<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dragon Liu</title>
  
  
  <link href="https://dragonliu2022.github.io/atom.xml" rel="self"/>
  
  <link href="https://dragonliu2022.github.io/"/>
  <updated>2022-06-05T15:46:39.668Z</updated>
  <id>https://dragonliu2022.github.io/</id>
  
  <author>
    <name>Dragon Liu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Lab3实验总结</title>
    <link href="https://dragonliu2022.github.io/2022/06/05/Lab3%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <id>https://dragonliu2022.github.io/2022/06/05/Lab3%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/</id>
    <published>2022-06-05T12:52:07.000Z</published>
    <updated>2022-06-05T15:46:39.668Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-前言"><a class="markdownIt-Anchor" href="#1-前言"></a> 1 前言</h1><p>这个编程实验需要实现一个简单的cache, 并尝试实现各种替换算法来优化程序的性能. 在代码目录下执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>来编译, 生成可执行文件 <code>a.out</code> . 其运行方式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./a.out [-r seed] [trace]</span><br></pre></td></tr></table></figure><p>其中 <code>seed</code> 是随机种子, 可以用于确定性回放帮助调试, 缺省时会用系统时间作为种子; <code>trace</code> 是 <code>bz2</code> 压缩格式的访存序列, 缺省时会产生随机访存序列来测试.</p><blockquote><p>具体见讲义：<a href="https://zhong-kangwei.gitee.io/ics-pa-gitbook-2022/lab3.html" target="_blank" rel="noopener">https://zhong-kangwei.gitee.io/ics-pa-gitbook-2022/lab3.html</a></p></blockquote><h1 id="2-实现"><a class="markdownIt-Anchor" href="#2-实现"></a> 2 实现</h1><h2 id="init_cache-20分"><a class="markdownIt-Anchor" href="#init_cache-20分"></a> init_cache （20分）</h2><ul><li><p>cache结构设计</p><ul><li><p>思路</p><p>主存<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn><mn>2</mn><mi>K</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mrow><mn>1</mn><mn>5</mn></mrow></msup><mi>B</mi></mrow><annotation encoding="application/x-tex">32KB=2^{15}B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">3</span><span class="mord mathrm">2</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mrel">=</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">5</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span>，块<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn><mn>4</mn><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>6</mn></msup><mi>B</mi></mrow><annotation encoding="application/x-tex">64B=2^6B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">6</span><span class="mord mathrm">4</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mrel">=</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">6</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span>，cache容量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>6</mn><mi>K</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mrow><mn>1</mn><mn>4</mn></mrow></msup><mi>B</mi></mrow><annotation encoding="application/x-tex">16KB=2^{14}B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">6</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mrel">=</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">4</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span>，行数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>6</mn><mi>K</mi><mi>B</mi><mi mathvariant="normal">/</mi><mn>6</mn><mn>4</mn><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>8</mn></msup><mi>B</mi></mrow><annotation encoding="application/x-tex">16KB/64B=2^8B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">6</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mord mathrm">/</span><span class="mord mathrm">6</span><span class="mord mathrm">4</span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mrel">=</span><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">8</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span>；由于四路组相联，所以cache组号占<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup><mi>B</mi><mi mathvariant="normal">/</mi><mn>4</mn><mo>=</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">2^8B/4=6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">2</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord mathrm">8</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.05017em;">B</span><span class="mord mathrm">/</span><span class="mord mathrm">4</span><span class="mrel">=</span><span class="mord mathrm">6</span></span></span></span>位，所以Tag占<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>5</mn><mo>−</mo><mn>6</mn><mo>−</mo><mn>6</mn><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">15-6-6=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">5</span><span class="mbin">−</span><span class="mord mathrm">6</span><span class="mbin">−</span><span class="mord mathrm">6</span><span class="mrel">=</span><span class="mord mathrm">3</span></span></span></span>位。</p></li><li><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="keyword">bool</span> valid_bit:<span class="number">1</span>;<span class="comment">//valid bit</span></span><br><span class="line"><span class="keyword">bool</span> tag:<span class="number">3</span>;<span class="comment">//Tag</span></span><br><span class="line"><span class="keyword">bool</span> data[<span class="number">64</span>];<span class="comment">//block: data</span></span><br><span class="line"><span class="keyword">bool</span> dirty_bit:<span class="number">1</span>;<span class="comment">//dirty bit</span></span><br><span class="line">&#125;Cache;</span><br><span class="line"></span><br><span class="line">Cache *cache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>cache初始化</p><ul><li><p>思路<br>算出总行数，然后遍历cache并将所有valid bit置为无效即可。</p></li><li><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_cache</span><span class="params">(<span class="keyword">int</span> total_size_width, <span class="keyword">int</span> associativity_width)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> lines = exp2( total_size_width - BLOCK_WIDTH );<span class="comment">//number of lines??</span></span><br><span class="line"><span class="comment">//printf("%d\n", lines);</span></span><br><span class="line">cache = <span class="built_in">malloc</span>( lines * <span class="keyword">sizeof</span>(Cache) );<span class="comment">//init a cache</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Set all valid bits as invalid</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; lines; i++ )&#123;</span><br><span class="line">cache[i].valid_bit = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="cache_read-30分"><a class="markdownIt-Anchor" href="#cache_read-30分"></a> cache_read (30分)</h2><ul><li><p>思路：首先将主存地址进行划分，然后分情况讨论：</p><ul><li>命中成功，在相关cache组中找到符合条件(tag位相同且有效位有效)的cache行，则直接从cache中读出；</li><li>命中失败，但在该组中有空闲行，则到主存读取一块信息并设置标记位；</li><li>命中失败且在该组中未找到空闲行，则任意替代该组的某一行并设置cache。</li></ul></li><li><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get data from cache</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">get_data</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> offset)</span></span>&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> ret = cache[num].data[offset] + </span><br><span class="line">(cache[num].data[offset + <span class="number">1</span>] &lt;&lt; <span class="number">8</span>) + </span><br><span class="line">(cache[num].data[offset + <span class="number">2</span>] &lt;&lt; <span class="number">16</span>) + </span><br><span class="line">(cache[num].data[offset + <span class="number">3</span>] &lt;&lt; <span class="number">24</span>);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">cache_read</span><span class="params">(<span class="keyword">uintptr_t</span> addr)</span> </span>&#123;</span><br><span class="line">try_increase(<span class="number">1</span>);<span class="comment">//visit cache times ++</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Memory address division</span></span><br><span class="line">addr = addr &amp; <span class="number">0x7FFF</span>;</span><br><span class="line"><span class="keyword">uint32_t</span> tag, cache_group_num, block_offset, block_num;</span><br><span class="line">block_offset = addr &amp; <span class="number">0x3C</span>;<span class="comment">//block addr: 6 bits, 4 bytes alignment</span></span><br><span class="line">cache_group_num = (addr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x3F</span>;<span class="comment">//cache group number: 6 bits</span></span><br><span class="line">tag = (addr &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x7</span>;<span class="comment">//tag: 3 bits</span></span><br><span class="line">block_num = (tag &lt;&lt; <span class="number">6</span>) | cache_group_num;<span class="comment">//memory block number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> paddr, ret_data;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;<span class="comment">//flag hit or not</span></span><br><span class="line"><span class="keyword">int</span> start = cache_group_num * <span class="number">4</span>;<span class="comment">//the start of a group</span></span><br><span class="line"><span class="keyword">int</span><span class="built_in">end</span>   = start + <span class="number">3</span>;          <span class="comment">//the end of a group</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Find the corresponding group</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = start ; i &lt;= <span class="built_in">end</span> ; i++ )&#123;</span><br><span class="line"><span class="comment">//Successful hit</span></span><br><span class="line"><span class="keyword">if</span>( cache[i].tag == tag &amp;&amp; cache[i].valid_bit )&#123;</span><br><span class="line">hit_increase(<span class="number">1</span>);</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line">ret_data = get_data(i, block_offset);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//failed hit</span></span><br><span class="line"><span class="keyword">if</span>( !flag )&#123;</span><br><span class="line"><span class="keyword">bool</span> flg = <span class="literal">false</span>;<span class="comment">// flag that is there a free line</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = start ; i &lt;= <span class="built_in">end</span>; i++ )&#123;</span><br><span class="line"><span class="comment">//find a free line</span></span><br><span class="line"><span class="keyword">if</span>( !cache[i].valid_bit  )&#123;</span><br><span class="line">flg = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//set cache</span></span><br><span class="line">mem_read(block_num, cache[i].data);<span class="comment">//read data from memory</span></span><br><span class="line">cache[i].tag = tag;</span><br><span class="line">cache[i].valid_bit = <span class="literal">true</span>;</span><br><span class="line">cache[i].dirty_bit = <span class="literal">false</span>;</span><br><span class="line">ret_data = get_data(i, block_offset); </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cannot find a free line, </span></span><br><span class="line"><span class="keyword">if</span>( !flg )&#123;</span><br><span class="line"><span class="keyword">int</span> rand_line = start + rand()%<span class="number">4</span>;<span class="comment">//find a random line</span></span><br><span class="line"><span class="comment">//if dirty, write first</span></span><br><span class="line"><span class="keyword">if</span>( cache[rand_line].dirty_bit )&#123;</span><br><span class="line">paddr = ( cache[rand_line].tag &lt;&lt; <span class="number">6</span> ) | cache_group_num ;</span><br><span class="line">mem_write(paddr, cache[rand_line].data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//set cache</span></span><br><span class="line">mem_read(block_num, cache[rand_line].data);</span><br><span class="line">cache[rand_line].tag = tag;</span><br><span class="line">cache[rand_line].valid_bit = <span class="literal">true</span>;</span><br><span class="line">cache[rand_line].dirty_bit = <span class="literal">false</span>;</span><br><span class="line">ret_data = get_data(rand_line, block_offset);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret_data;</span><br><span class="line"></span><br><span class="line"><span class="comment">//return 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="cache_write-30分"><a class="markdownIt-Anchor" href="#cache_write-30分"></a> cache_write (30分)</h2><ul><li><p>思路：首先将主存地址进行划分，然后分情况讨论(与读类似)：</p><ul><li>命中成功，在相关cache组中找到符合条件(tag位相同且有效位有效)的cache行，则根据写掩码写入cache并置脏位；</li><li>命中失败，但在该组中有空闲行，则根据写掩码写入cache并设置标记位；</li><li>命中失败且在该组中未找到空闲行，则随机取一行；判断脏位是否为1，若为1则将当前的cache行写回主存，然后根据写掩码写入cache并设置cache。</li></ul></li><li><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set the data of cache by wmask</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_cache</span><span class="params">(<span class="keyword">int</span> num , <span class="keyword">uint32_t</span> offset , <span class="keyword">uint32_t</span> wmask , <span class="keyword">uint32_t</span> data)</span></span>&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> standard_data;</span><br><span class="line">standard_data = get_data(num, offset); </span><br><span class="line">standard_data = ( standard_data &amp; ( ~ wmask) ) | (data &amp; wmask);</span><br><span class="line"></span><br><span class="line">cache[num].data[offset]     = standard_data         &amp; <span class="number">0xFF</span>;</span><br><span class="line">cache[num].data[offset + <span class="number">1</span>] = (standard_data &gt;&gt;  <span class="number">8</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">cache[num].data[offset + <span class="number">2</span>] = (standard_data &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">cache[num].data[offset + <span class="number">3</span>] = (standard_data &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_write</span><span class="params">(<span class="keyword">uintptr_t</span> addr, <span class="keyword">uint32_t</span> data, <span class="keyword">uint32_t</span> wmask)</span> </span>&#123;</span><br><span class="line">try_increase(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//Memory address division</span></span><br><span class="line">addr = addr &amp; <span class="number">0x7FFF</span>;</span><br><span class="line"><span class="keyword">uint32_t</span> tag, cache_group_num, block_offset, block_num;</span><br><span class="line">block_offset = addr &amp; <span class="number">0x3C</span>;</span><br><span class="line">cache_group_num = (addr &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x3F</span>;</span><br><span class="line">tag = (addr &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0x7</span>;</span><br><span class="line">    block_num = (tag &lt;&lt; <span class="number">6</span>) | cache_group_num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> paddr;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;<span class="comment">// flag write hit or not</span></span><br><span class="line"><span class="keyword">int</span> start = cache_group_num * <span class="number">4</span>;<span class="comment">//the start of a group</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">end</span>   = start + <span class="number">3</span>;<span class="comment">//the end of a group</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Find the corresponding group</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = start ; i &lt;= <span class="built_in">end</span>; i++ )&#123;</span><br><span class="line"><span class="comment">//successful hit</span></span><br><span class="line"><span class="keyword">if</span>( cache[i].tag == tag &amp;&amp; cache[i].valid_bit )&#123;</span><br><span class="line">hit_increase(<span class="number">1</span>);</span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line">set_cache(i, block_offset, wmask, data);<span class="comment">//write data</span></span><br><span class="line">cache[i].dirty_bit = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//failed hit</span></span><br><span class="line"><span class="keyword">if</span>( !flag )&#123;</span><br><span class="line"><span class="keyword">bool</span> flg = <span class="literal">false</span>;<span class="comment">//flag that is there a free line</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = start ; i &lt;= <span class="built_in">end</span>; i++ )&#123;</span><br><span class="line"><span class="comment">//find a free line</span></span><br><span class="line"><span class="keyword">if</span>( !cache[i].valid_bit )&#123;</span><br><span class="line">flg = <span class="literal">true</span>;</span><br><span class="line">mem_read(block_num, cache[i].data);<span class="comment">//read data from memory</span></span><br><span class="line">set_cache(i, block_offset, wmask, data);<span class="comment">//write data to cache</span></span><br><span class="line">cache[i].tag = tag;</span><br><span class="line">cache[i].valid_bit = <span class="literal">true</span>;</span><br><span class="line">cache[i].dirty_bit = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cannot find a free line</span></span><br><span class="line"><span class="keyword">if</span>( !flg )&#123;</span><br><span class="line"><span class="keyword">int</span> rand_line = start + rand()%<span class="number">4</span>;<span class="comment">//find a random line</span></span><br><span class="line"><span class="comment">//if dirty, write first</span></span><br><span class="line"><span class="keyword">if</span>( cache[rand_line].dirty_bit )&#123;</span><br><span class="line">paddr = ( cache[rand_line].tag &lt;&lt; <span class="number">6</span> ) | cache_group_num;</span><br><span class="line">mem_write(paddr, cache[rand_line].data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//set cache</span></span><br><span class="line">mem_read(block_num, cache[rand_line].data);</span><br><span class="line">set_cache(rand_line, block_offset, wmask , data);</span><br><span class="line">cache[rand_line].tag = tag;</span><br><span class="line">cache[rand_line].valid_bit = <span class="literal">true</span>;</span><br><span class="line">cache[rand_line].dirty_bit = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="最终结果截图20分"><a class="markdownIt-Anchor" href="#最终结果截图20分"></a> 最终结果截图（20分）</h2><img src="https://s2.loli.net/2022/06/05/TkSoKYvaZm7dDq1.jpg" width="800" height="200" alt="图片名称" align="center" id="206"><h2 id="思考题"><a class="markdownIt-Anchor" href="#思考题"></a> 思考题</h2><ul><li><strong>问</strong>：数据对齐和存储层次结构：想一想, 为什么编译器为变量分配存储空间的时候一般都会对齐? 访问一个没有对齐的存储空间会经历怎么样的过程?</li><li><strong>答</strong>：需要字节对齐的根本原因在于CPU访问数据的效率问题。若存储空间未对齐，则可能出现多次访存，然后组合成目标数据，因此带来指令执行效率的降低。</li><li><strong>参考</strong>：<ul><li><a href="https://blog.csdn.net/hunanchenxingyu/article/details/53942407" target="_blank" rel="noopener">为什么需要字节对齐</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计组" scheme="https://Dragonliu2022.github.io/categories/计组/"/>
    
    
  </entry>
  
  <entry>
    <title>gdb调试</title>
    <link href="https://dragonliu2022.github.io/2022/05/27/gdb%E8%B0%83%E8%AF%95/"/>
    <id>https://dragonliu2022.github.io/2022/05/27/gdb%E8%B0%83%E8%AF%95/</id>
    <published>2022-05-27T05:24:18.000Z</published>
    <updated>2022-05-27T05:47:04.178Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-前言"><a class="markdownIt-Anchor" href="#1-前言"></a> 1 前言</h1><p>gdb调试是必须要掌握的基本技能。</p><h1 id="2-安装gdb-peda"><a class="markdownIt-Anchor" href="#2-安装gdb-peda"></a> 2 安装gdb-peda</h1><p>gdb-peda是gdb的插件，加强gdb调试能力。</p><p>安装方法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ <span class="built_in">set</span> disassembly-flavor att$ git <span class="built_in">clone</span> htgdb-peda$ <span class="built_in">set</span> disassembly-flavor atttps://github.com/longld/peda.git ~/peda</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"source ~/peda/peda.py"</span> &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure><p>安装插件后汇编指令格式改为了intel模式，不太习惯，改变为AT&amp;T格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改为AT&amp;T格式</span></span><br><span class="line">gdb-peda$ <span class="built_in">set</span> disassembly-flavor att</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改为Intel格式</span></span><br><span class="line">gdb-peda$ <span class="built_in">set</span> disassembly-flavor intel</span><br></pre></td></tr></table></figure><p><strong>参考</strong>：<a href="https://blog.csdn.net/counsellor/article/details/81290335" target="_blank" rel="noopener">gdb-peda安装</a></p><p>此外，GDB dashboard插件也不错：<a href="https://github.com/cyrus-and/gdb-dashboard" target="_blank" rel="noopener">链接</a></p><h1 id="3-文档"><a class="markdownIt-Anchor" href="#3-文档"></a> 3 文档</h1><ul><li><a href="https://wizardforcel.gitbooks.io/100-gdb-tips/content/index.html" target="_blank" rel="noopener">《100个gdb小技巧》</a></li><li><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/" target="_blank" rel="noopener">gdb手册</a></li></ul><h1 id="4-gdb卡片"><a class="markdownIt-Anchor" href="#4-gdb卡片"></a> 4 GDB卡片</h1><img src="https://s2.loli.net/2022/05/27/joJaNUkKdB5Pnew.png" width="1000" height="800" alt="图片名称" align="center" id="204"><img src="https://s2.loli.net/2022/05/27/yrgOVkfGmJQxjDT.png" width="1000" height="800" alt="图片名称" align="center" id="205"><h1 id="5-常见指令"><a class="markdownIt-Anchor" href="#5-常见指令"></a> 5 常见指令</h1><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://blog.csdn.net/tianya_lu/article/details/123648314" target="_blank" rel="noopener">gdb基本命令(非常详细)</a></li><li><a href="https://www.cnblogs.com/qq78292959/archive/2012/07/20/2600865.html" target="_blank" rel="noopener">EAX、ECX、EDX、EBX寄存器的作用</a></li><li><a href="https://www.xianwaizhiyin.net/?p=1035" target="_blank" rel="noopener">X86汇编入门-寄存器32位 - 弦外之音</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="环境与工具" scheme="https://Dragonliu2022.github.io/categories/环境与工具/"/>
    
    
  </entry>
  
  <entry>
    <title>PA答疑之a4指令码报错</title>
    <link href="https://dragonliu2022.github.io/2022/05/27/PA%E7%AD%94%E7%96%91%E4%B9%8Ba4%E6%8C%87%E4%BB%A4%E7%A0%81%E6%8A%A5%E9%94%99/"/>
    <id>https://dragonliu2022.github.io/2022/05/27/PA%E7%AD%94%E7%96%91%E4%B9%8Ba4%E6%8C%87%E4%BB%A4%E7%A0%81%E6%8A%A5%E9%94%99/</id>
    <published>2022-05-27T05:06:36.000Z</published>
    <updated>2022-05-27T05:22:15.890Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题"><a class="markdownIt-Anchor" href="#1-问题"></a> 1 问题</h1><p>PA3.1在运行/bin/bmptest时，遇到提示a4这条指令没有实现的情况：</p><img src="https://s2.loli.net/2022/05/27/yOt4KiAgJuleBNQ.png" width="500" height="400" alt="图片名称" align="center" id="202"><h1 id="2-解决"><a class="markdownIt-Anchor" href="#2-解决"></a> 2 解决</h1><h2 id="21-法1"><a class="markdownIt-Anchor" href="#21-法1"></a> 2.1 法1</h2><p>在 navy-apps/Makefile.compile 修改o2为o0即可，这是关闭了代码优化，避免了⼀些数据未保存。</p><p>在navy-apps里make clean后再重新编译。</p><h2 id="22-法2"><a class="markdownIt-Anchor" href="#22-法2"></a> 2.2 法2</h2><p>实现a4指令：（<code>胡宇轩学弟</code>提供）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">make_EHelper(movsb)&#123;</span><br><span class="line">  vaddr_write(cpu.edi,<span class="number">1</span>,vaddr_read(cpu.esi,<span class="number">1</span>));</span><br><span class="line">  t0 = <span class="number">1</span>;</span><br><span class="line">  rtl_add(&amp;cpu.edi,&amp;cpu.edi,&amp;t0);</span><br><span class="line">  rtl_add(&amp;cpu.esi,&amp;cpu.esi,&amp;t0);</span><br><span class="line">  print_asm(<span class="string">"movbx"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DF等于0是递增，等于1是递减，具体实现见386手册：</p><img src="https://s2.loli.net/2022/05/27/AimEsOoM9XalY8c.png" width="600" height="400" alt="图片名称" align="center" id="203">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计组" scheme="https://Dragonliu2022.github.io/categories/计组/"/>
    
    
  </entry>
  
  <entry>
    <title>64位Ubuntu运行或调试32位程序</title>
    <link href="https://dragonliu2022.github.io/2022/05/26/64%E4%BD%8DUbuntu%E8%BF%90%E8%A1%8C32%E4%BD%8D%E7%A8%8B%E5%BA%8F/"/>
    <id>https://dragonliu2022.github.io/2022/05/26/64%E4%BD%8DUbuntu%E8%BF%90%E8%A1%8C32%E4%BD%8D%E7%A8%8B%E5%BA%8F/</id>
    <published>2022-05-26T05:20:32.000Z</published>
    <updated>2022-05-26T05:42:45.714Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题"><a class="markdownIt-Anchor" href="#1-问题"></a> 1 问题</h1><p>最近在做lab2，使用64位的Ubuntu发现无法调试和运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  lab ./bomb </span><br><span class="line">zsh: no such file or directory: ./bomb</span><br></pre></td></tr></table></figure><h1 id="2-解决"><a class="markdownIt-Anchor" href="#2-解决"></a> 2 解决</h1><p>ubuntu 64位下可以兼容32位程序的运行，但是必须要有32位基础库的支持才行。下面进行安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg --add-architecture i386</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386</span><br><span class="line">sudo apt install lib32z1</span><br></pre></td></tr></table></figure><p>安装完成后可以运行和调试了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  lab ./bomb </span><br><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line"><span class="built_in">which</span> to blow yourself up. Have a nice day!</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">➜  lab gdb ./bomb</span><br><span class="line">GNU gdb (Ubuntu 9.2-0ubuntu1~20.04.1) 9.2</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type <span class="string">"show copying"</span> and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"x86_64-linux-gnu"</span>.</span><br><span class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</span><br><span class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>...</span><br><span class="line">Reading symbols from ./bomb...</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/357653128" target="_blank" rel="noopener">ubuntu 64下运行32位程序</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计组" scheme="https://Dragonliu2022.github.io/categories/计组/"/>
    
    
  </entry>
  
  <entry>
    <title>MLP的pytorch实现</title>
    <link href="https://dragonliu2022.github.io/2022/05/16/MLP%E7%9A%84pytorch%E5%AE%9E%E7%8E%B0/"/>
    <id>https://dragonliu2022.github.io/2022/05/16/MLP%E7%9A%84pytorch%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-05-16T13:40:45.000Z</published>
    <updated>2022-05-16T16:24:02.585Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题"><a class="markdownIt-Anchor" href="#1-问题"></a> 1 问题</h1><p>xxx</p><h1 id="2-实现"><a class="markdownIt-Anchor" href="#2-实现"></a> 2 实现</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset, DataLoader</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score, precision_score, recall_score, f1_score, classification_report, confusion_matrix</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> label_binarize</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_curve, auc</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">torch.manual_seed(<span class="number">0</span>)</span><br><span class="line">torch.cuda.manual_seed_all(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"加载数据"</span>)</span><br><span class="line">digits = load_digits()</span><br><span class="line">data, label = digits.data, digits.target</span><br><span class="line"><span class="comment"># print(data.shape, label.shape)</span></span><br><span class="line">train_data, test_data, train_label, test_label = train_test_split(data, label, test_size=<span class="number">.3</span>, random_state=<span class="number">123</span>)</span><br><span class="line">print(<span class="string">'训练数据：'</span>, train_data.shape)</span><br><span class="line">print(<span class="string">'测试数据：'</span>, test_data.shape)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"定义相关参数"</span>)</span><br><span class="line">epochs = <span class="number">30</span></span><br><span class="line">batch_size = train_data.shape[<span class="number">0</span>]</span><br><span class="line">device = torch.device(<span class="string">"cuda:0"</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line">input_dim = data.shape[<span class="number">1</span>]</span><br><span class="line">hidden_dim = <span class="number">256</span></span><br><span class="line">output_dim = len(set(label))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"构建数据集"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DigitsDataset</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_data, input_label)</span>:</span></span><br><span class="line">    data = []</span><br><span class="line">    <span class="keyword">for</span> i,j <span class="keyword">in</span> zip(input_data, input_label):</span><br><span class="line">      data.append((i,j))</span><br><span class="line">    self.data = data</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(self.data)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">    d, l = self.data[index]</span><br><span class="line">    <span class="keyword">return</span> d, l</span><br><span class="line"></span><br><span class="line">trainDataset = DigitsDataset(train_data, train_label)</span><br><span class="line">testDataset = DigitsDataset(test_data, test_label)</span><br><span class="line"><span class="comment"># print(trainDataset[0])</span></span><br><span class="line"><span class="comment"># print(trainDataset[0])</span></span><br><span class="line">trainDataLoader = DataLoader(trainDataset, batch_size=batch_size, shuffle=<span class="literal">True</span>, num_workers=<span class="number">0</span>)  <span class="comment"># 2改为0</span></span><br><span class="line">testDataLoader = DataLoader(testDataset, batch_size=batch_size, shuffle=<span class="literal">False</span>, num_workers=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_dim, hidden_dim, output_dim)</span>:</span></span><br><span class="line">    super(Model, self).__init__()</span><br><span class="line">    self.fc1 = nn.Linear(input_dim, hidden_dim)</span><br><span class="line">    self.relu = nn.ReLU()</span><br><span class="line">    self.fc2 = nn.Linear(hidden_dim, output_dim)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    x = self.fc1(x)</span><br><span class="line">    x = self.relu(x)</span><br><span class="line">    x = self.fc2(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">model = Model(input_dim, hidden_dim, output_dim)</span><br><span class="line">print(model)</span><br><span class="line">model.to(device)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"定义损失函数、优化器"</span>)</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=<span class="number">0.01</span>, momentum=<span class="number">0.9</span>, weight_decay=<span class="number">1e-4</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"初始化相关参数"</span>)</span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> model.parameters():</span><br><span class="line">  nn.init.normal_(param, mean=<span class="number">0</span>, std=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">"开始训练主循环"</span>)</span><br><span class="line">total_step = len(trainDataLoader)</span><br><span class="line"></span><br><span class="line">model.train()</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(epochs):</span><br><span class="line">  tot_loss = <span class="number">0.0</span></span><br><span class="line">  tot_acc = <span class="number">0.0</span></span><br><span class="line">  train_preds = []</span><br><span class="line">  train_trues = []</span><br><span class="line">  <span class="comment"># model.train()</span></span><br><span class="line">  <span class="keyword">for</span> i,(train_data_batch, train_label_batch) <span class="keyword">in</span> enumerate(trainDataLoader):</span><br><span class="line">    train_data_batch = train_data_batch.float().to(device) <span class="comment"># 将double数据转换为float</span></span><br><span class="line">    train_label_batch = train_label_batch.to(device)</span><br><span class="line">    outputs = model(train_data_batch)</span><br><span class="line">    <span class="comment"># _, preds = torch.max(outputs.data, 1)</span></span><br><span class="line">    loss = criterion(outputs, train_label_batch.type(torch.LongTensor))</span><br><span class="line">    <span class="comment"># print(loss)</span></span><br><span class="line">    <span class="comment">#反向传播优化网络参数</span></span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    <span class="comment">#累加每个step的损失</span></span><br><span class="line">    tot_loss += loss.data</span><br><span class="line">    train_outputs = outputs.argmax(dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    train_preds.extend(train_outputs.detach().cpu().numpy())</span><br><span class="line">    train_trues.extend(train_label_batch.detach().cpu().numpy())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># tot_acc += (outputs.argmax(dim=1) == train_label_batch).sum().item()</span></span><br><span class="line"></span><br><span class="line">  sklearn_accuracy = accuracy_score(train_trues, train_preds)</span><br><span class="line">  sklearn_precision = precision_score(train_trues, train_preds, average=<span class="string">'micro'</span>)</span><br><span class="line">  sklearn_recall = recall_score(train_trues, train_preds, average=<span class="string">'micro'</span>)</span><br><span class="line">  sklearn_f1 = f1_score(train_trues, train_preds, average=<span class="string">'micro'</span>)</span><br><span class="line">  print(<span class="string">"[sklearn_metrics] Epoch:&#123;&#125; loss:&#123;:.4f&#125; accuracy:&#123;:.4f&#125; precision:&#123;:.4f&#125; recall:&#123;:.4f&#125; f1:&#123;:.4f&#125;"</span>.format(epoch, tot_loss, sklearn_accuracy, sklearn_precision, sklearn_recall, sklearn_f1))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_confusion_matrix</span><span class="params">(trues, preds)</span>:</span></span><br><span class="line">  labels = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">  conf_matrix = confusion_matrix(trues, preds, labels=labels)</span><br><span class="line">  <span class="keyword">return</span> conf_matrix</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_confusion_matrix</span><span class="params">(conf_matrix)</span>:</span></span><br><span class="line">  plt.imshow(conf_matrix, cmap=plt.cm.Greens)</span><br><span class="line">  indices = range(conf_matrix.shape[<span class="number">0</span>])</span><br><span class="line">  labels = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">  plt.xticks(indices, labels)</span><br><span class="line">  plt.yticks(indices, labels)</span><br><span class="line">  plt.colorbar()</span><br><span class="line">  plt.xlabel(<span class="string">'y_pred'</span>)</span><br><span class="line">  plt.ylabel(<span class="string">'y_true'</span>)</span><br><span class="line">  <span class="comment"># 显示数据</span></span><br><span class="line">  <span class="keyword">for</span> first_index <span class="keyword">in</span> range(conf_matrix.shape[<span class="number">0</span>]):</span><br><span class="line">    <span class="keyword">for</span> second_index <span class="keyword">in</span> range(conf_matrix.shape[<span class="number">1</span>]):</span><br><span class="line">      plt.text(first_index, second_index, conf_matrix[first_index, second_index])</span><br><span class="line">  plt.savefig(<span class="string">'heatmap_confusion_matrix.jpg'</span>)</span><br><span class="line">  plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test_preds = []</span><br><span class="line">test_trues = []</span><br><span class="line">model.eval()</span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">  <span class="keyword">for</span> i,(test_data_batch, test_data_label) <span class="keyword">in</span> enumerate(testDataLoader):</span><br><span class="line">    test_data_batch = test_data_batch.float().to(device) <span class="comment"># 将double数据转换为float</span></span><br><span class="line">    test_data_label = test_data_label.to(device)</span><br><span class="line">    test_outputs = model(test_data_batch)</span><br><span class="line">    test_outputs = test_outputs.argmax(dim=<span class="number">1</span>)</span><br><span class="line">    test_preds.extend(test_outputs.detach().cpu().numpy())</span><br><span class="line">    test_trues.extend(test_data_label.detach().cpu().numpy())</span><br><span class="line"></span><br><span class="line">  sklearn_precision = precision_score(test_trues, test_preds, average=<span class="string">'micro'</span>)</span><br><span class="line">  sklearn_recall = recall_score(test_trues, test_preds, average=<span class="string">'micro'</span>)</span><br><span class="line">  sklearn_f1 = f1_score(test_trues, test_preds, average=<span class="string">'micro'</span>)</span><br><span class="line">  print(classification_report(test_trues, test_preds))</span><br><span class="line">  conf_matrix = get_confusion_matrix(test_trues, test_preds)</span><br><span class="line">  print(conf_matrix)</span><br><span class="line">  plot_confusion_matrix(conf_matrix)</span><br><span class="line">  print(<span class="string">"[sklearn_metrics] accuracy:&#123;:.4f&#125; precision:&#123;:.4f&#125; recall:&#123;:.4f&#125; f1:&#123;:.4f&#125;"</span>.format(sklearn_accuracy, sklearn_precision, sklearn_recall, sklearn_f1))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Press the green button in the gutter to run the script.</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    print(<span class="string">'train-mlp'</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line">    print((end - start) / <span class="number">60</span>, <span class="string">"min"</span>)  <span class="comment"># 秒</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="AI" scheme="https://Dragonliu2022.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>sklean常见机器学习分类器</title>
    <link href="https://dragonliu2022.github.io/2022/05/16/sklean%E5%B8%B8%E8%A7%81%E5%88%86%E7%B1%BB%E5%99%A8/"/>
    <id>https://dragonliu2022.github.io/2022/05/16/sklean%E5%B8%B8%E8%A7%81%E5%88%86%E7%B1%BB%E5%99%A8/</id>
    <published>2022-05-16T12:28:16.000Z</published>
    <updated>2022-05-16T13:39:46.135Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题"><a class="markdownIt-Anchor" href="#1-问题"></a> 1 问题</h1><p>使用python的机器学习库sklearn实现常见的机器学习分类算法，如决策树、随机森林等。</p><h1 id="2-代码实现"><a class="markdownIt-Anchor" href="#2-代码实现"></a> 2 代码实现</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rf_train</span><span class="params">()</span>:</span></span><br><span class="line">    api_train = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]])</span><br><span class="line">    type_train = np.array([<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">    api_test = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">    type_test = np.array([<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    clf = DecisionTreeClassifier(random_state=<span class="number">0</span>)</span><br><span class="line">    rfc = RandomForestClassifier(random_state=<span class="number">0</span>)</span><br><span class="line">    clf = clf.fit(api_train, type_train)</span><br><span class="line">    rfc = rfc.fit(api_train, type_train)</span><br><span class="line">    score_c = clf.score(api_test, type_test)</span><br><span class="line">    score_r = rfc.score(api_test, type_test)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"Single Tree:&#123;&#125;"</span>.format(score_c), <span class="string">"Random Forest:&#123;&#125;"</span>.format(score_r))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    print(<span class="string">'最终版-随机森林'</span>)</span><br><span class="line"></span><br><span class="line">    end = time.time()</span><br><span class="line">    print((end - start) / <span class="number">60</span>, <span class="string">"min"</span>)  <span class="comment"># 秒</span></span><br></pre></td></tr></table></figure><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://blog.csdn.net/weixin_41571493/article/details/83011147" target="_blank" rel="noopener">【机器学习】Sklearn 常用分类器（全）</a></li><li></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="AI" scheme="https://Dragonliu2022.github.io/categories/AI/"/>
    
    
  </entry>
  
  <entry>
    <title>Lab2实验总结</title>
    <link href="https://dragonliu2022.github.io/2022/05/15/Lab2%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <id>https://dragonliu2022.github.io/2022/05/15/Lab2%E5%AE%9E%E9%AA%8C%E6%80%BB%E7%BB%93/</id>
    <published>2022-05-15T13:58:16.000Z</published>
    <updated>2022-05-27T04:24:09.518Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-准备"><a class="markdownIt-Anchor" href="#1-准备"></a> 1 准备</h1><h2 id="11-安装gdb-peda"><a class="markdownIt-Anchor" href="#11-安装gdb-peda"></a> 1.1 安装gdb-peda</h2><p>gdb-peda是gdb的插件，加强gdb调试能力。</p><p>安装方法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ <span class="built_in">set</span> disassembly-flavor att$ git <span class="built_in">clone</span> htgdb-peda$ <span class="built_in">set</span> disassembly-flavor atttps://github.com/longld/peda.git ~/peda</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"source ~/peda/peda.py"</span> &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure><p>安装插件后汇编指令格式改为了intel模式，不太习惯，改变为AT&amp;T格式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改为AT&amp;T格式</span></span><br><span class="line">gdb-peda$ <span class="built_in">set</span> disassembly-flavor att</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改为Intel格式</span></span><br><span class="line">gdb-peda$ <span class="built_in">set</span> disassembly-flavor intel</span><br></pre></td></tr></table></figure><p><strong>参考</strong>：<a href="https://blog.csdn.net/counsellor/article/details/81290335" target="_blank" rel="noopener">gdb-peda安装</a></p><h2 id="12-gdbpeda使用"><a class="markdownIt-Anchor" href="#12-gdbpeda使用"></a> 1.2 gdb&amp;peda使用</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 载入可执行程序</span></span><br><span class="line">gdb &lt;file name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置断点</span></span><br><span class="line">b &lt;地址或函数名等&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># (重新)运行程序，若有断点，会卡在第一个断点</span></span><br><span class="line">r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 继续执行程序至下一个断点</span></span><br><span class="line">c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行一(n)条指令，进入call</span></span><br><span class="line">s &lt;n&gt;</span><br><span class="line"><span class="comment"># 执行一(n)条指令，不进入call</span></span><br><span class="line">n &lt;n&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看断点</span></span><br><span class="line">info b</span><br><span class="line">i b</span><br><span class="line"><span class="comment"># 删除断点 n为断点编号</span></span><br><span class="line">delete &lt;n&gt;</span><br><span class="line">d &lt;n&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反汇编，func为某个函数</span></span><br><span class="line">disassemble &lt;func&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示addr处的内存信息</span></span><br><span class="line">x/nfu &lt;addr&gt;</span><br><span class="line"><span class="comment">#n表示输出单元的个数</span></span><br><span class="line"><span class="comment">#f是输出格式。比如x是以16进制形式输出，o是以8进制形式输出等等。</span></span><br><span class="line"><span class="comment">#u标明一个单元的长度。b是一个byte，h是两个byte（halfword），w是四个byte（word），g是八个byte（giant word）。</span></span><br></pre></td></tr></table></figure><h2 id="13-计组知识"><a class="markdownIt-Anchor" href="#13-计组知识"></a> 1.3 计组知识</h2><p><strong>汇编格式</strong>：</p><ul><li>Intel格式：目的操作数在左，MASM采用</li><li>AT&amp;T格式：目的操作数在右，objdump和gcc默认格式</li></ul><p><strong>栈</strong>：</p><ul><li>先进后出</li><li>从高地址向低地址增长</li><li>ESP指向栈顶</li><li>EBP指向栈底</li></ul><p><strong>大小端模式</strong>：</p><ul><li>大端（Big-Endian）：高字节存低地址，低字节存低高地址</li><li>小端（Little-Endian）：低字节存低地址，高字节存高地址</li></ul><p><strong>常见指令</strong>：</p><ul><li><code>push</code>：R[sp] ← R[sp] - 2 或者  R[esp] ← R[esp] - 4，然后将一个字或双字从指定寄存器送到SP或者ESP指示的单元；</li><li><code>pop</code>：然后将一个字或双字从SP或者ESP指示的单元送到指定寄存器，再执行R[sp] ← R[sp] + 2 或者  R[esp] ← R[esp] + 4</li><li><code>call &lt;func_addr&gt;</code>：先push EIP（当前指令的第一条指令地址），再执行jmp &lt;func_addr&gt;</li><li><code>ret</code>：pop EIP</li><li><code>leave</code>：先执行mov %ebp %esp，再pop %ebp</li></ul><h2 id="14-lab概览"><a class="markdownIt-Anchor" href="#14-lab概览"></a> 1.4 lab概览</h2><p>通过IDA打开bomb文件，找到主函数main，发现需要需要进行六次输入，对应phase_1到phase_6函数，每次输入需要躲开explode_bomb()函数，否则拆炸弹失败。</p><h1 id="2-phase_1"><a class="markdownIt-Anchor" href="#2-phase_1"></a> 2 phase_1</h1><h2 id="21-解析"><a class="markdownIt-Anchor" href="#21-解析"></a> 2.1 解析</h2><p>IDA查看phase_1函数伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">phase_1</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  result = strings_not_equal(a1, <span class="string">"And they have no disregard for human life."</span>);</span><br><span class="line">  <span class="keyword">if</span> ( result )</span><br><span class="line">    explode_bomb();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gdb查看phase_1函数汇编代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ disassemble phase_1</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> phase_1:</span><br><span class="line">=&gt; 0x00401662 &lt;+0&gt;:     endbr32</span><br><span class="line">   0x00401666 &lt;+4&gt;:     push   ebp</span><br><span class="line">   0x00401667 &lt;+5&gt;:     mov    ebp,esp</span><br><span class="line">   0x00401669 &lt;+7&gt;:     push   ebx</span><br><span class="line">   0x0040166a &lt;+8&gt;:     sub    esp,0xc</span><br><span class="line">   0x0040166d &lt;+11&gt;:    call   0x4013d0 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line">   0x00401672 &lt;+16&gt;:    add    ebx,0x38f2</span><br><span class="line">   0x00401678 &lt;+22&gt;:    lea    eax,[ebx-0x1e20]</span><br><span class="line">   0x0040167e &lt;+28&gt;:    push   eax</span><br><span class="line">   0x0040167f &lt;+29&gt;:    push   DWORD PTR [ebp+0x8]</span><br><span class="line">   0x00401682 &lt;+32&gt;:    call   0x401bdf &lt;strings_not_equal&gt;</span><br><span class="line">   0x00401687 &lt;+37&gt;:    add    esp,0x10</span><br><span class="line">   0x0040168a &lt;+40&gt;:    <span class="built_in">test</span>   eax,eax</span><br><span class="line">   0x0040168c &lt;+42&gt;:    jne    0x401693 &lt;phase_1+49&gt;</span><br><span class="line">   0x0040168e &lt;+44&gt;:    mov    ebx,DWORD PTR [ebp-0x4]</span><br><span class="line">   0x00401691 &lt;+47&gt;:    leave</span><br><span class="line">   0x00401692 &lt;+48&gt;:    ret</span><br><span class="line">   0x00401693 &lt;+49&gt;:    call   0x401e64 &lt;explode_bomb&gt;</span><br><span class="line">   0x00401698 &lt;+54&gt;:    jmp    0x40168e &lt;phase_1+44&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><h2 id="22-思路"><a class="markdownIt-Anchor" href="#22-思路"></a> 2.2 思路</h2><p>看伪代码直接得出答案，输入需要与给定字符串一致。</p><hr><p>如果不看伪代码，使用gdb动态调试则：</p><ol><li><p>载入bomb：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ gdb bomb</span><br><span class="line">GNU gdb (Debian 8.2.1-2+b3) 8.2.1</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type <span class="string">"show copying"</span> and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"i686-linux-gnu"</span>.</span><br><span class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</span><br><span class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>...</span><br><span class="line"></span><br><span class="line">warning: build/bdist.linux-i686/wheel/peda/peda.py: No such file or directory</span><br><span class="line">Reading symbols from bomb...done.</span><br><span class="line">gdb-peda$</span><br></pre></td></tr></table></figure></li><li><p>在main函数处打断点，并执行到该断点：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ b main</span><br><span class="line">Breakpoint 1 at 0x14cd: file bomb.c, line 37.</span><br><span class="line">gdb-peda$ r</span><br></pre></td></tr></table></figure></li><li><p>在phase_1函数处打断点，并执行到该断点：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ b phase_1</span><br><span class="line">Breakpoint 2 at 0x401662</span><br><span class="line">gdb-peda$ c</span><br><span class="line">Continuing.</span><br><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line"><span class="built_in">which</span> to blow yourself up. Have a nice day!</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x401651 &lt;main+388&gt;: call   0x401300 &lt;__printf_chk@plt&gt;</span><br><span class="line">   0x401656 &lt;main+393&gt;: mov    DWORD PTR [esp],0x8</span><br><span class="line">   0x40165d &lt;main+400&gt;: call   0x4012a0 &lt;<span class="built_in">exit</span>@plt&gt;</span><br><span class="line">=&gt; 0x401662 &lt;phase_1&gt;:  endbr32</span><br><span class="line">   0x401666 &lt;phase_1+4&gt;:        push   ebp</span><br><span class="line">   0x401667 &lt;phase_1+5&gt;:        mov    ebp,esp</span><br><span class="line">   0x401669 &lt;phase_1+7&gt;:        push   ebx</span><br><span class="line">   0x40166a &lt;phase_1+8&gt;:        sub    esp,0xc</span><br></pre></td></tr></table></figure></li><li><p>执行8步到<code>0x0040167e &lt;+28&gt;: push eax</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ n 8</span><br><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0x403144 (<span class="string">"And they have no disregard for human life."</span>)</span><br><span class="line">EBX: 0x404f64 --&gt; 0x4e6c (<span class="string">'lN'</span>)</span><br><span class="line">ECX: 0x2b (<span class="string">'+'</span>)</span><br><span class="line">EDX: 0x1</span><br><span class="line">ESI: 0xbffff574 --&gt; 0xbffff6bf (<span class="string">"/home/liuzhenlong/lab_debug/bomb_162020203/bomb95/bomb"</span>)</span><br><span class="line">EDI: 0xb7fbc000 --&gt; 0x1d9d6c</span><br><span class="line">EBP: 0xbffff498 --&gt; 0xbffff4c8 --&gt; 0x0</span><br><span class="line">ESP: 0xbffff488 --&gt; 0xb7e13cb9 (&lt;__new_exitfn+9&gt;:       add    ebx,0x1a8347)</span><br><span class="line">EIP: 0x40167e (&lt;phase_1+28&gt;:    push   eax)</span><br><span class="line">EFLAGS: 0x202 (carry parity adjust zero sign <span class="built_in">trap</span> INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x40166d &lt;phase_1+11&gt;:       call   0x4013d0 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line">   0x401672 &lt;phase_1+16&gt;:       add    ebx,0x38f2</span><br><span class="line">   0x401678 &lt;phase_1+22&gt;:       lea    eax,[ebx-0x1e20]</span><br><span class="line">=&gt; 0x40167e &lt;phase_1+28&gt;:       push   eax</span><br><span class="line">   0x40167f &lt;phase_1+29&gt;:       push   DWORD PTR [ebp+0x8]</span><br><span class="line">   0x401682 &lt;phase_1+32&gt;:       call   0x401bdf &lt;strings_not_equal&gt;</span><br><span class="line">   0x401687 &lt;phase_1+37&gt;:       add    esp,0x10</span><br><span class="line">   0x40168a &lt;phase_1+40&gt;:       <span class="built_in">test</span>   eax,eax</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xbffff488 --&gt; 0xb7e13cb9 (&lt;__new_exitfn+9&gt;:      add    ebx,0x1a8347)</span><br><span class="line">0004| 0xbffff48c --&gt; 0x404f64 --&gt; 0x4e6c (<span class="string">'lN'</span>)</span><br><span class="line">0008| 0xbffff490 --&gt; 0xbffff574 --&gt; 0xbffff6bf (<span class="string">"/home/liuzhenlong/lab_debug/bomb_162020203/bomb95/bomb"</span>)</span><br><span class="line">0012| 0xbffff494 --&gt; 0x404f64 --&gt; 0x4e6c (<span class="string">'lN'</span>)</span><br><span class="line">0016| 0xbffff498 --&gt; 0xbffff4c8 --&gt; 0x0</span><br><span class="line">0020| 0xbffff49c --&gt; 0x40155a (&lt;main+141&gt;:      call   0x40203c &lt;phase_defused&gt;)</span><br><span class="line">0024| 0xbffff4a0 --&gt; 0x405760 (<span class="string">"And they have no disregard for human life."</span>)</span><br><span class="line">0028| 0xbffff4a4 --&gt; 0x404f64 --&gt; 0x4e6c (<span class="string">'lN'</span>)</span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">0x0040167e <span class="keyword">in</span> phase_1 ()</span><br></pre></td></tr></table></figure><p>此时可以看到EAX中所指向的字符串，也就是答案。</p></li></ol><p><strong>答案</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">And they have no disregard <span class="keyword">for</span> human life.</span><br></pre></td></tr></table></figure><h1 id="3-phase_2"><a class="markdownIt-Anchor" href="#3-phase_2"></a> 3 phase_2</h1><h2 id="31-解析"><a class="markdownIt-Anchor" href="#31-解析"></a> 3.1 解析</h2><p>IDA查看phase_2函数伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">read_six_numbers</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  result = __isoc99_sscanf(a1, &amp;unk_33A1, a2, a2 + <span class="number">4</span>, a2 + <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">if</span> ( result &lt;= <span class="number">5</span> )</span><br><span class="line">    explode_bomb();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> __cdecl <span class="title">phase_2</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *v1; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v3[<span class="number">5</span>]; <span class="comment">// [esp+Ch] [ebp-34h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v4; <span class="comment">// [esp+20h] [ebp-20h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// [esp+24h] [ebp-1Ch]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  read_six_numbers(a1, v3);</span><br><span class="line">  <span class="keyword">if</span> ( v3[<span class="number">0</span>] != <span class="number">1</span> )</span><br><span class="line">    explode_bomb();</span><br><span class="line">  v1 = v3;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v1[<span class="number">1</span>] != <span class="number">2</span> * *v1 )</span><br><span class="line">      explode_bomb();</span><br><span class="line">    ++v1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v1 != (<span class="keyword">int</span> *)&amp;v4 );</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gdb查看phase_2函数汇编代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ disassemble phase_2</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> phase_2:</span><br><span class="line">   0x0040169a &lt;+0&gt;:     endbr32</span><br><span class="line">   0x0040169e &lt;+4&gt;:     push   ebp</span><br><span class="line">   0x0040169f &lt;+5&gt;:     mov    ebp,esp</span><br><span class="line">   0x004016a1 &lt;+7&gt;:     push   edi</span><br><span class="line">   0x004016a2 &lt;+8&gt;:     push   esi</span><br><span class="line">   0x004016a3 &lt;+9&gt;:     push   ebx</span><br><span class="line">   0x004016a4 &lt;+10&gt;:    sub    esp,0x34</span><br><span class="line">   0x004016a7 &lt;+13&gt;:    call   0x4013d0 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line">   0x004016ac &lt;+18&gt;:    add    ebx,0x38b8</span><br><span class="line">   0x004016b2 &lt;+24&gt;:    mov    eax,gs:0x14</span><br><span class="line">   0x004016b8 &lt;+30&gt;:    mov    DWORD PTR [ebp-0x1c],eax</span><br><span class="line">   0x004016bb &lt;+33&gt;:    xor    eax,eax</span><br><span class="line">   0x004016bd &lt;+35&gt;:    lea    eax,[ebp-0x34]</span><br><span class="line">   0x004016c0 &lt;+38&gt;:    push   eax</span><br><span class="line">   0x004016c1 &lt;+39&gt;:    push   DWORD PTR [ebp+0x8]</span><br><span class="line">   0x004016c4 &lt;+42&gt;:    call   0x401eba &lt;read_six_numbers&gt;</span><br><span class="line">   0x004016c9 &lt;+47&gt;:    add    esp,0x10</span><br><span class="line">   0x004016cc &lt;+50&gt;:    cmp    DWORD PTR [ebp-0x34],0x1</span><br><span class="line">   0x004016d0 &lt;+54&gt;:    jne    0x4016da &lt;phase_2+64&gt;</span><br><span class="line">   0x004016d2 &lt;+56&gt;:    lea    esi,[ebp-0x34]</span><br><span class="line">   0x004016d5 &lt;+59&gt;:    lea    edi,[ebp-0x20]</span><br><span class="line">   0x004016d8 &lt;+62&gt;:    jmp    0x4016ed &lt;phase_2+83&gt;</span><br><span class="line">   0x004016da &lt;+64&gt;:    call   0x401e64 &lt;explode_bomb&gt;</span><br><span class="line">   0x004016df &lt;+69&gt;:    jmp    0x4016d2 &lt;phase_2+56&gt;</span><br><span class="line">   0x004016e1 &lt;+71&gt;:    call   0x401e64 &lt;explode_bomb&gt;</span><br><span class="line">   0x004016e6 &lt;+76&gt;:    add    esi,0x4</span><br><span class="line">   0x004016e9 &lt;+79&gt;:    cmp    esi,edi</span><br><span class="line">   0x004016eb &lt;+81&gt;:    je     0x4016f8 &lt;phase_2+94&gt;</span><br><span class="line">   0x004016ed &lt;+83&gt;:    mov    eax,DWORD PTR [esi]</span><br><span class="line">   0x004016ef &lt;+85&gt;:    add    eax,eax</span><br><span class="line">   0x004016f1 &lt;+87&gt;:    cmp    DWORD PTR [esi+0x4],eax</span><br><span class="line">   0x004016f4 &lt;+90&gt;:    je     0x4016e6 &lt;phase_2+76&gt;</span><br><span class="line">   0x004016f6 &lt;+92&gt;:    jmp    0x4016e1 &lt;phase_2+71&gt;</span><br><span class="line">   0x004016f8 &lt;+94&gt;:    mov    eax,DWORD PTR [ebp-0x1c]</span><br><span class="line">   0x004016fb &lt;+97&gt;:    xor    eax,DWORD PTR gs:0x14</span><br><span class="line">   0x00401702 &lt;+104&gt;:   jne    0x40170c &lt;phase_2+114&gt;</span><br><span class="line">   0x00401704 &lt;+106&gt;:   lea    esp,[ebp-0xc]</span><br><span class="line">   0x00401707 &lt;+109&gt;:   pop    ebx</span><br><span class="line">   0x00401708 &lt;+110&gt;:   pop    esi</span><br><span class="line">   0x00401709 &lt;+111&gt;:   pop    edi</span><br><span class="line">   0x0040170a &lt;+112&gt;:   pop    ebp</span><br><span class="line">   0x0040170b &lt;+113&gt;:   ret</span><br><span class="line">   0x0040170c &lt;+114&gt;:   call   0x402e00 &lt;__stack_chk_fail_local&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><h2 id="32-思路"><a class="markdownIt-Anchor" href="#32-思路"></a> 3.2 思路</h2><p>从伪代码看：需要输入6个数字，而且第一个数字为1，后面的数字是前面的两倍。</p><p><strong>答案</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 4 8 16 32</span><br></pre></td></tr></table></figure><h1 id="4-phase_3"><a class="markdownIt-Anchor" href="#4-phase_3"></a> 4 phase_3</h1><h2 id="41-解析"><a class="markdownIt-Anchor" href="#41-解析"></a> 4.1 解析</h2><p>IDA查看phase_3函数伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __cdecl <span class="title">phase_3</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v1; <span class="comment">// [esp+4h] [ebp-14h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v2[<span class="number">3</span>]; <span class="comment">// [esp+8h] [ebp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v2[<span class="number">1</span>] = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( __isoc99_sscanf(a1, <span class="string">"%d %d"</span>, &amp;v1, v2) &gt; <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v1 &lt;= <span class="number">7</span> )</span><br><span class="line">      __asm &#123; jmp     edx &#125;</span><br><span class="line">    explode_bomb();</span><br><span class="line">  &#125;</span><br><span class="line">  explode_bomb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gdb查看phase_3函数汇编代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ disassemble phase_3</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> phase_3:</span><br><span class="line">=&gt; 0x00401711 &lt;+0&gt;:     endbr32</span><br><span class="line">   0x00401715 &lt;+4&gt;:     push   ebp</span><br><span class="line">   0x00401716 &lt;+5&gt;:     mov    ebp,esp</span><br><span class="line">   0x00401718 &lt;+7&gt;:     push   ebx</span><br><span class="line">   0x00401719 &lt;+8&gt;:     sub    esp,0x14</span><br><span class="line">   0x0040171c &lt;+11&gt;:    call   0x4013d0 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line">   0x00401721 &lt;+16&gt;:    add    ebx,0x3843</span><br><span class="line">   0x00401727 &lt;+22&gt;:    mov    eax,gs:0x14</span><br><span class="line">   0x0040172d &lt;+28&gt;:    mov    DWORD PTR [ebp-0xc],eax</span><br><span class="line">   0x00401730 &lt;+31&gt;:    xor    eax,eax</span><br><span class="line">   0x00401732 &lt;+33&gt;:    lea    eax,[ebp-0x10]</span><br><span class="line">   0x00401735 &lt;+36&gt;:    push   eax</span><br><span class="line">   0x00401736 &lt;+37&gt;:    lea    eax,[ebp-0x14]</span><br><span class="line">   0x00401739 &lt;+40&gt;:    push   eax</span><br><span class="line">   0x0040173a &lt;+41&gt;:    lea    eax,[ebx-0x1bb7]</span><br><span class="line">   0x00401740 &lt;+47&gt;:    push   eax</span><br><span class="line">   0x00401741 &lt;+48&gt;:    push   DWORD PTR [ebp+0x8]</span><br><span class="line">   0x00401744 &lt;+51&gt;:    call   0x4012d0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x00401749 &lt;+56&gt;:    add    esp,0x10</span><br><span class="line">   0x0040174c &lt;+59&gt;:    cmp    eax,0x1</span><br><span class="line">   0x0040174f &lt;+62&gt;:    jle    0x40176a &lt;phase_3+89&gt;</span><br><span class="line">   0x00401751 &lt;+64&gt;:    cmp    DWORD PTR [ebp-0x14],0x7</span><br><span class="line">   0x00401755 &lt;+68&gt;:    ja     0x4017e1 &lt;phase_3+208&gt;</span><br><span class="line">   0x0040175b &lt;+74&gt;:    mov    eax,DWORD PTR [ebp-0x14]</span><br><span class="line">   0x0040175e &lt;+77&gt;:    mov    edx,ebx</span><br><span class="line">   0x00401760 &lt;+79&gt;:    add    edx,DWORD PTR [ebx+eax*4-0x1dc4]</span><br><span class="line">   0x00401767 &lt;+86&gt;:    notrack jmp edx</span><br><span class="line">   0x0040176a &lt;+89&gt;:    call   0x401e64 &lt;explode_bomb&gt;</span><br><span class="line">   0x0040176f &lt;+94&gt;:    jmp    0x401751 &lt;phase_3+64&gt;</span><br><span class="line">   0x00401771 &lt;+96&gt;:    mov    eax,0x398</span><br><span class="line">   0x00401776 &lt;+101&gt;:   sub    eax,0xd8</span><br><span class="line">   0x0040177b &lt;+106&gt;:   add    eax,0x1ad</span><br><span class="line">   0x00401780 &lt;+111&gt;:   sub    eax,0x3e</span><br><span class="line">   0x00401783 &lt;+114&gt;:   add    eax,0x3e</span><br><span class="line">   0x00401786 &lt;+117&gt;:   sub    eax,0x3e</span><br><span class="line">   0x00401789 &lt;+120&gt;:   add    eax,0x3e</span><br><span class="line">   0x0040178c &lt;+123&gt;:   sub    eax,0x3e</span><br><span class="line">   0x0040178f &lt;+126&gt;:   cmp    DWORD PTR [ebp-0x14],0x5</span><br><span class="line">   0x00401793 &lt;+130&gt;:   jg     0x40179a &lt;phase_3+137&gt;</span><br><span class="line">   0x00401795 &lt;+132&gt;:   cmp    DWORD PTR [ebp-0x10],eax</span><br><span class="line">   0x00401798 &lt;+135&gt;:   je     0x40179f &lt;phase_3+142&gt;</span><br><span class="line">   0x0040179a &lt;+137&gt;:   call   0x401e64 &lt;explode_bomb&gt;</span><br><span class="line">   0x0040179f &lt;+142&gt;:   mov    eax,DWORD PTR [ebp-0xc]</span><br><span class="line">   0x004017a2 &lt;+145&gt;:   xor    eax,DWORD PTR gs:0x14</span><br><span class="line">   0x004017a9 &lt;+152&gt;:   jne    0x4017ed &lt;phase_3+220&gt;</span><br><span class="line">   0x004017ab &lt;+154&gt;:   mov    ebx,DWORD PTR [ebp-0x4]</span><br><span class="line">   0x004017ae &lt;+157&gt;:   leave</span><br><span class="line">   0x004017af &lt;+158&gt;:   ret</span><br><span class="line">   0x004017b0 &lt;+159&gt;:   mov    eax,0x0</span><br><span class="line">   0x004017b5 &lt;+164&gt;:   jmp    0x401776 &lt;phase_3+101&gt;</span><br><span class="line">   0x004017b7 &lt;+166&gt;:   mov    eax,0x0</span><br><span class="line">   0x004017bc &lt;+171&gt;:   jmp    0x40177b &lt;phase_3+106&gt;</span><br><span class="line">   0x004017be &lt;+173&gt;:   mov    eax,0x0</span><br><span class="line">   0x004017c3 &lt;+178&gt;:   jmp    0x401780 &lt;phase_3+111&gt;</span><br><span class="line">   0x004017c5 &lt;+180&gt;:   mov    eax,0x0</span><br><span class="line">   0x004017ca &lt;+185&gt;:   jmp    0x401783 &lt;phase_3+114&gt;</span><br><span class="line">   0x004017cc &lt;+187&gt;:   mov    eax,0x0</span><br><span class="line">   0x004017d1 &lt;+192&gt;:   jmp    0x401786 &lt;phase_3+117&gt;</span><br><span class="line">   0x004017d3 &lt;+194&gt;:   mov    eax,0x0</span><br><span class="line">   0x004017d8 &lt;+199&gt;:   jmp    0x401789 &lt;phase_3+120&gt;</span><br><span class="line">   0x004017da &lt;+201&gt;:   mov    eax,0x0</span><br><span class="line">   0x004017df &lt;+206&gt;:   jmp    0x40178c &lt;phase_3+123&gt;</span><br><span class="line">   0x004017e1 &lt;+208&gt;:   call   0x401e64 &lt;explode_bomb&gt;</span><br><span class="line">   0x004017e6 &lt;+213&gt;:   mov    eax,0x0</span><br><span class="line">   0x004017eb &lt;+218&gt;:   jmp    0x40178f &lt;phase_3+126&gt;</span><br><span class="line">   0x004017ed &lt;+220&gt;:   call   0x402e00 &lt;__stack_chk_fail_local&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><h2 id="42-思路"><a class="markdownIt-Anchor" href="#42-思路"></a> 4.2 思路</h2><p>从伪代码看，phase_3需要输入两个整数，第一个整数需要小于等于7，然后跳转到EDX，其他信息无法获取，需要gdb调试。</p><p>假设第一个数为0，进行动态调试：</p><ol><li><p>运行到<code>&lt;+79&gt;</code>，此时EDX=0x401771 (<code>&lt;phase_3+96&gt;: mov eax,0x398</code>)</p></li><li><p><code>&lt;+86&gt;</code>表示跳转到EDX对应的指令地址，也就是<code>&lt;+96&gt;</code></p></li><li><p><code>&lt;+126&gt;</code>和<code>&lt;+130&gt;</code>表示<strong>第一个数还需要小于等于5</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x0040178f &lt;+126&gt;:   cmp    DWORD PTR [ebp-0x14],0x5</span><br><span class="line">0x00401793 &lt;+130&gt;:   jg     0x40179a &lt;phase_3+137&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>&lt;+132&gt;</code>表示第二个数需要等于EAX，此时的EAX为0x42f：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ p <span class="variable">$eax</span></span><br><span class="line"><span class="variable">$24</span> = 0x42f</span><br><span class="line">gdb-peda$ d <span class="variable">$24</span></span><br><span class="line">No breakpoint number 1071.</span><br></pre></td></tr></table></figure></li><li><p>此时可以得到一组答案<code>0 1071</code>，答案不唯一。</p></li></ol><p><strong>答案</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1071</span><br></pre></td></tr></table></figure><h1 id="5-phase_4"><a class="markdownIt-Anchor" href="#5-phase_4"></a> 5 phase_4</h1><h2 id="51-解析"><a class="markdownIt-Anchor" href="#51-解析"></a> 5.1 解析</h2><p>IDA查看phase_4函数伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">func4</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// ebx</span></span><br><span class="line"></span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = a2;</span><br><span class="line">    <span class="keyword">if</span> ( a1 != <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = func4(a1 - <span class="number">1</span>, a2) + a2;</span><br><span class="line">      result = v3 + func4(a1 - <span class="number">2</span>, a2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> __cdecl <span class="title">phase_4</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [esp+4h] [ebp-14h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp+8h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( __isoc99_sscanf(a1, <span class="string">"%d %d"</span>, &amp;v4, &amp;v3) != <span class="number">2</span> || (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(v3 - <span class="number">2</span>) &gt; <span class="number">2</span> )</span><br><span class="line">    explode_bomb();</span><br><span class="line">  v1 = func4(<span class="number">5</span>, v3);</span><br><span class="line">  <span class="keyword">if</span> ( v4 != v1 )</span><br><span class="line">    explode_bomb();</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gdb查看phase_4函数汇编代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ disassemble phase_4</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> phase_4:</span><br><span class="line">   0x0040183f &lt;+0&gt;:     endbr32</span><br><span class="line">   0x00401843 &lt;+4&gt;:     push   ebp</span><br><span class="line">   0x00401844 &lt;+5&gt;:     mov    ebp,esp</span><br><span class="line">   0x00401846 &lt;+7&gt;:     push   ebx</span><br><span class="line">   0x00401847 &lt;+8&gt;:     sub    esp,0x14</span><br><span class="line">   0x0040184a &lt;+11&gt;:    call   0x4013d0 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line">   0x0040184f &lt;+16&gt;:    add    ebx,0x3715</span><br><span class="line">   0x00401855 &lt;+22&gt;:    mov    eax,gs:0x14</span><br><span class="line">   0x0040185b &lt;+28&gt;:    mov    DWORD PTR [ebp-0xc],eax</span><br><span class="line">   0x0040185e &lt;+31&gt;:    xor    eax,eax</span><br><span class="line">   0x00401860 &lt;+33&gt;:    lea    eax,[ebp-0x14]</span><br><span class="line">   0x00401863 &lt;+36&gt;:    push   eax</span><br><span class="line">   0x00401864 &lt;+37&gt;:    lea    eax,[ebp-0x10]</span><br><span class="line">   0x00401867 &lt;+40&gt;:    push   eax</span><br><span class="line">   0x00401868 &lt;+41&gt;:    lea    eax,[ebx-0x1bb7]</span><br><span class="line">   0x0040186e &lt;+47&gt;:    push   eax</span><br><span class="line">   0x0040186f &lt;+48&gt;:    push   DWORD PTR [ebp+0x8]</span><br><span class="line">   0x00401872 &lt;+51&gt;:    call   0x4012d0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">   0x00401877 &lt;+56&gt;:    add    esp,0x10</span><br><span class="line">   0x0040187a &lt;+59&gt;:    cmp    eax,0x2</span><br><span class="line">   0x0040187d &lt;+62&gt;:    jne    0x40188a &lt;phase_4+75&gt;</span><br><span class="line">   0x0040187f &lt;+64&gt;:    mov    eax,DWORD PTR [ebp-0x14]</span><br><span class="line">   0x00401882 &lt;+67&gt;:    sub    eax,0x2</span><br><span class="line">   0x00401885 &lt;+70&gt;:    cmp    eax,0x2</span><br><span class="line">   0x00401888 &lt;+73&gt;:    jbe    0x40188f &lt;phase_4+80&gt;</span><br><span class="line">   0x0040188a &lt;+75&gt;:    call   0x401e64 &lt;explode_bomb&gt;</span><br><span class="line">   0x0040188f &lt;+80&gt;:    sub    esp,0x8</span><br><span class="line">   0x00401892 &lt;+83&gt;:    push   DWORD PTR [ebp-0x14]</span><br><span class="line">   0x00401895 &lt;+86&gt;:    push   0x5</span><br><span class="line">   0x00401897 &lt;+88&gt;:    call   0x4017f2 &lt;func4&gt;</span><br><span class="line">   0x0040189c &lt;+93&gt;:    add    esp,0x10</span><br><span class="line">   0x0040189f &lt;+96&gt;:    cmp    DWORD PTR [ebp-0x10],eax</span><br><span class="line">   0x004018a2 &lt;+99&gt;:    jne    0x4018b5 &lt;phase_4+118&gt;</span><br><span class="line">   0x004018a4 &lt;+101&gt;:   mov    eax,DWORD PTR [ebp-0xc]</span><br><span class="line">   0x004018a7 &lt;+104&gt;:   xor    eax,DWORD PTR gs:0x14</span><br><span class="line">   0x004018ae &lt;+111&gt;:   jne    0x4018bc &lt;phase_4+125&gt;</span><br><span class="line">   0x004018b0 &lt;+113&gt;:   mov    ebx,DWORD PTR [ebp-0x4]</span><br><span class="line">   0x004018b3 &lt;+116&gt;:   leave</span><br><span class="line">   0x004018b4 &lt;+117&gt;:   ret</span><br><span class="line">   0x004018b5 &lt;+118&gt;:   call   0x401e64 &lt;explode_bomb&gt;</span><br><span class="line">   0x004018ba &lt;+123&gt;:   jmp    0x4018a4 &lt;phase_4+101&gt;</span><br><span class="line">   0x004018bc &lt;+125&gt;:   call   0x402e00 &lt;__stack_chk_fail_local&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><h2 id="52-思路"><a class="markdownIt-Anchor" href="#52-思路"></a> 5.2 思路</h2><p>从伪代码来看，phase_4需要输入两个整数，第二个可能是2、3、4，第一个需要满足一定的条件。</p><ol><li><p>假设第二个为2，进入gdb动态调试；</p></li><li><p>执行到<code>&lt;+96&gt;</code>，第一个值需要等于此时的EAX，查看EAX的值：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ p <span class="variable">$eax</span></span><br><span class="line"><span class="variable">$28</span> = 0x18</span><br><span class="line">gdb-peda$ d <span class="variable">$28</span></span><br><span class="line">No breakpoint number 24.</span><br></pre></td></tr></table></figure></li><li><p>所以其中一个答案是<code>24 2</code></p></li></ol><p><strong>答案</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24 2</span><br></pre></td></tr></table></figure><h1 id="6-phase_5"><a class="markdownIt-Anchor" href="#6-phase_5"></a> 6 phase_5</h1><h2 id="61-解析"><a class="markdownIt-Anchor" href="#61-解析"></a> 6.1 解析</h2><p>IDA查看phase_5函数伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_BYTE *__cdecl <span class="title">phase_5</span><span class="params">(_BYTE *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _BYTE *result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// ecx</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( string_length(a1) != <span class="number">6</span> )</span><br><span class="line">    explode_bomb();</span><br><span class="line">  result = a1;</span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    v2 += array_3066[*result++ &amp; <span class="number">0xF</span>];</span><br><span class="line">  <span class="keyword">while</span> ( result != a1 + <span class="number">6</span> );</span><br><span class="line">  <span class="keyword">if</span> ( v2 != <span class="number">44</span> )</span><br><span class="line">    explode_bomb();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gdb查看phase_5函数汇编代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ disassemble phase_5</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> phase_5:</span><br><span class="line">=&gt; 0x004018c1 &lt;+0&gt;:     endbr32</span><br><span class="line">   0x004018c5 &lt;+4&gt;:     push   ebp</span><br><span class="line">   0x004018c6 &lt;+5&gt;:     mov    ebp,esp</span><br><span class="line">   0x004018c8 &lt;+7&gt;:     push   edi</span><br><span class="line">   0x004018c9 &lt;+8&gt;:     push   esi</span><br><span class="line">   0x004018ca &lt;+9&gt;:     push   ebx</span><br><span class="line">   0x004018cb &lt;+10&gt;:    sub    esp,0x18</span><br><span class="line">   0x004018ce &lt;+13&gt;:    call   0x4013d0 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line">   0x004018d3 &lt;+18&gt;:    add    ebx,0x3691</span><br><span class="line">   0x004018d9 &lt;+24&gt;:    mov    esi,DWORD PTR [ebp+0x8]</span><br><span class="line">   0x004018dc &lt;+27&gt;:    push   esi</span><br><span class="line">   0x004018dd &lt;+28&gt;:    call   0x401bb9 &lt;string_length&gt;</span><br><span class="line">   0x004018e2 &lt;+33&gt;:    add    esp,0x10</span><br><span class="line">   0x004018e5 &lt;+36&gt;:    cmp    eax,0x6</span><br><span class="line">   0x004018e8 &lt;+39&gt;:    jne    0x401917 &lt;phase_5+86&gt;</span><br><span class="line">   0x004018ea &lt;+41&gt;:    mov    eax,esi</span><br><span class="line">   0x004018ec &lt;+43&gt;:    add    esi,0x6</span><br><span class="line">   0x004018ef &lt;+46&gt;:    mov    ecx,0x0</span><br><span class="line">   0x004018f4 &lt;+51&gt;:    lea    edi,[ebx-0x1da4]</span><br><span class="line">   0x004018fa &lt;+57&gt;:    movzx  edx,BYTE PTR [eax]</span><br><span class="line">   0x004018fd &lt;+60&gt;:    and    edx,0xf</span><br><span class="line">   0x00401900 &lt;+63&gt;:    add    ecx,DWORD PTR [edi+edx*4]</span><br><span class="line">   0x00401903 &lt;+66&gt;:    add    eax,0x1</span><br><span class="line">   0x00401906 &lt;+69&gt;:    cmp    eax,esi</span><br><span class="line">   0x00401908 &lt;+71&gt;:    jne    0x4018fa &lt;phase_5+57&gt;</span><br><span class="line">   0x0040190a &lt;+73&gt;:    cmp    ecx,0x2c</span><br><span class="line">   0x0040190d &lt;+76&gt;:    jne    0x40191e &lt;phase_5+93&gt;</span><br><span class="line">   0x0040190f &lt;+78&gt;:    lea    esp,[ebp-0xc]</span><br><span class="line">   0x00401912 &lt;+81&gt;:    pop    ebx</span><br><span class="line">   0x00401913 &lt;+82&gt;:    pop    esi</span><br><span class="line">   0x00401914 &lt;+83&gt;:    pop    edi</span><br><span class="line">   0x00401915 &lt;+84&gt;:    pop    ebp</span><br><span class="line">   0x00401916 &lt;+85&gt;:    ret</span><br><span class="line">   0x00401917 &lt;+86&gt;:    call   0x401e64 &lt;explode_bomb&gt;</span><br><span class="line">   0x0040191c &lt;+91&gt;:    jmp    0x4018ea &lt;phase_5+41&gt;</span><br><span class="line">   0x0040191e &lt;+93&gt;:    call   0x401e64 &lt;explode_bomb&gt;</span><br><span class="line">   0x00401923 &lt;+98&gt;:    jmp    0x40190f &lt;phase_5+78&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><h2 id="62-思路"><a class="markdownIt-Anchor" href="#62-思路"></a> 6.2 思路</h2><p>观察伪代码发现，输入是一段长度为6的字符串，而且需要满足一定的条件。</p><p>在IDA中双击<code>array_3066</code>查看该数组的值：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_3066      dd 2, 0Ah, 6, 1, 0Ch, 10h, 9, 3, 4, 7, 0Eh, 5, 0Bh, 8</span><br></pre></td></tr></table></figure><p>或者在gdb中查看，运行至<code>&lt;+51&gt;</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ x/20x <span class="variable">$ebx</span>-0x1da4</span><br><span class="line">0x4031c0 &lt;array.3066&gt;:  0x00000002      0x0000000a      0x00000006      0x00000001</span><br><span class="line">0x4031d0 &lt;array.3066+16&gt;:       0x0000000c      0x00000010      0x00000009      0x00000003</span><br><span class="line">0x4031e0 &lt;array.3066+32&gt;:       0x00000004      0x00000007      0x0000000e      0x00000005</span><br><span class="line">0x4031f0 &lt;array.3066+48&gt;:       0x0000000b      0x00000008      0x0000000f      0x0000000d</span><br><span class="line">0x403200:       0x79206f53      0x7420756f      0x6b6e6968      0x756f7920</span><br></pre></td></tr></table></figure><p>下标可以这样组合：1 1 1 1 0 0 （也就是10+10+10+10+2+2=44，满足条件）</p><p>对应到字符串是：<code>111100</code> 或 <code>AAAA@@</code>等。</p><p><strong>答案</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">111100</span><br></pre></td></tr></table></figure><h1 id="7-phase_6"><a class="markdownIt-Anchor" href="#7-phase_6"></a> 7 phase_6</h1><h2 id="71-解析"><a class="markdownIt-Anchor" href="#71-解析"></a> 7.1 解析</h2><p>IDA查看phase_6函数伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> __cdecl <span class="title">phase_6</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *v1; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// eax</span></span><br><span class="line">  _DWORD *v5; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// edi</span></span><br><span class="line">  <span class="keyword">char</span> *v14; <span class="comment">// [esp+Ch] [ebp-64h]</span></span><br><span class="line">  <span class="keyword">int</span> v15; <span class="comment">// [esp+10h] [ebp-60h]</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// [esp+24h] [ebp-4Ch] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v17; <span class="comment">// [esp+28h] [ebp-48h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v18; <span class="comment">// [esp+3Ch] [ebp-34h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v19; <span class="comment">// [esp+40h] [ebp-30h]</span></span><br><span class="line">  <span class="keyword">int</span> v20; <span class="comment">// [esp+44h] [ebp-2Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v21; <span class="comment">// [esp+48h] [ebp-28h]</span></span><br><span class="line">  <span class="keyword">int</span> v22; <span class="comment">// [esp+4Ch] [ebp-24h]</span></span><br><span class="line">  <span class="keyword">int</span> v23; <span class="comment">// [esp+50h] [ebp-20h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v24; <span class="comment">// [esp+54h] [ebp-1Ch]</span></span><br><span class="line"></span><br><span class="line">  v24 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  read_six_numbers(a1, (<span class="keyword">int</span>)&amp;v16);</span><br><span class="line">  v14 = &amp;v17;</span><br><span class="line">  v15 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(*((_DWORD *)v14 - <span class="number">1</span>) - <span class="number">1</span>) &gt; <span class="number">5</span> )</span><br><span class="line">      explode_bomb();</span><br><span class="line">    <span class="keyword">if</span> ( ++v15 &gt; <span class="number">5</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v1 = (<span class="keyword">int</span> *)v14;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *((_DWORD *)v14 - <span class="number">1</span>) == *v1 )</span><br><span class="line">        explode_bomb();</span><br><span class="line">      ++v1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( &amp;v18 != v1 );</span><br><span class="line">    v14 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i != <span class="number">6</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = *(&amp;v16 + i);</span><br><span class="line">    v4 = <span class="number">1</span>;</span><br><span class="line">    v5 = &amp;node1;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &gt; <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        v5 = (_DWORD *)v5[<span class="number">2</span>];</span><br><span class="line">        ++v4;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( v4 != v3 );</span><br><span class="line">    &#125;</span><br><span class="line">    *(&amp;v18 + i) = (<span class="keyword">int</span>)v5;</span><br><span class="line">  &#125;</span><br><span class="line">  v6 = v18;</span><br><span class="line">  v7 = v19;</span><br><span class="line">  *(_DWORD *)(v18 + <span class="number">8</span>) = v19;</span><br><span class="line">  v8 = v20;</span><br><span class="line">  *(_DWORD *)(v7 + <span class="number">8</span>) = v20;</span><br><span class="line">  v9 = v21;</span><br><span class="line">  *(_DWORD *)(v8 + <span class="number">8</span>) = v21;</span><br><span class="line">  v10 = v22;</span><br><span class="line">  *(_DWORD *)(v9 + <span class="number">8</span>) = v22;</span><br><span class="line">  v11 = v23;</span><br><span class="line">  *(_DWORD *)(v10 + <span class="number">8</span>) = v23;</span><br><span class="line">  *(_DWORD *)(v11 + <span class="number">8</span>) = <span class="number">0</span>;</span><br><span class="line">  v12 = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(_DWORD *)v6 &gt; **(_DWORD **)(v6 + <span class="number">8</span>) )</span><br><span class="line">      explode_bomb();</span><br><span class="line">    v6 = *(_DWORD *)(v6 + <span class="number">8</span>);</span><br><span class="line">    --v12;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v12 );</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v24;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gdb查看phase_6函数汇编代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ disassemble phase_6</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> phase_6:</span><br><span class="line">=&gt; 0x00401925 &lt;+0&gt;:     endbr32</span><br><span class="line">   0x00401929 &lt;+4&gt;:     push   ebp</span><br><span class="line">   0x0040192a &lt;+5&gt;:     mov    ebp,esp</span><br><span class="line">   0x0040192c &lt;+7&gt;:     push   edi</span><br><span class="line">   0x0040192d &lt;+8&gt;:     push   esi</span><br><span class="line">   0x0040192e &lt;+9&gt;:     push   ebx</span><br><span class="line">   0x0040192f &lt;+10&gt;:    sub    esp,0x64</span><br><span class="line">   0x00401932 &lt;+13&gt;:    call   0x4013d0 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line">   0x00401937 &lt;+18&gt;:    add    ebx,0x362d</span><br><span class="line">   0x0040193d &lt;+24&gt;:    mov    eax,gs:0x14</span><br><span class="line">   0x00401943 &lt;+30&gt;:    mov    DWORD PTR [ebp-0x1c],eax</span><br><span class="line">   0x00401946 &lt;+33&gt;:    xor    eax,eax</span><br><span class="line">   0x00401948 &lt;+35&gt;:    lea    eax,[ebp-0x4c]</span><br><span class="line">   0x0040194b &lt;+38&gt;:    push   eax</span><br><span class="line">   0x0040194c &lt;+39&gt;:    push   DWORD PTR [ebp+0x8]</span><br><span class="line">   0x0040194f &lt;+42&gt;:    call   0x401eba &lt;read_six_numbers&gt;</span><br><span class="line">   0x00401954 &lt;+47&gt;:    lea    eax,[ebp-0x48]</span><br><span class="line">   0x00401957 &lt;+50&gt;:    mov    DWORD PTR [ebp-0x64],eax</span><br><span class="line">   0x0040195a &lt;+53&gt;:    add    esp,0x10</span><br><span class="line">   0x0040195d &lt;+56&gt;:    mov    DWORD PTR [ebp-0x60],0x0</span><br><span class="line">   0x00401964 &lt;+63&gt;:    lea    eax,[ebp-0x34]</span><br><span class="line">   0x00401967 &lt;+66&gt;:    mov    DWORD PTR [ebp-0x5c],eax</span><br><span class="line">   0x0040196a &lt;+69&gt;:    jmp    0x40198d &lt;phase_6+104&gt;</span><br><span class="line">   0x0040196c &lt;+71&gt;:    call   0x401e64 &lt;explode_bomb&gt;</span><br><span class="line">   0x00401971 &lt;+76&gt;:    jmp    0x4019a0 &lt;phase_6+123&gt;</span><br><span class="line">   0x00401973 &lt;+78&gt;:    add    esi,0x4</span><br><span class="line">   0x00401976 &lt;+81&gt;:    cmp    DWORD PTR [ebp-0x5c],esi</span><br><span class="line">   0x00401979 &lt;+84&gt;:    je     0x401989 &lt;phase_6+100&gt;</span><br><span class="line">   0x0040197b &lt;+86&gt;:    mov    eax,DWORD PTR [esi]</span><br><span class="line">   0x0040197d &lt;+88&gt;:    cmp    DWORD PTR [edi-0x4],eax</span><br><span class="line">   0x00401980 &lt;+91&gt;:    jne    0x401973 &lt;phase_6+78&gt;</span><br><span class="line">   0x00401982 &lt;+93&gt;:    call   0x401e64 &lt;explode_bomb&gt;</span><br><span class="line">   0x00401987 &lt;+98&gt;:    jmp    0x401973 &lt;phase_6+78&gt;</span><br><span class="line">   0x00401989 &lt;+100&gt;:   add    DWORD PTR [ebp-0x64],0x4</span><br><span class="line">   0x0040198d &lt;+104&gt;:   mov    eax,DWORD PTR [ebp-0x64]</span><br><span class="line">   0x00401990 &lt;+107&gt;:   mov    edi,eax</span><br><span class="line">   0x00401992 &lt;+109&gt;:   mov    eax,DWORD PTR [eax-0x4]</span><br><span class="line">   0x00401995 &lt;+112&gt;:   mov    DWORD PTR [ebp-0x68],eax</span><br><span class="line">   0x00401998 &lt;+115&gt;:   sub    eax,0x1</span><br><span class="line">   0x0040199b &lt;+118&gt;:   cmp    eax,0x5</span><br><span class="line">   0x0040199e &lt;+121&gt;:   ja     0x40196c &lt;phase_6+71&gt;</span><br><span class="line">   0x004019a0 &lt;+123&gt;:   add    DWORD PTR [ebp-0x60],0x1</span><br><span class="line">   0x004019a4 &lt;+127&gt;:   mov    eax,DWORD PTR [ebp-0x60]</span><br><span class="line">   0x004019a7 &lt;+130&gt;:   cmp    eax,0x5</span><br><span class="line">   0x004019aa &lt;+133&gt;:   jg     0x4019b1 &lt;phase_6+140&gt;</span><br><span class="line">   0x004019ac &lt;+135&gt;:   mov    esi,DWORD PTR [ebp-0x64]</span><br><span class="line">   0x004019af &lt;+138&gt;:   jmp    0x40197b &lt;phase_6+86&gt;</span><br><span class="line">   0x004019b1 &lt;+140&gt;:   mov    esi,0x0</span><br><span class="line">   0x004019b6 &lt;+145&gt;:   mov    edi,esi</span><br><span class="line">   0x004019b8 &lt;+147&gt;:   mov    ecx,DWORD PTR [ebp+esi*4-0x4c]</span><br><span class="line">   0x004019bc &lt;+151&gt;:   mov    eax,0x1</span><br><span class="line">   0x004019c1 &lt;+156&gt;:   lea    edx,[ebx+0x594]</span><br><span class="line">   0x004019c7 &lt;+162&gt;:   cmp    ecx,0x1</span><br><span class="line">   0x004019ca &lt;+165&gt;:   jle    0x4019d6 &lt;phase_6+177&gt;</span><br><span class="line">   0x004019cc &lt;+167&gt;:   mov    edx,DWORD PTR [edx+0x8]</span><br><span class="line">   0x004019cf &lt;+170&gt;:   add    eax,0x1</span><br><span class="line">   0x004019d2 &lt;+173&gt;:   cmp    eax,ecx</span><br><span class="line">   0x004019d4 &lt;+175&gt;:   jne    0x4019cc &lt;phase_6+167&gt;</span><br><span class="line">   0x004019d6 &lt;+177&gt;:   mov    DWORD PTR [ebp+edi*4-0x34],edx</span><br><span class="line">   0x004019da &lt;+181&gt;:   add    esi,0x1</span><br><span class="line">   0x004019dd &lt;+184&gt;:   cmp    esi,0x6</span><br><span class="line">   0x004019e0 &lt;+187&gt;:   jne    0x4019b6 &lt;phase_6+145&gt;</span><br><span class="line">   0x004019e2 &lt;+189&gt;:   mov    esi,DWORD PTR [ebp-0x34]</span><br><span class="line">   0x004019e5 &lt;+192&gt;:   mov    eax,DWORD PTR [ebp-0x30]</span><br><span class="line">   0x004019e8 &lt;+195&gt;:   mov    DWORD PTR [esi+0x8],eax</span><br><span class="line">   0x004019eb &lt;+198&gt;:   mov    edx,DWORD PTR [ebp-0x2c]</span><br><span class="line">   0x004019ee &lt;+201&gt;:   mov    DWORD PTR [eax+0x8],edx</span><br><span class="line">   0x004019f1 &lt;+204&gt;:   mov    eax,DWORD PTR [ebp-0x28]</span><br><span class="line">   0x004019f4 &lt;+207&gt;:   mov    DWORD PTR [edx+0x8],eax</span><br><span class="line">   0x004019f7 &lt;+210&gt;:   mov    edx,DWORD PTR [ebp-0x24]</span><br><span class="line">   0x004019fa &lt;+213&gt;:   mov    DWORD PTR [eax+0x8],edx</span><br><span class="line">   0x004019fd &lt;+216&gt;:   mov    eax,DWORD PTR [ebp-0x20]</span><br><span class="line">   0x00401a00 &lt;+219&gt;:   mov    DWORD PTR [edx+0x8],eax</span><br><span class="line">   0x00401a03 &lt;+222&gt;:   mov    DWORD PTR [eax+0x8],0x0</span><br><span class="line">   0x00401a0a &lt;+229&gt;:   mov    edi,0x5</span><br><span class="line">   0x00401a0f &lt;+234&gt;:   jmp    0x401a19 &lt;phase_6+244&gt;</span><br><span class="line">   0x00401a11 &lt;+236&gt;:   mov    esi,DWORD PTR [esi+0x8]</span><br><span class="line">   0x00401a14 &lt;+239&gt;:   sub    edi,0x1</span><br><span class="line">   0x00401a17 &lt;+242&gt;:   je     0x401a29 &lt;phase_6+260&gt;</span><br><span class="line">   0x00401a19 &lt;+244&gt;:   mov    eax,DWORD PTR [esi+0x8]</span><br><span class="line">   0x00401a1c &lt;+247&gt;:   mov    eax,DWORD PTR [eax]</span><br><span class="line">   0x00401a1e &lt;+249&gt;:   cmp    DWORD PTR [esi],eax</span><br><span class="line">   0x00401a20 &lt;+251&gt;:   jle    0x401a11 &lt;phase_6+236&gt;</span><br><span class="line">   0x00401a22 &lt;+253&gt;:   call   0x401e64 &lt;explode_bomb&gt;</span><br><span class="line">   0x00401a27 &lt;+258&gt;:   jmp    0x401a11 &lt;phase_6+236&gt;</span><br><span class="line">   0x00401a29 &lt;+260&gt;:   mov    eax,DWORD PTR [ebp-0x1c]</span><br><span class="line">   0x00401a2c &lt;+263&gt;:   xor    eax,DWORD PTR gs:0x14</span><br><span class="line">   0x00401a33 &lt;+270&gt;:   jne    0x401a3d &lt;phase_6+280&gt;</span><br><span class="line">   0x00401a35 &lt;+272&gt;:   lea    esp,[ebp-0xc]</span><br><span class="line">   0x00401a38 &lt;+275&gt;:   pop    ebx</span><br><span class="line">   0x00401a39 &lt;+276&gt;:   pop    esi</span><br><span class="line">   0x00401a3a &lt;+277&gt;:   pop    edi</span><br><span class="line">   0x00401a3b &lt;+278&gt;:   pop    ebp</span><br><span class="line">   0x00401a3c &lt;+279&gt;:   ret</span><br><span class="line">   0x00401a3d &lt;+280&gt;:   call   0x402e00 &lt;__stack_chk_fail_local&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><h2 id="72-思路"><a class="markdownIt-Anchor" href="#72-思路"></a> 7.2 思路</h2><ol><li><p>查看伪代码需要输入六个数字；</p></li><li><p>观察这部分代码块（对应汇编代码<code>&lt;+47&gt;</code>到<code>&lt;+98&gt;</code>）可得，这六个数字必须从<code>1 2 3 4 5 6</code>中选，而且互不相同；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(*((_DWORD *)v14 - <span class="number">1</span>) - <span class="number">1</span>) &gt; <span class="number">5</span> )</span><br><span class="line">        explode_bomb();</span><br><span class="line">    <span class="keyword">if</span> ( ++v15 &gt; <span class="number">5</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    v1 = (<span class="keyword">int</span> *)v14;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *((_DWORD *)v14 - <span class="number">1</span>) == *v1 )</span><br><span class="line">            explode_bomb();</span><br><span class="line">        ++v1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( &amp;v18 != v1 );</span><br><span class="line">    v14 += <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看这部分代码块可得，是根据输入的六个数字对node链表进行排序，node链表最后要升序排列（可以有相等的）；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i != <span class="number">6</span>; ++i )</span><br><span class="line">&#123;</span><br><span class="line">    v3 = *(&amp;v16 + i);</span><br><span class="line">    v4 = <span class="number">1</span>;</span><br><span class="line">    v5 = &amp;node1;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &gt; <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            v5 = (_DWORD *)v5[<span class="number">2</span>];</span><br><span class="line">            ++v4;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ( v4 != v3 );</span><br><span class="line">    &#125;</span><br><span class="line">    *(&amp;v18 + i) = (<span class="keyword">int</span>)v5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(_DWORD *)v6 &gt; **(_DWORD **)(v6 + <span class="number">8</span>) )</span><br><span class="line">        explode_bomb();</span><br><span class="line">    v6 = *(_DWORD *)(v6 + <span class="number">8</span>);</span><br><span class="line">    --v12;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ( v12 );</span><br></pre></td></tr></table></figure></li><li><p>运行至<code>&lt;+156&gt; lea edx,[ebx+0x594]</code>，查看各个node结点的数值：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[----------------------------------registers-----------------------------------]</span><br><span class="line">EAX: 0x1</span><br><span class="line">EBX: 0x404f64 --&gt; 0x4e6c (<span class="string">'lN'</span>)</span><br><span class="line">ECX: 0x4</span><br><span class="line">EDX: 0x4054f8 --&gt; 0x2a0</span><br><span class="line">ESI: 0x1</span><br><span class="line">EDI: 0x1</span><br><span class="line">EBP: 0xbffff498 --&gt; 0xbffff4c8 --&gt; 0x0</span><br><span class="line">ESP: 0xbffff430 --&gt; 0x3</span><br><span class="line">EIP: 0x4019c7 (&lt;phase_6+162&gt;:   cmp    ecx,0x1)</span><br><span class="line">EFLAGS: 0x293 (CARRY parity ADJUST zero SIGN <span class="built_in">trap</span> INTERRUPT direction overflow)</span><br><span class="line">[-------------------------------------code-------------------------------------]</span><br><span class="line">   0x4019b8 &lt;phase_6+147&gt;:      mov    ecx,DWORD PTR [ebp+esi*4-0x4c]</span><br><span class="line">   0x4019bc &lt;phase_6+151&gt;:      mov    eax,0x1</span><br><span class="line">   0x4019c1 &lt;phase_6+156&gt;:      lea    edx,[ebx+0x594]</span><br><span class="line">=&gt; 0x4019c7 &lt;phase_6+162&gt;:      cmp    ecx,0x1</span><br><span class="line">   0x4019ca &lt;phase_6+165&gt;:      jle    0x4019d6 &lt;phase_6+177&gt;</span><br><span class="line">   0x4019cc &lt;phase_6+167&gt;:      mov    edx,DWORD PTR [edx+0x8]</span><br><span class="line">   0x4019cf &lt;phase_6+170&gt;:      add    eax,0x1</span><br><span class="line">   0x4019d2 &lt;phase_6+173&gt;:      cmp    eax,ecx</span><br><span class="line">[------------------------------------stack-------------------------------------]</span><br><span class="line">0000| 0xbffff430 --&gt; 0x3</span><br><span class="line">0004| 0xbffff434 --&gt; 0xbffff464 --&gt; 0x405528 --&gt; 0x133</span><br><span class="line">0008| 0xbffff438 --&gt; 0x6</span><br><span class="line">0012| 0xbffff43c --&gt; 0xbffff464 --&gt; 0x405528 --&gt; 0x133</span><br><span class="line">0016| 0xbffff440 --&gt; 0x4058f0 (<span class="string">"5 4 2 1 6 3"</span>)</span><br><span class="line">0020| 0xbffff444 --&gt; 0x50 (<span class="string">'P'</span>)</span><br><span class="line">0024| 0xbffff448 --&gt; 0xb7fbc5c0 --&gt; 0xfbad2288</span><br><span class="line">0028| 0xbffff44c --&gt; 0x5</span><br><span class="line">[------------------------------------------------------------------------------]</span><br><span class="line">Legend: code, data, rodata, value</span><br><span class="line">0x004019c7 <span class="keyword">in</span> phase_6 ()</span><br><span class="line">gdb-peda$ x/21x <span class="variable">$ebx</span>+0x594</span><br><span class="line">0x4054f8 &lt;node1&gt;:       0x000002a0      0x00000001      0x00405504      0x0000026d</span><br><span class="line">0x405508 &lt;node2+4&gt;:     0x00000002      0x00405510      0x000001ea      0x00000003</span><br><span class="line">0x405518 &lt;node3+8&gt;:     0x0040551c      0x00000038      0x00000004      0x00405528</span><br><span class="line">0x405528 &lt;node5&gt;:       0x00000133      0x00000005      0x00405080      0x00000000</span><br><span class="line">0x405538:       0x00000000      0x00000000      0x00403417      0x00000000</span><br><span class="line">0x405548 &lt;host_table+8&gt;:        0x00000000</span><br><span class="line">gdb-peda$ x 0x00405080</span><br><span class="line">0x405080 &lt;node6&gt;:       0x000000ca</span><br><span class="line">gdb-peda$ x/3x 0x00405080</span><br><span class="line">0x405080 &lt;node6&gt;:       0x000000ca      0x00000006      0x00000000</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：在IDA中查看注意截断</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.data:000054F8                 public node1</span><br><span class="line">.data:000054F8 node1           db 0A0h                 ; DATA XREF: phase_6+9C↑o</span><br><span class="line">.data:000054F9                 db    2</span><br><span class="line">.data:000054FA                 db    0</span><br><span class="line">.data:000054FB                 db    0</span><br><span class="line">.data:000054FC                 db    1</span><br><span class="line">.data:000054FD                 db    0</span><br><span class="line">.data:000054FE                 db    0</span><br><span class="line">.data:000054FF                 db    0</span><br><span class="line">.data:00005500                 dd offset node2</span><br><span class="line">.data:00005504                 public node2</span><br><span class="line">.data:00005504 node2           db  6Dh ; m             ; DATA XREF: .data:00005500↑o</span><br><span class="line">.data:00005505                 db    2</span><br><span class="line">.data:00005506                 db    0</span><br><span class="line">.data:00005507                 db    0</span><br><span class="line">.data:00005508                 db    2</span><br><span class="line">.data:00005509                 db    0</span><br><span class="line">.data:0000550A                 db    0</span><br><span class="line">.data:0000550B                 db    0</span><br><span class="line">.data:0000550C                 dd offset node3</span><br></pre></td></tr></table></figure><p>可以得出：</p><ul><li><p>node结点的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>node排列：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|node1=0x2a0| -&gt; |node2=0x260| -&gt; |node3=0x1ea| -&gt; |node4=0x038| -&gt; |node5=0x133| -&gt; |node6=0x0ca|</span><br></pre></td></tr></table></figure></li></ul><p>所以应输入从小到大排列序号为：4 6 5 3 2 1</p></li></ol><p><strong>答案</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 6 5 3 2 1</span><br></pre></td></tr></table></figure><h1 id="8-bomblab隐藏关卡"><a class="markdownIt-Anchor" href="#8-bomblab隐藏关卡"></a> 8 bomblab隐藏关卡</h1><h2 id="81-解析"><a class="markdownIt-Anchor" href="#81-解析"></a> 8.1 解析</h2><p>在bomb的伪代码内找到调用 secret_phase 的函数-- phase_defused ，研究phase_defused 汇编代码：首先调用 sscanf ，要求输入 %d %d %s ，而且调用strings_not_equal 函数，只有第三个输入是 <code>DrEvil</code> 时触发 secret_phase() 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">phase_defused</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v1[<span class="number">4</span>]; <span class="comment">// [esp+10h] [ebp-64h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v2[<span class="number">4</span>]; <span class="comment">// [esp+14h] [ebp-60h] BYREF</span></span><br><span class="line">  <span class="keyword">char</span> v3[<span class="number">80</span>]; <span class="comment">// [esp+18h] [ebp-5Ch] BYREF</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v4; <span class="comment">// [esp+68h] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  send_msg(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( num_input_strings == <span class="number">6</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( __isoc99_sscanf(&amp;input_strings[<span class="number">240</span>], <span class="string">"%d %d %s"</span>, v1, v2) == <span class="number">3</span> &amp;&amp; !strings_not_equal(v3, <span class="string">"DrEvil"</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Curses, you've found the secret phase!"</span>);</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"But finding it and solving it are quite different..."</span>);</span><br><span class="line">      secret_phase();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Congratulations! You've defused the bomb!"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Your instructor has been notified and will verify your solution."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将已经解决的问题答案放到txt文件中，便于操作；找到一个输入是两个整数的阶段，这里选择了phase_4，成功触发隐藏关卡；（第三阶段无法触发，不知为何？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">And they have no disregard for human life.</span><br><span class="line">1 2 4 8 16 32</span><br><span class="line">0 1071 </span><br><span class="line">24 2 DrEvil</span><br><span class="line">111100</span><br><span class="line">4 6 5 3 2 1</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ./bomb flag.txt</span><br><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line"><span class="built_in">which</span> to blow yourself up. Have a nice day!</span><br><span class="line">Phase 1 defused. How about the next one?</span><br><span class="line">That<span class="string">'s number 2.  Keep going!</span></span><br><span class="line"><span class="string">Halfway there!</span></span><br><span class="line"><span class="string">So you got that one.  Try this one.</span></span><br><span class="line"><span class="string">Good work!  On to the next...</span></span><br><span class="line"><span class="string">Curses, you'</span>ve found the secret phase!</span><br><span class="line">But finding it and solving it are quite different...</span><br></pre></td></tr></table></figure><p>secret_phase伪代码 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">secret_phase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// esi</span></span><br><span class="line"></span><br><span class="line">  v0 = read_line();</span><br><span class="line">  v1 = strtol(v0, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(v1 - <span class="number">1</span>) &gt; <span class="number">0x3E8</span> )</span><br><span class="line">    explode_bomb();</span><br><span class="line">  <span class="keyword">if</span> ( fun7(n1, v1) != <span class="number">3</span> )</span><br><span class="line">    explode_bomb();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Wow! You've defused the secret stage!"</span>);</span><br><span class="line">  <span class="keyword">return</span> phase_defused();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fun7伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">fun7</span><span class="params">(_DWORD *a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !a1 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *a1 &gt; a2 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * fun7(a1[<span class="number">1</span>], a2);</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *a1 != a2 )</span><br><span class="line">    result = <span class="number">2</span> * fun7(a1[<span class="number">2</span>], a2) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="82-思路"><a class="markdownIt-Anchor" href="#82-思路"></a> 8.2 思路</h2><ol><li><p>进入 secret_phase：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ disassemble secret_phase</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> secret_phase:</span><br><span class="line">   0x00401a98 &lt;+0&gt;:     endbr32</span><br><span class="line">   0x00401a9c &lt;+4&gt;:     push   ebp</span><br><span class="line">   0x00401a9d &lt;+5&gt;:     mov    ebp,esp</span><br><span class="line">   0x00401a9f &lt;+7&gt;:     push   esi</span><br><span class="line">   0x00401aa0 &lt;+8&gt;:     push   ebx</span><br><span class="line">   0x00401aa1 &lt;+9&gt;:     call   0x4013d0 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line">   0x00401aa6 &lt;+14&gt;:    add    ebx,0x34be</span><br><span class="line">   0x00401aac &lt;+20&gt;:    call   0x401f09 &lt;read_line&gt;</span><br><span class="line">   0x00401ab1 &lt;+25&gt;:    sub    esp,0x4</span><br><span class="line">   0x00401ab4 &lt;+28&gt;:    push   0xa</span><br><span class="line">   0x00401ab6 &lt;+30&gt;:    push   0x0</span><br><span class="line">   0x00401ab8 &lt;+32&gt;:    push   eax</span><br><span class="line">   0x00401ab9 &lt;+33&gt;:    call   0x401340 &lt;strtol@plt&gt;</span><br><span class="line">   0x00401abe &lt;+38&gt;:    mov    esi,eax</span><br><span class="line">   0x00401ac0 &lt;+40&gt;:    lea    eax,[eax-0x1]</span><br><span class="line">   0x00401ac3 &lt;+43&gt;:    add    esp,0x10</span><br><span class="line">   0x00401ac6 &lt;+46&gt;:    cmp    eax,0x3e8</span><br><span class="line">   0x00401acb &lt;+51&gt;:    ja     0x401b03 &lt;secret_phase+107&gt;</span><br><span class="line">   0x00401acd &lt;+53&gt;:    sub    esp,0x8</span><br><span class="line">   0x00401ad0 &lt;+56&gt;:    push   esi</span><br><span class="line">   0x00401ad1 &lt;+57&gt;:    lea    eax,[ebx+0x540]</span><br><span class="line">   0x00401ad7 &lt;+63&gt;:    push   eax</span><br><span class="line">   0x00401ad8 &lt;+64&gt;:    call   0x401a42 &lt;fun7&gt;</span><br><span class="line">   0x00401add &lt;+69&gt;:    add    esp,0x10</span><br><span class="line">   0x00401ae0 &lt;+72&gt;:    cmp    eax,0x3</span><br><span class="line">   0x00401ae3 &lt;+75&gt;:    jne    0x401b0a &lt;secret_phase+114&gt;</span><br><span class="line">   0x00401ae5 &lt;+77&gt;:    sub    esp,0xc</span><br><span class="line">   0x00401ae8 &lt;+80&gt;:    lea    eax,[ebx-0x1df4]</span><br><span class="line">   0x00401aee &lt;+86&gt;:    push   eax</span><br><span class="line">   0x00401aef &lt;+87&gt;:    call   0x401280 &lt;puts@plt&gt;</span><br><span class="line">   0x00401af4 &lt;+92&gt;:    call   0x40203c &lt;phase_defused&gt;</span><br><span class="line">   0x00401af9 &lt;+97&gt;:    add    esp,0x10</span><br><span class="line">   0x00401afc &lt;+100&gt;:   lea    esp,[ebp-0x8]</span><br><span class="line">   0x00401aff &lt;+103&gt;:   pop    ebx</span><br><span class="line">   0x00401b00 &lt;+104&gt;:   pop    esi</span><br><span class="line">   0x00401b01 &lt;+105&gt;:   pop    ebp</span><br><span class="line">   0x00401b02 &lt;+106&gt;:   ret</span><br><span class="line">   0x00401b03 &lt;+107&gt;:   call   0x401e64 &lt;explode_bomb&gt;</span><br><span class="line">   0x00401b08 &lt;+112&gt;:   jmp    0x401acd &lt;secret_phase+53&gt;</span><br><span class="line">   0x00401b0a &lt;+114&gt;:   call   0x401e64 &lt;explode_bomb&gt;</span><br><span class="line">   0x00401b0f &lt;+119&gt;:   jmp    0x401ae5 &lt;secret_phase+77&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>可以看到<code>&lt;+20&gt;</code>调用了read_line函数，接着把read_line的返回值赋给了eax，并调用了strtol函数，这个标准库函数的作用是把一个字符串转换成对应的长整型数值。返回值还是存放在eax中，<code>&lt;+38&gt;</code>将eax赋值给了esi，<code>&lt;+40&gt;</code>将eax减1赋给eax，<code>&lt;+46&gt;</code>与1000(0x3e8)进行比较，如果这个值小于等于0x3e8就跳过引爆代码。看到这里可以知道我们需要再加入一行数据，它应该是一个小于等于1001的数值。</p></li><li><p><code>&lt;+53&gt;</code>将 esi 赋给了 M[esp + 4] ，也就是一开始输入的 eax 值。<code>&lt;+57&gt;</code>将ebx+0x540赋给了 M[esp] ，<code>&lt;+64&gt;</code>调用了 fun7 函数。函数返回后令返回值 eax 与 0x3 做了一个比较，如果相等则跳过引爆代码。所以fun7函数需要返回3；</p></li><li><p>查看 fun7 函数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ disassemble fun7</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> fun7:</span><br><span class="line">   0x00401a42 &lt;+0&gt;:     endbr32</span><br><span class="line">   0x00401a46 &lt;+4&gt;:     push   ebp</span><br><span class="line">   0x00401a47 &lt;+5&gt;:     mov    ebp,esp</span><br><span class="line">   0x00401a49 &lt;+7&gt;:     push   ebx</span><br><span class="line">   0x00401a4a &lt;+8&gt;:     sub    esp,0x4</span><br><span class="line">   0x00401a4d &lt;+11&gt;:    mov    edx,DWORD PTR [ebp+0x8]</span><br><span class="line">   0x00401a50 &lt;+14&gt;:    mov    ecx,DWORD PTR [ebp+0xc]</span><br><span class="line">   0x00401a53 &lt;+17&gt;:    <span class="built_in">test</span>   edx,edx</span><br><span class="line">   0x00401a55 &lt;+19&gt;:    je     0x401a91 &lt;fun7+79&gt;</span><br><span class="line">   0x00401a57 &lt;+21&gt;:    mov    ebx,DWORD PTR [edx]</span><br><span class="line">   0x00401a59 &lt;+23&gt;:    cmp    ebx,ecx</span><br><span class="line">   0x00401a5b &lt;+25&gt;:    jg     0x401a69 &lt;fun7+39&gt;</span><br><span class="line">   0x00401a5d &lt;+27&gt;:    mov    eax,0x0</span><br><span class="line">   0x00401a62 &lt;+32&gt;:    jne    0x401a7c &lt;fun7+58&gt;</span><br><span class="line">   0x00401a64 &lt;+34&gt;:    mov    ebx,DWORD PTR [ebp-0x4]</span><br><span class="line">   0x00401a67 &lt;+37&gt;:    leave</span><br><span class="line">   0x00401a68 &lt;+38&gt;:    ret</span><br><span class="line">   0x00401a69 &lt;+39&gt;:    sub    esp,0x8</span><br><span class="line">   0x00401a6c &lt;+42&gt;:    push   ecx</span><br><span class="line">   0x00401a6d &lt;+43&gt;:    push   DWORD PTR [edx+0x4]</span><br><span class="line">   0x00401a70 &lt;+46&gt;:    call   0x401a42 &lt;fun7&gt;</span><br><span class="line">   0x00401a75 &lt;+51&gt;:    add    esp,0x10</span><br><span class="line">   0x00401a78 &lt;+54&gt;:    add    eax,eax</span><br><span class="line">   0x00401a7a &lt;+56&gt;:    jmp    0x401a64 &lt;fun7+34&gt;</span><br><span class="line">   0x00401a7c &lt;+58&gt;:    sub    esp,0x8</span><br><span class="line">   0x00401a7f &lt;+61&gt;:    push   ecx</span><br><span class="line">   0x00401a80 &lt;+62&gt;:    push   DWORD PTR [edx+0x8]</span><br><span class="line">   0x00401a83 &lt;+65&gt;:    call   0x401a42 &lt;fun7&gt;</span><br><span class="line">   0x00401a88 &lt;+70&gt;:    add    esp,0x10</span><br><span class="line">   0x00401a8b &lt;+73&gt;:    lea    eax,[eax+eax*1+0x1]</span><br><span class="line">   0x00401a8f &lt;+77&gt;:    jmp    0x401a64 &lt;fun7+34&gt;</span><br><span class="line">   0x00401a91 &lt;+79&gt;:    mov    eax,0xffffffff</span><br><span class="line">   0x00401a96 &lt;+84&gt;:    jmp    0x401a64 &lt;fun7+34&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><p>查看一下 M[esp] 这个地址里存放的什么数据结构：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gdb-peda$ b *0x00401ad8  <span class="comment">#打断点至&lt;+64&gt;</span></span><br><span class="line">gdb-peda$ x/24xw <span class="variable">$eax</span></span><br><span class="line">0x4054a4 &lt;n1&gt;:  0x00000024      0x004054b0      0x004054bc      0x00000008</span><br><span class="line">0x4054b4 &lt;n21+4&gt;:       0x004054e0      0x004054c8      0x00000032      0x004054d4</span><br><span class="line">0x4054c4 &lt;n22+8&gt;:       0x004054ec      0x00000016      0x0040505c      0x00405044</span><br><span class="line">0x4054d4 &lt;n33&gt;: 0x0000002d      0x00405020      0x00405068      0x00000006</span><br><span class="line">0x4054e4 &lt;n31+4&gt;:       0x0040502c      0x00405050      0x0000006b      0x00405038</span><br><span class="line">0x4054f4 &lt;n34+8&gt;:       0x00405074      0x000002a0      0x00000001      0x00000000</span><br></pre></td></tr></table></figure><p>仔细观察可以发现这是一个二叉树的结构，每个节点第1个4字节存放数据，第2个4字节存放左子树地址，第3个4字节存放右子树位置。并且命名也有规律，<code>nab</code>，<code>a</code> 代表层数，<code>b</code> 代表从左至右第b个节点。整理可得：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0x4054a4 &lt;n1&gt;:  0x00000024      0x004054b0      0x004054bc</span><br><span class="line">0x4054b0 &lt;n21&gt;: 0x00000008      0x004054e0      0x004054c8</span><br><span class="line">0x4054bc &lt;n22&gt;: 0x00000032      0x004054d4      0x004054ec</span><br><span class="line">0x4054e0 &lt;n31&gt;: 0x00000006      0x0040502c      0x00405050</span><br><span class="line">0x4054c8 &lt;n32&gt;: 0x00000016      0x0040505c      0x00405044</span><br><span class="line">0x4054d4 &lt;n33&gt;: 0x0000002d      0x00405020      0x00405068</span><br><span class="line">0x4054ec &lt;n34&gt;: 0x0000006b      0x00405038      0x00405074</span><br><span class="line">0x40502c &lt;n41&gt;: 0x00000001      0x00000000      0x00000000</span><br><span class="line">0x405050 &lt;n42&gt;: 0x00000007      0x00000000      0x00000000</span><br><span class="line">0x40505c &lt;n43&gt;: 0x00000014      0x00000000      0x00000000</span><br><span class="line">0x405044 &lt;n44&gt;: 0x00000023      0x00000000      0x00000000</span><br><span class="line">0x405020 &lt;n45&gt;: 0x00000028      0x00000000      0x00000000</span><br><span class="line">0x405068 &lt;n46&gt;: 0x0000002f      0x00000000      0x00000000</span><br><span class="line">0x405038 &lt;n47&gt;: 0x00000063      0x00000000      0x00000000</span><br><span class="line">0x405074 &lt;n48&gt;: 0x000003e9      0x00000000      0x00000000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">  0x24 --&gt; 0x08</span><br><span class="line">  0x24 --&gt; 0x32</span><br><span class="line">  0x08 --&gt; 0x06</span><br><span class="line">  0x08 --&gt; 0x16</span><br><span class="line">  0x32 --&gt; 0x2d</span><br><span class="line">  0x32 --&gt; 0x6b</span><br><span class="line">  0x06 --&gt; 0x01</span><br><span class="line">  0x06 --&gt; 0x07</span><br><span class="line">  0x2d --&gt; 0x28</span><br><span class="line">  0x2d --&gt; 0x2f</span><br><span class="line">  0x6b --&gt; 0x63</span><br><span class="line">  0x6b --&gt; 0x3e9</span><br><span class="line">  0x16 --&gt; 0x14</span><br><span class="line">  0x16 --&gt; 0x23</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/05/26/3jUNCrcuDWAf5Ms.png" width="600" height="300" alt="图片名称" align="center" id="201"></li><li><p>总结上面的过程： M[esp] 指向树的一个节点，令节点的值与读入的值进行比较。</p><ul><li>如果前者大于后者： M[esp] 移至左子树，返回 2 * eax ；</li><li>如果前者不等于后者： M[esp] 移至右子树，返回 2 * eax + 1 ；</li><li>如果前者等于后者：返回0</li></ul></li><li><p>那么我们需要返回3，根据递归可得当输入是 0x63（99）时返回3。</p></li></ol><p><strong>答案</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">99</span><br></pre></td></tr></table></figure><h1 id="9-最终答案"><a class="markdownIt-Anchor" href="#9-最终答案"></a> 9 最终答案</h1><p><code>flag.txt</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">And they have no disregard <span class="keyword">for</span> human life.</span><br><span class="line">1 2 4 8 16 32</span><br><span class="line">0 1071 </span><br><span class="line">24 2 DrEvil</span><br><span class="line">111100</span><br><span class="line">4 6 5 3 2 1</span><br><span class="line">99</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ./bomb flag.txt</span><br><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line"><span class="built_in">which</span> to blow yourself up. Have a nice day!</span><br><span class="line">Phase 1 defused. How about the next one?</span><br><span class="line">That<span class="string">'s number 2.  Keep going!</span></span><br><span class="line"><span class="string">Halfway there!</span></span><br><span class="line"><span class="string">So you got that one.  Try this one.</span></span><br><span class="line"><span class="string">Good work!  On to the next...</span></span><br><span class="line"><span class="string">Curses, you'</span>ve found the secret phase!</span><br><span class="line">But finding it and solving it are quite different...</span><br><span class="line">Wow! You<span class="string">'ve defused the secret stage!</span></span><br><span class="line"><span class="string">Congratulations! You'</span>ve defused the bomb!</span><br><span class="line">Your instructor has been notified and will verify your solution.</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计组" scheme="https://Dragonliu2022.github.io/categories/计组/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux查看系统信息</title>
    <link href="https://dragonliu2022.github.io/2022/05/11/Linux%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/"/>
    <id>https://dragonliu2022.github.io/2022/05/11/Linux%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/</id>
    <published>2022-05-10T16:43:44.000Z</published>
    <updated>2022-05-10T16:52:12.494Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-系统版本"><a class="markdownIt-Anchor" href="#1-系统版本"></a> 1 系统版本</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(base) [ccyin@localhost ~]$ cat /etc/redhat-release</span><br><span class="line">CentOS Linux release 7.6.1810 (Core)</span><br></pre></td></tr></table></figure><p><a href="https://jingyan.baidu.com/article/425e69e6ada3edff14fc167c.html" target="_blank" rel="noopener">Linux怎么查看操作系统版本号</a></p><h1 id="2-显卡"><a class="markdownIt-Anchor" href="#2-显卡"></a> 2 显卡</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvidia-smi</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/dcrmg/article/details/78146797" target="_blank" rel="noopener">Linux查看GPU信息和使用情况</a></p><h1 id="3-cpu"><a class="markdownIt-Anchor" href="#3-cpu"></a> 3 CPU</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat  /proc/cpuinfo</span><br></pre></td></tr></table></figure><p><a href="https://www.yisu.com/zixun/132704.html" target="_blank" rel="noopener">linux查看cpu型号的方法</a></p><h1 id="4-内存"><a class="markdownIt-Anchor" href="#4-内存"></a> 4 内存</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(base) [ccyin@localhost ~]$ cat /proc/meminfo</span><br><span class="line">MemTotal:       263591864 kB</span><br><span class="line">MemFree:        191960176 kB</span><br><span class="line">MemAvailable:   246338560 kB</span><br><span class="line">Buffers:          119332 kB</span><br><span class="line">Cached:         53866512 kB</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">(base) [ccyin@localhost ~]$ free -m</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:         257413       15579      187461          27       54372      240565</span><br><span class="line">Swap:          4095           0        4095</span><br></pre></td></tr></table></figure><p><a href="https://www.programminghunter.com/article/9454887470/" target="_blank" rel="noopener">linux 查看CPU、内存大小</a></p><h1 id="5-硬盘"><a class="markdownIt-Anchor" href="#5-硬盘"></a> 5 硬盘</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(base) [ccyin@localhost ~]$ df -h</span><br><span class="line">文件系统                 容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/mapper/centos-root   50G   16G   35G   31% /</span><br><span class="line">devtmpfs                 126G     0  126G    0% /dev</span><br><span class="line">tmpfs                    126G  8.0K  126G    1% /dev/shm</span><br><span class="line">tmpfs                    126G   12M  126G    1% /run</span><br><span class="line">tmpfs                    126G     0  126G    0% /sys/fs/cgroup</span><br><span class="line">/dev/sda2               1014M  182M  833M   18% /boot</span><br><span class="line">/dev/mapper/centos-home  2.2T  1.5T  724G   67% /home</span><br><span class="line">tmpfs                     26G   12K   26G    1% /run/user/42</span><br><span class="line">tmpfs                     26G     0   26G    0% /run/user/1005</span><br><span class="line">tmpfs                     26G     0   26G    0% /run/user/1003</span><br><span class="line">tmpfs                     26G     0   26G    0% /run/user/1002</span><br><span class="line">tmpfs                     26G     0   26G    0% /run/user/1010</span><br><span class="line">/dev/mapper/data1-lvol0  8.0T  4.1G  7.6T    1% /data1</span><br></pre></td></tr></table></figure><p><a href="https://www.programminghunter.com/article/9454887470/" target="_blank" rel="noopener">linux 查看CPU、内存大小</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="环境与工具" scheme="https://Dragonliu2022.github.io/categories/环境与工具/"/>
    
    
  </entry>
  
  <entry>
    <title>PA报错之qemu: could not load PC BIOS &#39;bios-256k.bin&#39;</title>
    <link href="https://dragonliu2022.github.io/2022/05/10/PA%E6%8A%A5%E9%94%99%E4%B9%8Bqemu-could-not-load-PC-BIOS-bios-256k-bin/"/>
    <id>https://dragonliu2022.github.io/2022/05/10/PA%E6%8A%A5%E9%94%99%E4%B9%8Bqemu-could-not-load-PC-BIOS-bios-256k-bin/</id>
    <published>2022-05-10T14:24:04.000Z</published>
    <updated>2022-05-10T14:38:10.136Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-报错"><a class="markdownIt-Anchor" href="#1-报错"></a> 1 报错</h1><p>开启diff_test，nemu再make run后报错：</p><img src="https://s2.loli.net/2022/05/10/mGoDxkP4RLQbIjd.png" width="600" height="400" alt="图片名称" align="center" id="198"><h1 id="2-解决"><a class="markdownIt-Anchor" href="#2-解决"></a> 2 解决</h1><p>下面这些链接与遇到的问题相似，<strong>但是并未解决</strong></p><ul><li><a href="https://blog.csdn.net/zhangyexinaisurui/article/details/81806572" target="_blank" rel="noopener">qemu: could not load PC BIOS ‘bios-256k.bin’</a></li><li><a href="https://mlog.club/article/4454010" target="_blank" rel="noopener">由于缺少BIOS而无法启动KVM VM</a></li><li><a href="https://techglimpse.com/qemu-system-x86-command-error-solution/" target="_blank" rel="noopener">How to Fix Error – qemu: could not load PC BIOS ‘bios.bin’?</a></li></ul><p><strong>下面的方法解决了问题：</strong></p><p>自行编译一个 带i386,x86以及包含相关文件如’bios256k.bin’的qemu版本即可</p><p>参考：<a href="https://zhuanlan.zhihu.com/p/37329713" target="_blank" rel="noopener">QEMU虚拟机编译使用实践</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计组" scheme="https://Dragonliu2022.github.io/categories/计组/"/>
    
    
  </entry>
  
  <entry>
    <title>模型的评价指标</title>
    <link href="https://dragonliu2022.github.io/2022/04/26/%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/"/>
    <id>https://dragonliu2022.github.io/2022/04/26/%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/</id>
    <published>2022-04-26T06:59:37.000Z</published>
    <updated>2022-05-05T13:00:59.539Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>评估在测试集上计算</p></blockquote><h1 id="1-基本"><a class="markdownIt-Anchor" href="#1-基本"></a> 1 基本</h1><ul><li><strong>TP</strong>（True positives）：代表软件样本被认为是此类型，实际标签正是此类型；</li><li><strong>TN</strong>（True negatives）代表软件样本被认为不是此类型，实际标签不是此类型；</li><li><strong>FP</strong>（False positives）：代表软件样本被认为是此类型，实际标签不是此类型；</li><li><strong>FN</strong>（False negatives）：代表软件样本被认为不是此类型，实际标签正是此类型。</li></ul><h1 id="2-准确率accuracy"><a class="markdownIt-Anchor" href="#2-准确率accuracy"></a> 2 准确率（Accuracy）</h1><p>被预测正确的比例：<strong>Accuracy = (TP+TN) / (TP+TN+FP+FN)</strong></p><p>样本不平均的情况，此时模型评估不能仅仅依靠准确率。因此需要再结合F1值（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>F</mi><mn>1</mn></msub><mo>−</mo><mi>s</mi><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">F_1-score</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.13889em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord mathit">s</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">e</span></span></span></span>）</p><h1 id="3-精确率precision"><a class="markdownIt-Anchor" href="#3-精确率precision"></a> 3 精确率（Precision）</h1><p>&quot;正确被预测为正(TP)&quot;占所有&quot;实际被预测为正的(TP+FP)&quot;的比例（混淆矩阵中除以所在的那一列之和），可信度</p><p><strong>Precision = TP / (TP+FP)</strong></p><h1 id="4-召回率recall"><a class="markdownIt-Anchor" href="#4-召回率recall"></a> 4 召回率（Recall）</h1><p>&quot;正确被预测为正(TP)&quot;占所有&quot;应该被预测为正(TP+FN)&quot;的比例（混淆矩阵中除以所在的那一行之和），查全率</p><p><strong>Recall = TP / (TP+FN)</strong></p><h1 id="5-f1值f1-score"><a class="markdownIt-Anchor" href="#5-f1值f1-score"></a> 5 F1值（F1-score）</h1><p>同时考虑了精确率和召回率，precison和recall的调和平均值(?)</p><p><strong>F1 = 2*Recall*Precision / (Recall + Precision)</strong></p><h1 id="6-macro-f1"><a class="markdownIt-Anchor" href="#6-macro-f1"></a> 6 Macro F1</h1><p>将n分类的评价拆成n个二分类的评价，计算每个二分类的F1 score，n个F1 score的平均值即为Macro F1。</p><h1 id="7-micro-f1"><a class="markdownIt-Anchor" href="#7-micro-f1"></a> 7 Micro F1</h1><p>将n分类的评价拆成n个二分类的评价，将n个二分类评价的TP、FP、TN、FN对应相加，计算评价准确率和召回率，由这2个准确率和召回率计算的F1 score即为Micro F1。<br>(TP + FP) / (TP + TN + FP + FN)，实际上就是accuracy，分母就是输入分类器的预测样本个数，分子就是预测正确的样本个数（无论类别）。</p><p>一般来讲，Macro F1、Micro F1高的分类效果好。Macro F1受样本数量少的类别影响大。<br>宏平均比微平均更合理，但也不是说微平均一无是处，具体使用哪种评测机制，还是要取决于数据集中样本分布。</p><h1 id="8-加权平均f1"><a class="markdownIt-Anchor" href="#8-加权平均f1"></a> 8 加权平均F1(?)</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="AI" scheme="https://Dragonliu2022.github.io/categories/AI/"/>
    
    
    <category term="深度学习" scheme="https://Dragonliu2022.github.io/tags/深度学习/"/>
    
  </entry>
  
  <entry>
    <title>PA答疑之代码框架</title>
    <link href="https://dragonliu2022.github.io/2022/04/23/PA%E7%AD%94%E7%96%91%E4%B9%8B%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6/"/>
    <id>https://dragonliu2022.github.io/2022/04/23/PA%E7%AD%94%E7%96%91%E4%B9%8B%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6/</id>
    <published>2022-04-23T07:21:37.000Z</published>
    <updated>2022-04-23T07:42:43.216Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p><strong>转载</strong>：<a href="http://www.stardustdl.top/posts/learning/nju-icspa-analytics-nemu/" target="_blank" rel="noopener">NJU ICS Programming Assignment 代码分析 - NEMU</a></p></blockquote><blockquote><p>部分内容框架代码并不包含（如扩展的 Debug 宏），均为我为编码而添加的内容。采用 <code>a_b</code> 方式命名的多为原内容，采用 <code>aB</code> 方式命名的多为补充内容。由于此项目是 NJU ICS PA 的一部分，其中会包含与相关项目的互操作内容。</p></blockquote><p>NEMU (NJU EMUlator) 是在 Linux 上的一个 n86（x86 子集）模拟器，模拟了基本计算机系统的功能（内存，CPU等）。包含了：</p><ul><li>内存</li><li>CPU，寄存器</li><li>调试器（监视器）</li></ul><h1 id="1-框架代码结构"><a class="markdownIt-Anchor" href="#1-框架代码结构"></a> 1 框架代码结构</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nanos-lite/</span><br><span class="line">navy-apps/</span><br><span class="line">nexus-am/</span><br><span class="line">nemu/               <span class="comment"># NEMU 项目</span></span><br><span class="line">    build/          <span class="comment"># 构建输出文件夹</span></span><br><span class="line">        nemu        <span class="comment"># NEMU 主程序（可执行文件）</span></span><br><span class="line">    include/        <span class="comment"># 头文件</span></span><br><span class="line">    src/            <span class="comment"># 源码文件</span></span><br><span class="line">    tools/          <span class="comment"># 工具文件</span></span><br><span class="line">    runall.sh       <span class="comment"># 测试 AM cputest 测试集 （nexus-am/tests/cputest）</span></span><br><span class="line">    Makefile        <span class="comment"># NEMU 构建命令</span></span><br><span class="line">    Makefile.git    <span class="comment"># NEMU Git 记录命令</span></span><br></pre></td></tr></table></figure><p>nemu部分：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">nemu</span><br><span class="line">├── include                         <span class="comment">#   存放全局使用的头文件 </span></span><br><span class="line">|    ├── common.h                    <span class="comment">#   公用的头文件 </span></span><br><span class="line">|    ├── cpu</span><br><span class="line">|    |    ├── decode.h                <span class="comment">#   译码相关</span></span><br><span class="line">|    |    ├── exec.h                  <span class="comment">#   执行相关 </span></span><br><span class="line">|    |    ├── reg.h                   <span class="comment">#   寄存器结构体的定义 </span></span><br><span class="line">|    |    └── rtl.h                   <span class="comment">#   RTL指令 </span></span><br><span class="line">|    ├── debug.h                     <span class="comment">#   一些方便调试用的宏 </span></span><br><span class="line">|    ├── device                      <span class="comment">#   设备相关 </span></span><br><span class="line">|    ├── macro.h                     <span class="comment">#   一些方便的宏定义 </span></span><br><span class="line">|    ├── memory                      <span class="comment">#   访问内存相关 </span></span><br><span class="line">|    ├── monitor</span><br><span class="line">|    |    ├── expr.h</span><br><span class="line">|    |    ├── monitor.h</span><br><span class="line">|    |    └── watchpoint.h            <span class="comment">#   监视点相关 </span></span><br><span class="line">|    └── nemu.h</span><br><span class="line">├── Makefile                        <span class="comment">#   指示NEMU的编译和链接 </span></span><br><span class="line">├── Makefile.git                    <span class="comment">#   git版本控制相关 </span></span><br><span class="line">├── runall.sh                       <span class="comment">#   一键测试脚本 </span></span><br><span class="line">└── src                             <span class="comment">#   源文件</span></span><br><span class="line">    ├── cpu</span><br><span class="line">    |    ├── decode                  <span class="comment">#   译码相关</span></span><br><span class="line">    |    ├── <span class="built_in">exec</span>                    <span class="comment">#   执行相关 </span></span><br><span class="line">    |    ├── intr.c                  <span class="comment">#   中断处理相关</span></span><br><span class="line">    |    └── reg.c                   <span class="comment">#   寄存器相关    </span></span><br><span class="line">    ├── device                      <span class="comment">#   设备相关</span></span><br><span class="line">    ├── main.c                        </span><br><span class="line">    ├── memory</span><br><span class="line">    |    └── memory.c</span><br><span class="line">    ├── misc</span><br><span class="line">    |    └── logo.c                  <span class="comment">#   "i386"的logo</span></span><br><span class="line">    └── monitor</span><br><span class="line">        ├── cpu-exec.c              <span class="comment">#   指令执行的主循环</span></span><br><span class="line">        ├── diff-test</span><br><span class="line">        ├── debug                   <span class="comment">#   简易调试器相关</span></span><br><span class="line">        |    ├── expr.c              <span class="comment">#   表达式求值的实现</span></span><br><span class="line">        |    ├── ui.c                <span class="comment">#   用户界面相关    </span></span><br><span class="line">        |    └── watchpoint.c        <span class="comment">#   监视点的实现</span></span><br><span class="line">        └── monitor.c</span><br></pre></td></tr></table></figure><h1 id="2-include"><a class="markdownIt-Anchor" href="#2-include"></a> 2 include/</h1><h2 id="21-nemuh"><a class="markdownIt-Anchor" href="#21-nemuh"></a> 2.1 nemu.h</h2><p>基础头文件。包含了 <code>commom.h</code>，<code>memory/memory.h</code>，<code>cpu/reg.h</code></p><h2 id="22-macroh"><a class="markdownIt-Anchor" href="#22-macroh"></a> 2.2 macro.h</h2><p>定义了一些字符串连接宏 <code>concat</code> 等</p><h2 id="23-commonh"><a class="markdownIt-Anchor" href="#23-commonh"></a> 2.3 common.h</h2><p>定义了一些类型别名。</p><table><thead><tr><th style="text-align:center">类型别名</th><th style="text-align:center">原类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>rtlreg_t</code></td><td style="text-align:center"><code>uint32_t</code></td><td style="text-align:center">RTL寄存器</td></tr><tr><td style="text-align:center"><code>vaddr_t</code></td><td style="text-align:center"><code>uint32_t</code></td><td style="text-align:center">虚拟地址</td></tr><tr><td style="text-align:center"><code>paddr_t</code></td><td style="text-align:center"><code>uint32_t</code></td><td style="text-align:center">物理地址</td></tr><tr><td style="text-align:center"><code>ioaddr_t</code></td><td style="text-align:center"><code>uint16_t</code></td><td style="text-align:center">I/O 端口地址</td></tr></tbody></table><ul><li><code>relreg_t</code> 多用于寄存器访问</li><li><code>vaddr_t</code> <code>paddr_t</code> 多用于内存访问</li><li><code>ioaddr_t</code> 多用于设备 I/O 端口访问</li></ul><p>定义了一些控制编译方式的宏。</p><table><thead><tr><th style="text-align:center">宏</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>DEBUG</code></td><td style="text-align:center">启用调试</td></tr><tr><td style="text-align:center"><code>DIFF_TEST</code></td><td style="text-align:center">启用 diff-test</td></tr><tr><td style="text-align:center"><code>HAS_IOE</code></td><td style="text-align:center">启用输入输出扩展</td></tr></tbody></table><ul><li><code>DIFF_TEST</code> 可启用一个差异测试工具，参见 <code>tools/qemu-diff</code> 部分。</li><li><code>HAS_IOE</code> 启用输入输出设备，参见设备部分。</li></ul><h2 id="24-debugh"><a class="markdownIt-Anchor" href="#24-debugh"></a> 2.4 debug.h</h2><p>定义了便于调试的宏。</p><table><thead><tr><th style="text-align:center">宏</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>Log_write(format, ...)</code></td><td style="text-align:center">仅记录日志</td></tr><tr><td style="text-align:center"><code>printflog(format, ...)</code></td><td style="text-align:center">显示文本并记录日志</td></tr><tr><td style="text-align:center"><code>Log(format, ...)</code></td><td style="text-align:center">对 <code>printflog</code> 的扩展，包含当前文件，行，函数</td></tr><tr><td style="text-align:center"><code>Info(format, ...)</code></td><td style="text-align:center">对 <code>Log</code> 的扩展，日志级别：提示</td></tr><tr><td style="text-align:center"><code>Warning(format, ...)</code></td><td style="text-align:center">对 <code>Log</code> 的扩展，日志级别：警告</td></tr><tr><td style="text-align:center"><code>Error(format, ...)</code></td><td style="text-align:center">对 <code>Log</code> 的扩展，日志级别：错误</td></tr><tr><td style="text-align:center"><code>panic(format, ...)</code></td><td style="text-align:center">强制退出，显示文本并记录日志</td></tr><tr><td style="text-align:center"><code>Assert(cond [, format, ...])</code></td><td style="text-align:center">设置断言，失败时强制退出，显示文本并记录日志</td></tr><tr><td style="text-align:center"><code>TODO()</code></td><td style="text-align:center">标识待完成项，执行时会触发 <code>panic</code></td></tr></tbody></table><h2 id="25-cpu"><a class="markdownIt-Anchor" href="#25-cpu"></a> 2.5 cpu/</h2><h3 id="251-regh"><a class="markdownIt-Anchor" href="#251-regh"></a> 2.5.1 reg.h</h3><p>定义了寄存器结构，和辅助寄存器的一些宏和函数。</p><ul><li>外部数组 <code>regsl, regsw, regsb</code> 不同寄存器名。实现在 <code>src/cpu/reg.c</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">char</span>* regsl[];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">char</span>* regsw[];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">char</span>* regsb[];</span><br></pre></td></tr></table></figure><h4 id="结构体-cpu_state"><a class="markdownIt-Anchor" href="#结构体-cpu_state"></a> 结构体 CPU_state</h4><p>寄存器结构，包含了所有寄存器，均为无符号整数。</p><ul><li>对于 8 个通用寄存器，内部以 <code>gpr</code> 数组为基础结构，提供 <code>eax</code> 等别名方便访问。寄存器按照 i386 指令中寄存器标号顺序排列。可使用 <code>_16,_8[0],_8[1]</code> 访问寄存器低位部分。</li><li><code>eip</code> 当前执行指令位置寄存器</li><li><code>eflags</code>标志位寄存器（使用匿名结构体，可直接访问<code>CF,OF,ZF,SF</code>）<ul><li><code>eflags</code> 初始化为 <code>0x2</code></li></ul></li><li><code>cs,ss,ds,es,fs,gs</code>程序段寄存器（仅为支持 diff-test）<ul><li><code>cs</code> 初始化为 <code>8</code></li></ul></li><li><code>idtr</code>：48 位寄存器，存放 IDT (Interrupt Descriptor Table, 中断描述符表)的首地址和长度<ul><li><code>limit</code> 16位，长度，单位：字节</li><li><code>base</code> 32位，IDT 基地址</li></ul></li></ul><table><thead><tr><th style="text-align:center">函数/宏</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>reg_l(index)</code></td><td style="text-align:center">获取指定下标处寄存器32位值</td></tr><tr><td style="text-align:center"><code>reg_w(index)</code></td><td style="text-align:center">获取指定下标处寄存器低16位值</td></tr><tr><td style="text-align:center"><code>reg_b(index)</code></td><td style="text-align:center">获取指定下标处寄存器低8位值</td></tr><tr><td style="text-align:center"><code>reg_name(index,width)</code></td><td style="text-align:center">根据下标和位宽获得寄存器名</td></tr></tbody></table><blockquote><p>寄存器存储在变量 <code>cpu</code> 中。</p></blockquote><h4 id="枚举"><a class="markdownIt-Anchor" href="#枚举"></a> 枚举</h4><p>定义了形如 <code>R_NAME</code> 的寄存器枚举，其顺序与寄存器结构中的顺序一致。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; R_EAX, R_ECX, R_EDX, R_EBX, R_ESP, R_EBP, R_ESI, R_EDI &#125;;</span><br><span class="line"><span class="keyword">enum</span> &#123; R_AX, R_CX, R_DX, R_BX, R_SP, R_BP, R_SI, R_DI &#125;;</span><br><span class="line"><span class="keyword">enum</span> &#123; R_AL, R_CL, R_DL, R_BL, R_AH, R_CH, R_DH, R_BH &#125;;</span><br></pre></td></tr></table></figure><h3 id="252-decodeh"><a class="markdownIt-Anchor" href="#252-decodeh"></a> 2.5.2 decode.h</h3><p>定义了用于指令译码的结构和函数。</p><h4 id="结构体-operand"><a class="markdownIt-Anchor" href="#结构体-operand"></a> 结构体 Operand</h4><p>操作数。</p><table><thead><tr><th style="text-align:left">成员</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>type</code></td><td style="text-align:left">类型（见下方枚举）</td></tr><tr><td style="text-align:left"><code>width</code></td><td style="text-align:left">位宽</td></tr><tr><td style="text-align:left"><code>val</code></td><td style="text-align:left">实际值</td></tr><tr><td style="text-align:left"><code>str</code></td><td style="text-align:left">原串（用于调试输出）</td></tr><tr><td style="text-align:left"><code>reg</code></td><td style="text-align:left">寄存器下标</td></tr><tr><td style="text-align:left"><code>addr</code></td><td style="text-align:left">内存地址</td></tr><tr><td style="text-align:left"><code>imm</code></td><td style="text-align:left">立即数</td></tr><tr><td style="text-align:left"><code>simm</code></td><td style="text-align:left">带符号立即数</td></tr></tbody></table><h4 id="结构体-decodeinfo"><a class="markdownIt-Anchor" href="#结构体-decodeinfo"></a> 结构体 DecodeInfo</h4><p>单条命令译码结果。</p><table><thead><tr><th style="text-align:left">成员</th><th style="text-align:left">描述</th><th style="text-align:left">对应x86指令部分</th></tr></thead><tbody><tr><td style="text-align:left"><code>opcode</code></td><td style="text-align:left">指令码</td><td style="text-align:left">opcode</td></tr><tr><td style="text-align:left"><code>seq_eip</code></td><td style="text-align:left">序列 EIP 位置</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>is_operand_size_16</code></td><td style="text-align:left">标识操作数是否为 16 位</td><td style="text-align:left">operand-size prefix</td></tr><tr><td style="text-align:left"><code>ext_opcode</code></td><td style="text-align:left">额外指令码</td><td style="text-align:left">ModR/M 中 opcode</td></tr><tr><td style="text-align:left"><code>is_jmp</code></td><td style="text-align:left">标识是否为跳转语句</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>jmp_eip</code></td><td style="text-align:left">跳转目标（绝对地址），仅对于跳转语句</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>src</code></td><td style="text-align:left">源操作数</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>src2</code></td><td style="text-align:left">第二个源操作数</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>dest</code></td><td style="text-align:left">目标操作数</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>assembly</code></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>asm_buf</code></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>p</code></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><ul><li><code>seq_eip</code> 随译码过程改变，最终停留在需要译码的下一个位置，可根据这一值实现 eip 更新。</li><li><code>is_operand_size_16</code> 多用于实现单命令存在 16 位，32 位两个版本的情况</li><li><code>ext_opcode</code> 用于实现 <code>sub /5</code> 这种根据第二个指令码 <code>/5</code> 区分不同指令的情况，在译码中使用 <code>make_group</code> 实现。</li><li><code>is_jmp</code> 多在运行时指定（如 <code>rtl_j</code> 函数），如果标记，则不会再根据 <code>seq_eip</code> 更新 eip</li></ul><table><thead><tr><th style="text-align:left">函数/宏</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>id_src</code></td><td style="text-align:left"><code>(&amp;decoding.src)</code></td></tr><tr><td style="text-align:left"><code>id_src2</code></td><td style="text-align:left"><code>(&amp;decoding.src2)</code></td></tr><tr><td style="text-align:left"><code>id_dest</code></td><td style="text-align:left"><code>(&amp;decoding.dest)</code></td></tr><tr><td style="text-align:left"><code>operand_write(Operand *, rtlreg_t *)</code></td><td style="text-align:left">根据第一个参数中记录的类型的不同进行相应的写操作，包括写寄存器和写内存</td></tr><tr><td style="text-align:left"><code>load_addr(vaddr_t *, ModR_M *, Operand *)</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>read_ModR_M(vaddr_t *, Operand *, bool, Operand *, bool)</code></td><td style="text-align:left"></td></tr></tbody></table><blockquote><p>译码内容存储在变量 <code>decoding</code> 中。</p></blockquote><h4 id="结构体-modr_m"><a class="markdownIt-Anchor" href="#结构体-modr_m"></a> 结构体 ModR_M</h4><p>指令中的 ModR/M。</p><h4 id="结构体-sib"><a class="markdownIt-Anchor" href="#结构体-sib"></a> 结构体 SIB</h4><p>指令中的 SIB。</p><h4 id="枚举-2"><a class="markdownIt-Anchor" href="#枚举-2"></a> 枚举</h4><p>定义了操作数的类型 <code>OP_TYPE_REG</code>，<code>OP_TYPE_MEM</code>，<code>OP_TYPE_IMM</code>，分别为寄存器，内存，立即数。</p><h4 id="宏-make_dhelper-与函数族-decode_name"><a class="markdownIt-Anchor" href="#宏-make_dhelper-与函数族-decode_name"></a> 宏 make_DHelper 与函数族 decode_name</h4><p>由宏 <code>make_DHelper</code> 定义了一族函数（参数相同），用于指令译码，并定义了这些函数的指针类型 <code>DHelper</code>。</p><ul><li>设计目的：由于大量指令的操作数模式相似，将这一点提取出来，实现解耦。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> make_DHelper(name) void concat(decode_, name) (vaddr_t *eip)</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*DHelper)</span> <span class="params">(<span class="keyword">vaddr_t</span> *)</span></span>;</span><br></pre></td></tr></table></figure><p>函数族中部分函数命名规则（<strong>不全</strong>）：</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>I</code></td><td style="text-align:left">立即数</td></tr><tr><td style="text-align:left"><code>SI</code></td><td style="text-align:left">有符号立即数</td></tr><tr><td style="text-align:left"><code>E</code></td><td style="text-align:left">内存或寄存器（对应指令描述中的 r/m）</td></tr><tr><td style="text-align:left"><code>G</code></td><td style="text-align:left">通用寄存器</td></tr><tr><td style="text-align:left"><code>r</code></td><td style="text-align:left">单一寄存器</td></tr><tr><td style="text-align:left"><code>a</code></td><td style="text-align:left">指定寄存器为 <code>eax,ax,al</code></td></tr><tr><td style="text-align:left"><code>I2G</code></td><td style="text-align:left">立即数到通用寄存器</td></tr><tr><td style="text-align:left"><code>I_E2G</code></td><td style="text-align:left">立即数与内存或寄存器到通用寄存器</td></tr><tr><td style="text-align:left"><code>O</code></td><td style="text-align:left">未知</td></tr></tbody></table><ul><li><code>r</code> 一般用于寄存器信息存储在 <code>opcode</code> 中的情况</li><li>还有一些专用于特定指令的译码函数</li></ul><blockquote><p>建议结合 i386 手册附录 C 理解。</p></blockquote><p>函数族中特殊函数：</p><ul><li><code>J</code> 跳转指令解码。单操作数，存储到 <code>jmp_eip</code> 中。</li></ul><h3 id="253-exech"><a class="markdownIt-Anchor" href="#253-exech"></a> 2.5.3 exec.h</h3><p>定义了一些用于调试的指令打印宏：</p><table><thead><tr><th style="text-align:left">宏</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>print_asm</code></td><td style="text-align:left">打印指令</td></tr><tr><td style="text-align:left"><code>suffix_char</code></td><td style="text-align:left">根据宽度获取指令宽度后缀</td></tr><tr><td style="text-align:left"><code>print_asm_template1</code></td><td style="text-align:left">单操作数指令</td></tr><tr><td style="text-align:left"><code>print_asm_template2</code></td><td style="text-align:left">双操作数指令</td></tr><tr><td style="text-align:left"><code>print_asm_template3</code></td><td style="text-align:left">三操作数指令</td></tr></tbody></table><h4 id="函数-instr_fetch"><a class="markdownIt-Anchor" href="#函数-instr_fetch"></a> 函数 instr_fetch</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">instr_fetch</span><span class="params">(<span class="keyword">vaddr_t</span> *eip, <span class="keyword">int</span> len)</span></span></span><br></pre></td></tr></table></figure><p>从 <code>eip</code> 开始，读取 <code>len</code> 个字节，返回值，并自动增加 <code>eip</code>。</p><ul><li>设计目的：与机器的大端小端解耦。</li></ul><h4 id="宏-make_ehelper-与-函数族-exec_name"><a class="markdownIt-Anchor" href="#宏-make_ehelper-与-函数族-exec_name"></a> 宏 make_EHelper 与 函数族 exec_name</h4><p>用于定义一族函数（参数相同），用于指令执行，并定义了这些函数的指针类型 <code>EHelper</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> make_EHelper(name) void concat(exec_, name) (vaddr_t *eip)</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*EHelper)</span> <span class="params">(<span class="keyword">vaddr_t</span> *)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="254-reloph"><a class="markdownIt-Anchor" href="#254-reloph"></a> 2.5.4 relop.h</h3><p>定义了形如 <code>RELOP_NAME</code> 的枚举，标识不同类型的关系运算。对应了 <code>setcc,jcc</code> 命令的相应编码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">  <span class="comment">//            +-- unsign</span></span><br><span class="line">  <span class="comment">//            |   +-- sign</span></span><br><span class="line">  <span class="comment">//            |   |   +-- equal</span></span><br><span class="line">  <span class="comment">//            |   |   |   +-- invert</span></span><br><span class="line">  <span class="comment">//            |   |   |   |</span></span><br><span class="line">  RELOP_FALSE = <span class="number">0</span> | <span class="number">0</span> | <span class="number">0</span> | <span class="number">0</span>,</span><br><span class="line">  RELOP_TRUE  = <span class="number">0</span> | <span class="number">0</span> | <span class="number">0</span> | <span class="number">1</span>,</span><br><span class="line">  RELOP_EQ    = <span class="number">0</span> | <span class="number">0</span> | <span class="number">2</span> | <span class="number">0</span>,</span><br><span class="line">  RELOP_NE    = <span class="number">0</span> | <span class="number">0</span> | <span class="number">2</span> | <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  RELOP_LT    = <span class="number">0</span> | <span class="number">4</span> | <span class="number">0</span> | <span class="number">0</span>,</span><br><span class="line">  RELOP_LE    = <span class="number">0</span> | <span class="number">4</span> | <span class="number">2</span> | <span class="number">0</span>,</span><br><span class="line">  RELOP_GT    = <span class="number">0</span> | <span class="number">4</span> | <span class="number">2</span> | <span class="number">1</span>,</span><br><span class="line">  RELOP_GE    = <span class="number">0</span> | <span class="number">4</span> | <span class="number">0</span> | <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  RELOP_LTU   = <span class="number">8</span> | <span class="number">0</span> | <span class="number">0</span> | <span class="number">0</span>,</span><br><span class="line">  RELOP_LEU   = <span class="number">8</span> | <span class="number">0</span> | <span class="number">2</span> | <span class="number">0</span>,</span><br><span class="line">  RELOP_GTU   = <span class="number">8</span> | <span class="number">0</span> | <span class="number">2</span> | <span class="number">1</span>,</span><br><span class="line">  RELOP_GEU   = <span class="number">8</span> | <span class="number">0</span> | <span class="number">0</span> | <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="255-cch"><a class="markdownIt-Anchor" href="#255-cch"></a> 2.5.5 cc.h</h3><p>定义了函数 <code>get_cc_name</code> 根据编码获取指定关系运算字符串。</p><p>定义了 RTL 基本指令 <code>rtl_setcc</code> 用于根据当前关系运算和 eflags 寄存器标志位设置 dest。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_setcc</span><span class="params">(<span class="keyword">rtlreg_t</span>*, <span class="keyword">uint8_t</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="256-rtlh"><a class="markdownIt-Anchor" href="#256-rtlh"></a> 2.5.6 rtl.h</h3><p>定义和实现了一些 RTL 指令，用于提供对指令执行的底层建模。可使用这些操作将复杂指令分解成更简单的操作。</p><p>NEMU 中的 RTL 寄存器：</p><ul><li>x86的八个通用寄存器(在 <code>include/cpu/reg.h</code> 中定义)</li><li><code>id_src</code>, <code>id_src2</code> 和 <code>id_dest</code> 中的访存地址 <code>addr</code> 和操作数内容 <code>val</code> (在 <code>include/cpu/decode.h</code> 中定义). 从概念上看, 它们分别与MAR和 MDR有异曲同工之妙</li><li>临时寄存器 <code>t0~t3</code> 和 <code>at</code> (在 <code>src/cpu/decode/decode.c</code> 中定义)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">rtlreg_t</span> t0, t1, t2, t3, at;</span><br></pre></td></tr></table></figure><ul><li>宏<code>make_rtl_arith_logic</code>根据算术运算符名创建对应 RTL 基本指令和 RTL 指令，使用了<code>include/util/c_op.h</code>中的运算。<ul><li>32位寄存器-寄存器类型的算术/逻辑运算</li><li>32位寄存器-立即数类型的算术/逻辑运算</li></ul></li><li>定义函数 <code>decoding_set_jmp(bool is_jmp)</code> ：将 当前指令标记为跳转（标记 <code>decoing.is_jmp</code>）</li><li>定义函数 <code>interpret_relop</code> ：实现两个值的关系运算，返回结果（实现在 <code>src/cpu/exec/relop.c</code></li></ul><h4 id="rtl-基本指令"><a class="markdownIt-Anchor" href="#rtl-基本指令"></a> RTL 基本指令</h4><p>特点：不需要使用临时寄存器, 可以看做是最基本的x86指令中的最基本的操作。 实现时添加了 <code>interpret_</code> 前缀，但在 <code>include/cpu/rtl-wrapper.h</code> 作用下，其它代码中使用到这些RTL基本指令时会自动添加 <code>interpret_</code> 前缀。</p><ul><li>立即数读入 <code>rtl_li</code></li><li>寄存器传输 <code>rtl_mv</code></li><li>32位寄存器-寄存器类型的算术/逻辑运算, 包括 <code>rtl_(add|sub|and|or|xor|shl|shr|sar|i?mul_[lo|hi]|i?div_[q|r])</code> , 这些运算的定义用到 <code>include/util/c_op.h</code> 中的C语言运算</li><li>被除数为64位的除法运算 <code>rtl_i?div64_[q|r]</code></li><li>guest内存访问 <code>rtl_lm</code> 和 <code>rtl_sm</code></li><li>host内存访问 <code>rtl_host_lm</code> 和 <code>rtl_host_sm</code></li><li>关系运算 <code>rtl_setrelop</code>, 具体可参考 <code>src/cpu/exec/relop.c</code></li><li>跳转, 包括直接跳转 <code>rtl_j</code> , 间接跳转 <code>rtl_jr</code> 和条件跳转 <code>rtl_jrelop</code></li><li>终止程序 <code>rtl_exit</code></li></ul><p>具体声明：</p><ul><li>未标明则函数修饰符均为 <code>static inline</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 立即数读入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interpret_rtl_li</span><span class="params">(<span class="keyword">rtlreg_t</span>* dest, <span class="keyword">uint32_t</span> imm)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器传输</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interpret_rtl_mv</span><span class="params">(<span class="keyword">rtlreg_t</span>* dest, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span> *src1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 32位寄存器-寄存器类型的算术/逻辑运算</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interpret_rtl_add</span> <span class="params">(<span class="keyword">rtlreg_t</span>* dest, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src1, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被除数为64位的除法运算</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interpret_rtl_div64_q</span><span class="params">(<span class="keyword">rtlreg_t</span>* dest,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src1_hi, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src1_lo, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// guest内存访问</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interpret_rtl_lm</span><span class="params">(<span class="keyword">rtlreg_t</span> *dest, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* addr, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interpret_rtl_sm</span><span class="params">(<span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* addr, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src1, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// host内存访问</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interpret_rtl_host_lm</span><span class="params">(<span class="keyword">rtlreg_t</span>* dest, <span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interpret_rtl_host_sm</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span> *src1, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关系运算</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interpret_rtl_setrelop</span><span class="params">(<span class="keyword">uint32_t</span> relop, <span class="keyword">rtlreg_t</span> *dest, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span> *src1, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span> *src2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interpret_rtl_j</span><span class="params">(<span class="keyword">vaddr_t</span> target)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interpret_rtl_jr</span><span class="params">(<span class="keyword">rtlreg_t</span> *target)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interpret_rtl_jrelop</span><span class="params">(<span class="keyword">uint32_t</span> relop, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span> *src1, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span> *src2, <span class="keyword">vaddr_t</span> target)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终止程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interpret_rtl_exit</span><span class="params">(<span class="keyword">int</span> state)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="rtl-伪指令"><a class="markdownIt-Anchor" href="#rtl-伪指令"></a> RTL 伪指令</h4><p>通过RTL基本指令或者已经实现的RTL伪指令来实现。</p><ul><li>32位寄存器-立即数类型的算术/逻辑运算, 包括 <code>rtl_(add|sub|and|or|xor|shl|shr|sar|i?mul_[lo|hi]|i?div_[q|r])_i</code></li><li>通用寄存器访问 <code>rtl_lr</code> 和 <code>rtl_sr</code></li><li>EFLAGS标志位的读写 <code>rtl_set_(CF|OF|ZF|SF)</code> 和 <code>rtl_get_(CF|OF|ZF|SF)</code></li><li>其它常用功能, 如按位取反 <code>rtl_not</code> ，符号扩展 <code>rtl_sext</code> 等</li></ul><p>具体声明：</p><ul><li>未标明则函数修饰符均为 <code>static inline</code>。</li><li>宏<code>make_rtl_setget_eflags</code>声明了需要实现的 EFLAGS标志位的读写 指令<ul><li><code>rtl_set_name</code></li><li><code>rtl_get_name</code></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 32位寄存器-立即数类型的算术/逻辑运算</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_addi</span> <span class="params">(<span class="keyword">rtlreg_t</span>* dest, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src1, <span class="keyword">int</span> imm)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 通用寄存器访问</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_lr</span><span class="params">(<span class="keyword">rtlreg_t</span>* dest, <span class="keyword">int</span> r, <span class="keyword">int</span> <span class="built_in">width</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_sr</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src1, <span class="keyword">int</span> <span class="built_in">width</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EFLAGS标志位的读写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_set_CF</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_get_CF</span> <span class="params">(<span class="keyword">rtlreg_t</span>* dest)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_set_OF</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_get_OF</span> <span class="params">(<span class="keyword">rtlreg_t</span>* dest)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_set_ZF</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_get_ZF</span> <span class="params">(<span class="keyword">rtlreg_t</span>* dest)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_set_SF</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_get_SF</span> <span class="params">(<span class="keyword">rtlreg_t</span>* dest)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据运算结构更新 ZF, SF 标志位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_update_ZF</span><span class="params">(<span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* result, <span class="keyword">int</span> <span class="built_in">width</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_update_SF</span><span class="params">(<span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* result, <span class="keyword">int</span> <span class="built_in">width</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_update_ZFSF</span><span class="params">(<span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* result, <span class="keyword">int</span> <span class="built_in">width</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按位取反</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_not</span><span class="params">(<span class="keyword">rtlreg_t</span> *dest, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 符号扩展</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_sext</span><span class="params">(<span class="keyword">rtlreg_t</span>* dest, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src1, <span class="keyword">int</span> <span class="built_in">width</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_push</span><span class="params">(<span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_pop</span><span class="params">(<span class="keyword">rtlreg_t</span>* dest)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 32位寄存器-立即数类型 关系运算</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_setrelopi</span><span class="params">(<span class="keyword">uint32_t</span> relop, <span class="keyword">rtlreg_t</span> *dest, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span> *src1, <span class="keyword">int</span> imm)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取符号位（最高位）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_msb</span><span class="params">(<span class="keyword">rtlreg_t</span>* dest, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src1, <span class="keyword">int</span> <span class="built_in">width</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>我们定义RTL基本指令的时候, 约定了RTL基本指令不需要使用RTL临时寄存器. 但某些RTL伪指令需要使用临时寄存器存放中间结果, 才能实现其完整功能. 这样可能会带来寄存器覆盖的问题, 例如如下RTL指令序列:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1) rtl_mv(&amp;t0, &amp;t1);</span><br><span class="line">(2) rtl_sext(&amp;t1, &amp;t2, 1);  // use t0 temporarily</span><br><span class="line">(3) rtl_add(&amp;t2, &amp;t0, &amp;t1);</span><br></pre></td></tr></table></figure><p>如果实现(2)的时候恰好使用到了t0作为临时寄存器, 在(3)中使用的t0就不再是(1)的结果了, 从而产生非预期的结果.</p><p>为了尽可能避免上述问题, 我们有两条约定:</p><ul><li>实现RTL伪指令的时候, 尽可能不使用 <code>dest</code> 之外的寄存器存放中间结果. 由于 <code>dest</code> 最后会被写入新值, 其旧值肯定要被覆盖, 自然也可以安全地作为RTL伪指令的临时寄存器.</li><li>实在需要使用临时寄存器的时候, 使用 <code>at</code> . <code>at</code> 全称是assembly temporary, 是MIPS ABI中定义的一个特殊寄存器: 编译器并不会使用它, 它可以在编写汇编代码的时候安全地作为可使用的临时寄存器. 在这里， 我们借鉴它的功能来作如下约定: 不要在RTL伪指令的内部实现之外使用 <code>at</code> . 这样， <code>at</code> 就可以安全地作为RTL伪指令的临时寄存器了.</li></ul><h3 id="257-rtl-wrapperh"><a class="markdownIt-Anchor" href="#257-rtl-wrapperh"></a> 2.5.7 rtl-wrapper.h</h3><p>为 rtl.h 中定义的 RTL 基本指令的调用省去 <code>interpret_</code> 前缀。</p><h2 id="26-memory"><a class="markdownIt-Anchor" href="#26-memory"></a> 2.6 memory/</h2><h3 id="261-memoryh"><a class="markdownIt-Anchor" href="#261-memoryh"></a> 2.6.1 memory.h</h3><p>定义了访问内存的函数。使用数组 <code>pmem</code> 模拟内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">uint8_t</span> pmem[];</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">函数/宏</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>uint32_t vaddr_read(vaddr_t, int)</code></td><td style="text-align:left">从虚拟内存指定位置读取指定数目个字节</td></tr><tr><td style="text-align:left"><code>void vaddr_write(vaddr_t, uint32_t, int)</code></td><td style="text-align:left">向虚拟内存指定位置写入指定数目个字节</td></tr><tr><td style="text-align:left"><code>uint32_t paddr_read(paddr_t, int)</code></td><td style="text-align:left">从物理内存指定位置读取指定数目个字节</td></tr><tr><td style="text-align:left"><code>void paddr_write(paddr_t, uint32_t, int)</code></td><td style="text-align:left">向物理内存指定位置写入指定数目个字节</td></tr><tr><td style="text-align:left"><code>guest_to_host(p)</code></td><td style="text-align:left"><code>((void *)(pmem + (unsigned)p))</code></td></tr><tr><td style="text-align:left"><code>host_to_guest(p)</code></td><td style="text-align:left"><code>((paddr_t)((void *)p - (void *)pmem))</code></td></tr></tbody></table><h3 id="262-mmuh"><a class="markdownIt-Anchor" href="#262-mmuh"></a> 2.6.2 mmu.h</h3><p>(TODO)</p><h4 id="结构体-gatedesc"><a class="markdownIt-Anchor" href="#结构体-gatedesc"></a> 结构体 GateDesc</h4><p>指示中断操作的门描述符(Gate Descriptor)类型。门描述符是一个8字节的结构体, 里面包含着不少细节的信息, 在NEMU中简化了门描述符的结构, 只保留存在位P和偏移量OFFSET。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 31                23                15                7                0</span><br><span class="line">+-----------------+-----------------+---+-------------------------------+</span><br><span class="line">|           OFFSET 31..16           | P |          Don&apos;t care           |4</span><br><span class="line">+-----------------------------------+---+-------------------------------+</span><br><span class="line">|             Don&apos;t care            |           OFFSET 15..0            |0</span><br><span class="line">+-----------------+-----------------+-----------------+-----------------+</span><br></pre></td></tr></table></figure><p>在 <code>raise_intr</code>（定义在 <code>intr.c</code> 中）中使用。</p><table><thead><tr><th style="text-align:left">成员</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>offset_15_0</code></td><td style="text-align:left">Offset 低位部分</td></tr><tr><td style="text-align:left"><code>offset_31_16</code></td><td style="text-align:left">Offset 高位部分</td></tr><tr><td style="text-align:left"><code>present</code></td><td style="text-align:left">标识是否有效</td></tr></tbody></table><ul><li>为方便从内存中读取，使用 union 结构以及 <code>val0 val1</code> 域简化读写。</li><li>此结构体与 AM 中定义的 <code>GateDesc</code> （在 <code>arch/x86-nemu/include/x86.h</code> 中）结构相同。</li></ul><h2 id="27-device"><a class="markdownIt-Anchor" href="#27-device"></a> 2.7 device/</h2><h3 id="271-mmioh"><a class="markdownIt-Anchor" href="#271-mmioh"></a> 2.7.1 mmio.h</h3><p>对内存映射 I/O 编址方式的支持。注意，内存映射 I/O 的读写并不是面向 CPU 的。</p><blockquote><p>端口映射I/O把端口号作为I/O指令的一部分, 这种方法很简单, 但同时也是它最大的缺点. 指令集为了兼容已经开发的程序, 是只能添加但不能修改的. 这意味着, 端口映射I/O所能访问的I/O地址空间的大小, 在设计I/O指令的那一刻就已经决定下来了. 所谓I/O地址空间, 其实就是所有能访问的设备的地址的集合. 随着设备越来越多, 功能也越来越复杂, I/O地址空间有限的端口映射I/O已经逐渐不能满足需求了. 有的设备需要让CPU访问一段较大的连续存储空间, 如VGA的显存, 24色加上Alpha通道的1024x768分辨率的显存就需要3MB的编址范围. 于是内存映射I/O(memory-mapped I/O)应运而生. 内存映射I/O这种编址方式非常巧妙, 它是通过不同的物理内存地址给设备编址的. 这种编址方式将一部分物理内存&quot;重定向&quot;到I/O地址空间中, CPU尝试访问这部分物理内存的时候, 实际上最终是访问了相应的I/O设备, CPU却浑然不知. 这样以后, CPU就可以通过普通的访存指令来访问设备. 这也是内存映射I/O得天独厚的好处: 物理内存的地址空间和CPU的位宽都会不断增长, 内存映射I/O从来不需要担心I/O地址空间耗尽的问题. 从原理上来说, 内存映射I/O唯一的缺点就是, CPU无法通过正常渠道直接访问那些被映射到I/O地址空间的物理内存了. 但随着计算机的发展, 内存映射I/O的唯一缺点已经越来越不明显了: 现代计算机都已经是64位计算机, 物理地址线都有48根, 这意味着物理地址空间有256TB这么大, 从里面划出3MB的地址空间给显存, 根本就是不痛不痒. 正因为如此, 内存映射I/O成为了现代计算机主流的I/O编址方式: RISC架构只提供内存映射I/O的编址方式, 而PCI-e, 网卡, x86的APIC等主流设备, 都支持通过内存映射I/O来访问.</p></blockquote><blockquote><p>在 NEMU 中， video memory是唯一使用内存映射 I/O 方式访问的 I/O 空间。</p></blockquote><p>定义了类型 <code>mmio_callback_t</code> ，设备定义的回调函数，用以更新设备状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*<span class="keyword">mmio_callback_t</span>)</span><span class="params">(<span class="keyword">paddr_t</span>, <span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>void* add_mmio_map(paddr_t, int, mmio_callback_t)</code></td><td style="text-align:left">注册一个内存映射 I/O 映射关系，返回该映射关系的 I/O 空间首地址</td></tr><tr><td style="text-align:left"><code>int is_mmio(paddr_t)</code></td><td style="text-align:left">判断一个物理地址是否被映射到 I/O 空间，如果是，返回映射号, 否则返回 -1</td></tr><tr><td style="text-align:left"><code>uint32_t mmio_read(paddr_t, int, int)</code></td><td style="text-align:left">根据端口号和地址读取</td></tr><tr><td style="text-align:left"><code>void mmio_write(paddr_t, int, uint32_t, int)</code></td><td style="text-align:left">根据端口号和地址写入</td></tr></tbody></table><h3 id="272-port-ioh"><a class="markdownIt-Anchor" href="#272-port-ioh"></a> 2.7.2 port-io.h</h3><p>对端口映射 I/O 编址方式的支持。端口映射I/O(port-mapped I/O)， CPU使用专门的I/O指令对设备进行访问， 并把设备的地址称作端口号。 有了端口号以后， 在I/O指令中给出端口号， 就知道要访问哪一个设备寄存器了。</p><p>定义了类型 <code>pio_callback_t</code> ，设备定义的回调函数，用以更新设备状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*<span class="keyword">pio_callback_t</span>)</span><span class="params">(<span class="keyword">ioaddr_t</span>, <span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>void* add_pio_map(paddr_t, int, mmio_callback_t)</code></td><td style="text-align:left">注册一个端口映射 I/O 映射关系，返回该映射关系的 I/O 空间首地址</td></tr><tr><td style="text-align:left"><code>uint32_t pio_read_[l,w,b](ioaddr_t)</code></td><td style="text-align:left">面向 CPU 的端口 I/O 读接口</td></tr><tr><td style="text-align:left"><code>void pio_write_[l,w,b](ioaddr_t, uint32_t)</code></td><td style="text-align:left">面向 CPU 的端口 I/O 写接口</td></tr></tbody></table><h2 id="28-monitor"><a class="markdownIt-Anchor" href="#28-monitor"></a> 2.8 monitor/</h2><p>监视器部分（也包含 NEMU 执行主循环）。</p><h3 id="281-exprh"><a class="markdownIt-Anchor" href="#281-exprh"></a> 2.8.1 expr.h</h3><p>定义了计算表达式的值的函数 <code>expr</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">expr</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">bool</span> *)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="282-monitorh"><a class="markdownIt-Anchor" href="#282-monitorh"></a> 2.8.2 monitor.h</h3><p>定义了 NEMU 状态 变量 <code>nemu_state</code>，和枚举值 <code>NEMU_STOP, NEMU_RUNNING, NEMU_END, NEMU_ABORT</code>。 定义了 应用程序入口点 <code>ENTRY_START</code> ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENTRY_START 0x100000</span></span><br></pre></td></tr></table></figure><h3 id="283-watchpointh"><a class="markdownIt-Anchor" href="#283-watchpointh"></a> 2.8.3 watchpoint.h</h3><h4 id="结构体-wp"><a class="markdownIt-Anchor" href="#结构体-wp"></a> 结构体 WP</h4><p>监视点结构。采用链表结构存储。</p><table><thead><tr><th style="text-align:left">成员</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>NO</code></td><td style="text-align:left">序号</td></tr><tr><td style="text-align:left"><code>next</code></td><td style="text-align:left">下一监视点指针</td></tr><tr><td style="text-align:left"><code>expr</code></td><td style="text-align:left">监视的表达式</td></tr><tr><td style="text-align:left"><code>lastVal</code></td><td style="text-align:left">表达式最近一次的值</td></tr></tbody></table><h2 id="29-util"><a class="markdownIt-Anchor" href="#29-util"></a> 2.9 util/</h2><h3 id="291-c_oph"><a class="markdownIt-Anchor" href="#291-c_oph"></a> 2.9.1 c_op.h</h3><p>定义了一些形如 <code>c_opname_type</code> 的宏，用于表示基础 C 运算。在 RTL基本指令中的寄存器运算指令中使用。</p><h1 id="3-src"><a class="markdownIt-Anchor" href="#3-src"></a> 3 src/</h1><h2 id="mainc"><a class="markdownIt-Anchor" href="#mainc"></a> main.c</h2><p>NEMU 主程序。</p><p>调用 <code>init_monitor</code> （实现在 <code>/src/monitor/monitor.c</code>）初始化监视器，并获取当前是否为批处理模式。 调用 <code>ui_mainloop</code> （实现在 <code>/src/monitor/debug/ui.c</code>）进行指令执行模拟。</p><h2 id="cpu"><a class="markdownIt-Anchor" href="#cpu"></a> cpu/</h2><h3 id="regc"><a class="markdownIt-Anchor" href="#regc"></a> reg.c</h3><p>实现了 <code>include/cpu/reg.h</code> 中的 <code>regsl,regsw,regsb</code>，同时实现寄存器实际定义：变量 <code>cpu</code>。</p><ul><li>函数 <code>reg_test</code>：测试寄存器结构定义（<code>CPU_state</code>）是否正确。</li></ul><h3 id="intrc"><a class="markdownIt-Anchor" href="#intrc"></a> intr.c</h3><p>函数 <code>void raise_intr(uint8_t NO, vaddr_t ret_addr)</code> 为 <code>int</code> 指令（在 <code>system.c</code> 中实现）的内部实现。 实现了触发中断或异常后的硬件处理：</p><ol><li>依次将EFLAGS, CS(代码段寄存器), EIP寄存器（返回地址）的值压入堆栈</li><li>根据中断码，从IDTR中读出IDT的首地址</li><li>根据异常号在IDT中进行索引, 找到一个门描述符</li><li>将门描述符中的offset域组合成目标地址</li><li>跳转到目标地址</li></ol><h3 id="decode"><a class="markdownIt-Anchor" href="#decode"></a> decode/</h3><p>指令译码相关。</p><h4 id="decodec"><a class="markdownIt-Anchor" href="#decodec"></a> decode.c</h4><p>实现了 <code>include/cpu/decode.h</code> 中的译码函数族，函数 <code>operand_write</code> 以及译码信息变量 <code>decoding</code>。 实现了 <code>include/cpu/rtl.h</code> 中的临时寄存器 <code>t0,t1,t2,t3,at</code> 和函数 <code>decoding_set_jmp</code>。</p><h5 id="宏-make_dophelper-与函数族-decode_op_name"><a class="markdownIt-Anchor" href="#宏-make_dophelper-与函数族-decode_op_name"></a> 宏 make_DopHelper 与函数族 decode_op_name</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> make_DopHelper(name) void concat(decode_op_, name) (vaddr_t *eip, Operand *op, bool load_val)</span></span><br></pre></td></tr></table></figure><p>译码函数会进一步分解成各种不同操作数的译码的组合，以实现操作数译码的解耦. 操作数译码函数统一通过宏 <code>make_DopHelper</code> 来定义 （<code>decode_op_rm</code> 除外）。 操作数译码函数会把操作数的信息记录在结构体 <code>op</code> 中, 如果操作数在指令中， 就会通过 <code>instr_fetch()</code> 将它们从 <code>eip</code> 所指向的内存位置取出. 为了使操作数译码函数更易于复用， 函数中的 <code>load_val</code> 参数会控制 是否需要将该操作数读出到全局译码信息 <code>decoding</code> 供后续使用. 例如如果一个内存操作数是源操作数, 就需要将这个操作数从内存中读出来供后续执行阶段来使用； 如果它仅仅是一个目的操作数， 就不需要从内存读出它的值了，因为执行这条指令并不需要这个值， 而是将新数据写入相应的内存位置.</p><p><code>decode_op_name</code> 函数族命名规则可参见 <code>decode_name</code> 函数族命名规则。</p><ul><li><code>decode_op_a</code> 是一个特例，其用于将操作数标记为寄存器 <code>ax</code> 或 <code>eax</code></li></ul><h4 id="modrmc"><a class="markdownIt-Anchor" href="#modrmc"></a> modrm.c</h4><p>实现了 <code>include/cpu/decode.h</code> 中的函数 <code>load_addr</code> 和 <code>read_ModR_M</code>。</p><h3 id="exec"><a class="markdownIt-Anchor" href="#exec"></a> exec/</h3><p>指令执行相关。</p><h4 id="ccc"><a class="markdownIt-Anchor" href="#ccc"></a> cc.c</h4><p>实现了 <code>include/cpu/cc.h</code> 中的函数 <code>rtl_setcc</code>。根据指定关系运算以及条件标志位设置 dest。</p><h4 id="relopc"><a class="markdownIt-Anchor" href="#relopc"></a> relop.c</h4><p>实现了 <code>include/cpu/relop.h</code> 中的函数 <code>interpret_relop</code>，使用 C语言关系运算符实现关系运算。</p><h4 id="all-instrh"><a class="markdownIt-Anchor" href="#all-instrh"></a> all-instr.h</h4><p>定义了已经实现的指令执行函数（在 <code>exec.c</code> 中使用）。</p><h4 id="arithc"><a class="markdownIt-Anchor" href="#arithc"></a> arith.c</h4><p>算术运算指令执行函数实现。</p><table><thead><tr><th style="text-align:left">指令</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>add</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>sub</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>cmp</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>inc</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>dec</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>neg</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>adc</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>sbb</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>mul</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>imul1</code></td><td style="text-align:left">imul 单操作数</td></tr><tr><td style="text-align:left"><code>imul2</code></td><td style="text-align:left">imul 双操作数</td></tr><tr><td style="text-align:left"><code>imul3</code></td><td style="text-align:left">imul 三操作数</td></tr><tr><td style="text-align:left"><code>div</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>idiv</code></td><td style="text-align:left"></td></tr></tbody></table><h4 id="controlc"><a class="markdownIt-Anchor" href="#controlc"></a> control.c</h4><p>控制指令执行函数实现。</p><table><thead><tr><th style="text-align:left">指令</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>jmp</code></td><td style="text-align:left">直接跳转</td></tr><tr><td style="text-align:left"><code>jmp_rm</code></td><td style="text-align:left">间接跳转</td></tr><tr><td style="text-align:left"><code>jcc</code></td><td style="text-align:left">条件跳转</td></tr><tr><td style="text-align:left"><code>call</code></td><td style="text-align:left">直接调用</td></tr><tr><td style="text-align:left"><code>call_rm</code></td><td style="text-align:left">间接调用</td></tr><tr><td style="text-align:left"><code>ret</code></td><td style="text-align:left"></td></tr></tbody></table><h4 id="data-movc"><a class="markdownIt-Anchor" href="#data-movc"></a> data-mov.c</h4><p>数据移动指令执行函数实现。</p><table><thead><tr><th style="text-align:left">指令</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>mov</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>movsx</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>movzx</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>lea</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>push</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>pop</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>pusha</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>popa</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>leave</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>cltd</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>cwtl</code></td><td style="text-align:left"></td></tr></tbody></table><h4 id="logicc"><a class="markdownIt-Anchor" href="#logicc"></a> logic.c</h4><p>逻辑运算指令执行函数实现。</p><table><thead><tr><th style="text-align:left">指令</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>test</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>and</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>xor</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>or</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>sar</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>shl</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>shr</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>setcc</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>not</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>rol</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>ror</code></td><td style="text-align:left"></td></tr></tbody></table><h4 id="specialc"><a class="markdownIt-Anchor" href="#specialc"></a> special.c</h4><p>特殊指令执行函数实现。</p><p>实现了 <code>include/cpu/rtl.h</code> 中的函数 <code>interpret_rtl_exit</code>。</p><table><thead><tr><th style="text-align:left">指令</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>nop</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>inv</code></td><td style="text-align:left">非法指令</td></tr><tr><td style="text-align:left"><code>nemu_trap</code></td><td style="text-align:left">结束执行</td></tr></tbody></table><h4 id="prefixc"><a class="markdownIt-Anchor" href="#prefixc"></a> prefix.c</h4><p>定义了执行函数 <code>exec_real</code>。 定义并实现了执行函数 <code>exec_operand_size</code>。</p><ul><li><code>exec_operand_size</code> 以 16 位操作数执行指令（标记 <code>decoding.is_operand_size_16</code>）</li></ul><h4 id="systemc"><a class="markdownIt-Anchor" href="#systemc"></a> system.c</h4><p>系统相关指令实现。</p><table><thead><tr><th style="text-align:left">指令</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>lidt</code></td><td style="text-align:left">设置 IDTR 寄存器</td></tr><tr><td style="text-align:left"><code>mov_r2cr</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>mov_cr2r</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>int</code></td><td style="text-align:left">根据中断码进行中断跳转</td></tr><tr><td style="text-align:left"><code>iret</code></td><td style="text-align:left">从中断跳转返回</td></tr><tr><td style="text-align:left"><code>in</code></td><td style="text-align:left">读取端口映射 I/O</td></tr><tr><td style="text-align:left"><code>out</code></td><td style="text-align:left">写入端口映射 I/O</td></tr></tbody></table><ul><li>x86 提供了 in 和 out 指令用于访问设备，其中 in 指令用于将设备寄存器中的数据传输到 CPU 寄存器中，out 指令用于将 CPU 寄存器中的数据传送到设备寄存器中</li></ul><h4 id="execc"><a class="markdownIt-Anchor" href="#execc"></a> exec.c</h4><p>指令执行过程核心实现。</p><h5 id="结构体-opcode_entry"><a class="markdownIt-Anchor" href="#结构体-opcode_entry"></a> 结构体 opcode_entry</h5><p>译码查找表中元素。</p><table><thead><tr><th style="text-align:left">成员</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>DHelper decode</code></td><td style="text-align:left">译码函数指针</td></tr><tr><td style="text-align:left"><code>EHelper execute</code></td><td style="text-align:left">执行函数指针</td></tr><tr><td style="text-align:left"><code>width</code></td><td style="text-align:left">指令宽度</td></tr></tbody></table><h5 id="数组-opcode_table"><a class="markdownIt-Anchor" href="#数组-opcode_table"></a> 数组 opcode_table</h5><p>译码表。按指令第一个字节索引存放。分两段：单字节指令码和双字节指令码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">opcode_entry opcode_table [<span class="number">512</span>] = &#123;</span><br><span class="line">  <span class="comment">/* 0x00 */</span>EMPTY, EMPTY, EMPTY, EMPTY,</span><br><span class="line">  <span class="comment">/* 0x04 */</span>EMPTY, EMPTY, EMPTY, EMPTY,</span><br><span class="line">  <span class="comment">/* 0x08 */</span>EMPTY, EMPTY, EMPTY, EMPTY,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">宏</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>IDEXW(id, ex, w)</code></td><td style="text-align:left">根据译码函数名，执行函数名，宽度生成 <code>opcode_entry</code></td></tr><tr><td style="text-align:left"><code>IDEX(id, ex)</code></td><td style="text-align:left">根据译码函数名，执行函数名，以宽度 0 生成 <code>opcode_entry</code></td></tr><tr><td style="text-align:left"><code>EXW(ex, w)</code></td><td style="text-align:left">根据执行函数名，宽度，生成无译码函数的 <code>opcode_entry</code></td></tr><tr><td style="text-align:left"><code>EX(ex)</code></td><td style="text-align:left">根据执行函数名，生成宽度为 0 且无译码函数的 <code>opcode_entry</code></td></tr><tr><td style="text-align:left"><code>EMPTY</code></td><td style="text-align:left">未实现的命令，使用 <code>exec_inv</code>（定义在 <code>special.c</code> 中） 构造 <code>opcode_entry</code></td></tr><tr><td style="text-align:left"><code>make_group(name, item0, item1, item2, item3, item4, item5, item6, item7)</code></td><td style="text-align:left">用于实现 <code>sub /5</code> 这种根据第二个指令码 <code>/5</code> 区分不同指令的情况。会自动生成一个 <code>exec_name</code> 的统一执行函数，并根据 <code>decoding.ext_opcode</code> 分配到指定执行函数。</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDEXW(id, ex, w)   &#123;concat(decode_, id), concat(exec_, ex), w&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDEX(id, ex)       IDEXW(id, ex, 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXW(ex, w)         &#123;NULL, concat(exec_, ex), w&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EX(ex)             EXW(ex, 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EMPTY              EX(inv)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> make_group(name, item0, item1, item2, item3, item4, item5, item6, item7) \</span></span><br><span class="line">  static opcode_entry concat(opcode_table_, name) [8] = &#123; \</span><br><span class="line">    <span class="comment">/* 0x00 */</span>item0, item1, item2, item3, \</span><br><span class="line">    <span class="comment">/* 0x04 */</span>item4, item5, item6, item7  \</span><br><span class="line">  &#125;; \</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">make_EHelper</span><span class="params">(name)</span> </span>&#123; \</span><br><span class="line">  idex(eip, &amp;concat(opcode_table_, name)[decoding.ext_opcode]); \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>make_group</code> 宏定义了一些组 <code>gp1</code> - <code>gp7</code>。对应于 80386 手册附录中组的划分。</p><h5 id="函数-exec_wrapper"><a class="markdownIt-Anchor" href="#函数-exec_wrapper"></a> 函数 exec_wrapper</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exec_wrapper</span><span class="params">(<span class="keyword">bool</span> print_flag)</span></span>;</span><br></pre></td></tr></table></figure><p>执行下一条指令。</p><ul><li>首先将当前的 <code>%eip</code> 保存到全局译码信息 <code>decoding</code> 的成员 <code>seq_eip</code> 中</li><li>然后将其地址被作为参数送进<code>exec_real()</code>函数中<ul><li><code>seq</code> 代表顺序的意思, 当代码从 <code>exec_real()</code> 返回时，<code>decoding.seq_eip</code> 将会指向下一条指令的地址.</li></ul></li><li>调用 <code>update_eip</code> 更新 <code>%eip</code></li><li>调试模式下<ul><li>记录日志（指令内容以及相关信息）</li><li>若 <code>print_flag</code> 为真，则显示 <code>decoding.asm_buf</code></li></ul></li></ul><h5 id="函数-exec_real"><a class="markdownIt-Anchor" href="#函数-exec_real"></a> 函数 exec_real</h5><ul><li>首先通过 <code>instr_fetch()</code> 函数(在 <code>include/cpu/exec.h</code> 中定义)进行取指， 得到指令的第一个字节, 将其解释成 <code>opcode</code> 并记录在全局译码信息 <code>decoding</code> 中.</li><li>根据 <code>opcode</code> 查阅译码查找表，得到操作数的宽度信息，并通过调用 <code>set_width()</code> 函数将其记录在全局译码信息 <code>decoding</code> 中</li><li>调用 <code>idex()</code> 对指令进行进一步的译码和执行</li></ul><h5 id="函数-set_width"><a class="markdownIt-Anchor" href="#函数-set_width"></a> 函数 set_width</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_width</span><span class="params">(<span class="keyword">int</span> <span class="built_in">width</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>根据指令定义宽度（<code>opcode_entry.width</code>）指定所有操作数宽度（<code>decoding.src.width</code>）。</p><ul><li>如果定义宽度为 0，则采用译码结果（<code>decoding.is_operand_size_16</code>）</li></ul><h5 id="函数-idex"><a class="markdownIt-Anchor" href="#函数-idex"></a> 函数 idex</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Instruction Decode and EXecute */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">idex</span><span class="params">(<span class="keyword">vaddr_t</span> *eip, opcode_entry *e)</span></span>;</span><br></pre></td></tr></table></figure><p>调用译码查找表中的相应的译码函数（若存在）进行操作数的译码，译码过程结束之后, 会调用译码查找表中的相应的执行函数来进行真正的执行操作。</p><h5 id="函数-update_eip"><a class="markdownIt-Anchor" href="#函数-update_eip"></a> 函数 update_eip</h5><p>根据当前指令是否为跳转指令，更新 <code>%eip</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update_eip</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (decoding.is_jmp) &#123; decoding.is_jmp = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; cpu.eip = decoding.seq_eip; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="memory"><a class="markdownIt-Anchor" href="#memory"></a> memory/</h2><h3 id="memoryc"><a class="markdownIt-Anchor" href="#memoryc"></a> memory.c</h3><p>定义了宏 <code>PMEM_SIZE</code> 指定物理内存大小。 实现了 <code>include/memory/memory.h</code> 中的函数 <code>paddr_read</code>，<code>paddr_write</code>，<code>vaddr_read</code>，<code>vaddr_write</code>。</p><ul><li><code>vaddr_read, vaddr_write</code> 的实现调用了 <code>paddr_read</code> 和 <code>paddr_write</code>。</li><li>为支持内存映射 I/O，<code>paddr_read, paddr_write</code> 的实现加入了对内存映射 I/O 的判断。</li></ul><h2 id="device"><a class="markdownIt-Anchor" href="#device"></a> device/</h2><h3 id="io"><a class="markdownIt-Anchor" href="#io"></a> io/</h3><h4 id="mmioc"><a class="markdownIt-Anchor" href="#mmioc"></a> mmio.c</h4><p>定义了宏 <code>MMIO_SPACE_MAX</code> 指定内存映射空间大小。 定义了结构体 <code>MMIO_t</code> 保存 MMIO 信息。</p><p>实现了 <code>include/device/mmio.h</code> 中的函数。</p><ul><li>在 <code>mmio_read</code> 和 <code>mmio_write</code> 中，调用了回调函数。</li></ul><h4 id="port-ioc"><a class="markdownIt-Anchor" href="#port-ioc"></a> port-io.c</h4><p>定义了宏 <code>PORT_IO_SPACE_MAX</code> 指定内存映射空间大小。 定义了结构体 <code>PIO_t</code> 保存 MMIO 信息。</p><p>实现了 <code>include/device/port-io.h</code> 中的函数。</p><ul><li>在 <code>pio_read_common</code> 和 <code>pio_write_common</code> 中，调用了回调函数。</li><li>基于 <code>pio_read_common</code> 和 <code>pio_write_common</code> 实现了不同的端口读写函数</li></ul><h3 id="devicec"><a class="markdownIt-Anchor" href="#devicec"></a> device.c</h3><p>提供初始化和控制设备的一些函数。含有和SDL库相关的代码，NEMU使用SDL库来实现设备的模拟。</p><table><thead><tr><th style="text-align:left">宏</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>TIMER_HZ</code></td><td style="text-align:left">时钟频率</td></tr><tr><td style="text-align:left"><code>VGA_HZ</code></td><td style="text-align:left">VGA 刷新频率</td></tr></tbody></table><h4 id="函数-init_device"><a class="markdownIt-Anchor" href="#函数-init_device"></a> 函数 init_device</h4><p>用于初始化设备：串口， 时钟， 键盘， VGA四种设备。 其中在初始化 VGA 时还会进行一些和SDL相关的初始化工作， 包括创建窗口， 设置显示模式等. 最后还会注册一个100Hz的定时器， 每隔0.01秒就会调用一次 <code>device_update()</code> 函数。</p><h4 id="函数-device_update"><a class="markdownIt-Anchor" href="#函数-device_update"></a> 函数 device_update</h4><p>主要进行一些设备的模拟操作, 包括以50Hz的频率刷新屏幕, 以及检测是否有按键按下/释放.</p><p>需要说明的是， 代码中注册的定时器是虚拟定时器， 它只会在 NEMU 处于用户态的时候进行计时： 如果 NEMU 在 <code>ui_mainloop()</code> 中等待用户输入， 定时器将不会计时; 如果 NEMU 进行大量的输出， 定时器的计时将会变得缓慢. 因此除非你在进行调试， 否则尽量避免大量输出的情况， 从而影响定时器的工作。</p><h3 id="serialc"><a class="markdownIt-Anchor" href="#serialc"></a> serial.c</h3><p>串口设备。 模拟了串口的功能。 其大部分功能也被简化，只保留了数据寄存器和状态寄存器。串口初始化时会分别注册 <code>0x3F8</code> 和 <code>0x3FC</code> 处长度为1个字节的端口，分别作为数据寄存器和状态寄存器。由于NEMU串行模拟计算机系统的工作，串口的状态寄存器可以一直处于空闲状态; 每当CPU往数据寄存器中写入数据时，串口会将数据传送到主机的标准输出。</p><table><thead><tr><th style="text-align:left">函数/宏</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>init_serial()</code></td><td style="text-align:left">初始化设备</td></tr><tr><td style="text-align:left"><code>SERIAL_PORT=0x3F8</code></td><td style="text-align:left">端口 I/O 地址</td></tr></tbody></table><h3 id="timerc"><a class="markdownIt-Anchor" href="#timerc"></a> timer.c</h3><p>时钟设备。 模拟了i8253计时器的功能. 计时器的大部分功能都被简化, 只保留了&quot;发起时钟中断&quot;的功能. 同时添加了一个自定义的RTC(Real Time Clock), 初始化时将会注册0x48处的端口作为RTC寄存器, CPU可以通过I/O指令访问这一寄存器, 获得当前时间(单位是ms).</p><table><thead><tr><th style="text-align:left">函数/宏</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>init_timer()</code></td><td style="text-align:left">初始化设备</td></tr><tr><td style="text-align:left"><code>RTC_PORT=0x48</code></td><td style="text-align:left">端口 I/O 地址</td></tr></tbody></table><h3 id="keyboardc"><a class="markdownIt-Anchor" href="#keyboardc"></a> keyboard.c</h3><p>键盘设备。 模拟了i8042通用设备接口芯片的功能. 其大部分功能也被简化, 只保留了键盘接口. i8042初始化时会注册 <code>0x60</code> 处的端口（长度为 4）作为数据寄存器. 每当用户敲下/释放按键时, 将会把相应的键盘码放入数据寄存器, CPU可以通过端口I/O访问数据寄存器, 获得键盘码; 当无按键可获取时, 将会返回 <code>_KEY_NONE</code> . 在AM中, 我们约定通码的值为 <code>断码 | KEYDOWN_MASK</code>.</p><table><thead><tr><th style="text-align:left">函数/宏</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>init_i8042()</code></td><td style="text-align:left">初始化设备</td></tr><tr><td style="text-align:left"><code>I8042_DATA_PORT=0x60</code></td><td style="text-align:left">端口 I/O 地址</td></tr><tr><td style="text-align:left"><code>KEYDOWN_MASK=0x8000</code></td><td style="text-align:left">通码 MASK</td></tr><tr><td style="text-align:left"><code>KEY_QUEUE_LEN</code></td><td style="text-align:left">键队列长度</td></tr></tbody></table><h3 id="vgac"><a class="markdownIt-Anchor" href="#vgac"></a> vga.c</h3><p>VGA 设备。 模拟了VGA的功能. VGA初始化时注册了从 <code>0x40000</code> 开始的一段用于映射到video memory的物理内存. 在NEMU中, video memory是唯一使用内存映射I/O方式访问的I/O空间. 代码只模拟了400x300x32的图形模式, 一个像素占32个bit的存储空间, R(red), G(green), B(blue), A(alpha)各占8 bit, 其中VGA不使用alpha的信息。VGA 设备同时注册了位于 <code>0x100</code> 的长度为 4 的端口存储屏幕大小信息。</p><table><thead><tr><th style="text-align:left">函数/宏</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>init_vga()</code></td><td style="text-align:left">初始化设备</td></tr><tr><td style="text-align:left"><code>SCREEN_PORT=0x100</code></td><td style="text-align:left">端口 I/O 地址</td></tr><tr><td style="text-align:left"><code>VMEM=0x40000</code></td><td style="text-align:left">内存映射 I/O 地址</td></tr><tr><td style="text-align:left"><code>SCREEN_H</code></td><td style="text-align:left">屏幕高度</td></tr><tr><td style="text-align:left"><code>SCREEN_W</code></td><td style="text-align:left">屏幕宽度</td></tr></tbody></table><h2 id="monitor"><a class="markdownIt-Anchor" href="#monitor"></a> monitor/</h2><p>监视器部分实现（也包含 NEMU 执行主循环）。</p><h3 id="monitorc"><a class="markdownIt-Anchor" href="#monitorc"></a> monitor.c</h3><h4 id="函数-init_monitor"><a class="markdownIt-Anchor" href="#函数-init_monitor"></a> 函数 init_monitor</h4><p>初始化监视器并启动（用于 <code>main.c/main</code> 中）。</p><ul><li>解析并处理命令行参数</li><li>初始化日志文件</li><li>寄存器测试（调用 <code>reg_test()</code>，实现在 <code>src/cpu/reg.c</code>）</li><li>加载程序镜像（根据命令行参数，如果为空，则调用 <code>load_default_img()</code> 加载默认镜像）</li><li>启动环境（调用 <code>restart()</code>，初始化应用程序入口点，寄存器值）</li><li>编译正则表达式（调用 <code>init_regex()</code>，实现在 <code>src/monitor/debug/expr.c</code>）</li><li>初始化监视点池（调用 <code>init_wp_pool()</code>，实现在 <code>src/monitor/debug/watchpoint.c</code>）</li><li>初始化设备（调用 <code>init_device()</code>，实现在 <code>src/device/device.c</code>）</li><li>初始化差异测试（调用 <code>init_difftest()</code>，实现在 <code>src/monitor/diff-test.c</code>）</li><li>显示欢迎界面</li><li>返回是否为批处理模式（根据命令行参数）</li></ul><p>注：</p><ul><li>命令行参数<ul><li><code>[img_file]</code> 指定应用程序镜像文件</li><li><code>-b</code> 批处理模式</li><li><code>-l log_file</code> 指定日志文件</li><li><code>-d</code> 指定 Diff-Test 镜像文件</li></ul></li></ul><h3 id="cpu-execc"><a class="markdownIt-Anchor" href="#cpu-execc"></a> cpu-exec.c</h3><h4 id="函数-cpu_exec"><a class="markdownIt-Anchor" href="#函数-cpu_exec"></a> 函数 cpu_exec</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpu_exec</span><span class="params">(<span class="keyword">uint64_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>模拟 CPU 工作。</p><ul><li>判断 NEMU 状态（查看 <code>nemu_state</code>，定义在 <code>include/monitor/monitor.h</code>）</li><li>若指令数 <code>n</code> 小于 <code>MAX_INSTR_TO_PRINT</code> （默认为 10），则打印每条指令。</li><li>开始执行指令<ul><li>调用 <code>exec_wrapper</code> 执行下一条指令（传入是否打印指令标记）</li><li>检查监视点状态是否有更新</li><li>更新设备信息</li><li>判断 NEMU 状态（查看 <code>nemu_state</code>），决定是否退出</li></ul></li><li>执行完 <code>n</code> 条指令后，将 NEMU 状态置为结束（<code>NEMU_END</code>）</li></ul><p>注：</p><ul><li>执行某条命令后<ul><li>若 NEMU 状态为结束（<code>NEMU_END</code>），则检查程序返回值（<code>cpu.eax</code>）是否为 0（是否正常退出）。并输出 <code>HIT GOOD TRAP</code>（正常退出） 或 <code>HIT BAD TRAP</code>（非正常退出）。</li></ul></li></ul><h3 id="debug"><a class="markdownIt-Anchor" href="#debug"></a> debug/</h3><h4 id="watchpointc"><a class="markdownIt-Anchor" href="#watchpointc"></a> watchpoint.c</h4><p>定义了监视点内存池及其相关的函数。</p><ul><li><code>wp_pool</code> 监视点池</li><li><code>head</code> 使用中的监视点链表头指针</li><li><code>free_</code> 监视点池中未使用的监视点链表头指针</li></ul><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>init_wp_pool()</code></td><td style="text-align:left">初始化监视点内存池</td></tr><tr><td style="text-align:left"><code>clearWP(wp)</code></td><td style="text-align:left">清空某监视点的下一项指针</td></tr><tr><td style="text-align:left"><code>WP *getHeadWP()</code></td><td style="text-align:left">获取 <code>head</code></td></tr><tr><td style="text-align:left"><code>WP *createWP()</code></td><td style="text-align:left">申请使用一个新监视点（内部调用 <code>new_wp()</code> 并更新链表信息）</td></tr><tr><td style="text-align:left"><code>removeWP(no)</code></td><td style="text-align:left">删除指定编号的监视点</td></tr><tr><td style="text-align:left"><code>WP *new_wp()</code></td><td style="text-align:left">（私有）从内存池中获取下一个能使用的监视点，并作一定预处理</td></tr><tr><td style="text-align:left"><code>free_wp(wp)</code></td><td style="text-align:left">（私有）释放一个监视点</td></tr></tbody></table><h4 id="exprc"><a class="markdownIt-Anchor" href="#exprc"></a> expr.c</h4><p>实现了 <code>expr.h/expr</code> 函数，实现表达式解析和求值。</p><h5 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h5><ul><li><code>PRI_NEG</code> 取负运算优先级</li><li><code>PRI_POINT</code> 解引用运算优先级</li><li>形如 <code>TK_TYPE</code> 的 Token 类型枚举</li></ul><h5 id="数组-rules"><a class="markdownIt-Anchor" href="#数组-rules"></a> 数组 rules</h5><p>规定了使用正则表达式解析 Token 的规则。</p><table><thead><tr><th style="text-align:left">成员</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>regex</code></td><td style="text-align:left">正则表达式字符串</td></tr><tr><td style="text-align:left"><code>token_type</code></td><td style="text-align:left">对应 Token 类型，可用 <code>TK_TYPE</code> 枚举或字符（如 <code>+</code>）表示</td></tr><tr><td style="text-align:left"><code>opPri</code></td><td style="text-align:left">运算符 Token 的优先级</td></tr></tbody></table><h5 id="数组-re"><a class="markdownIt-Anchor" href="#数组-re"></a> 数组 re</h5><p>根据 <code>rules</code> 编译后的正则表达式。</p><h5 id="函数-init_regex"><a class="markdownIt-Anchor" href="#函数-init_regex"></a> 函数 <code>init_regex</code></h5><p>根据 <code>rules</code> 编译到 <code>re</code></p><h5 id="结构体-token"><a class="markdownIt-Anchor" href="#结构体-token"></a> 结构体 Token</h5><p>识别后的 Token.</p><table><thead><tr><th style="text-align:left">成员</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>type</code></td><td style="text-align:left">Token 类型，可用 <code>TK_TYPE</code> 枚举或字符（如 <code>+</code>）表示</td></tr><tr><td style="text-align:left"><code>isOp</code></td><td style="text-align:left">标记此 Token 是否是运算符</td></tr><tr><td style="text-align:left"><code>isValue</code></td><td style="text-align:left">标记此 Token 是否是值</td></tr><tr><td style="text-align:left"><code>str</code></td><td style="text-align:left">Token 的原始字符串</td></tr><tr><td style="text-align:left"><code>data</code></td><td style="text-align:left">值类型的实际数据</td></tr><tr><td style="text-align:left"><code>priority</code></td><td style="text-align:left">运算符的优先级</td></tr></tbody></table><ul><li><code>isOp</code> 和 <code>isValue</code> 多用于区分特殊单目运算符，如解引用和取负</li><li><code>data</code> 多存储经过预处理的数据，如转换后的整数</li></ul><blockquote><p>解析后的 Token 列表存储在数组 <code>tokens</code> 中。 <code>nr_token</code> 指示 <code>token</code> 有效长度。</p></blockquote><h5 id="函数-make_token"><a class="markdownIt-Anchor" href="#函数-make_token"></a> 函数 make_token</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">make_token</span><span class="params">(<span class="keyword">char</span> *e)</span></span></span><br></pre></td></tr></table></figure><p>根据字符串解析 Token 列表，返回是否解析成功。</p><p>实现思路：使用 <code>re</code> 依次尝试每一种匹配，直到遇到第一个成功匹配，根据其规则的 <code>token_type</code> 生成 Token，存入 <code>token</code>。</p><ul><li>函数 <code>toInteger</code> ：以指定进制完成字符串到数的转换，用于 十进制，二进制，八进制，十六进制 数的解析。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span> <span class="title">toInteger</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">uint32_t</span> base)</span></span></span><br></pre></td></tr></table></figure><h5 id="函数-evalwithtoken"><a class="markdownIt-Anchor" href="#函数-evalwithtoken"></a> 函数 evalWithToken</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">evalWithToken</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">bool</span> * success)</span></span></span><br></pre></td></tr></table></figure><p>求解 <code>tokens[l..r]</code> 中的表达式的值。</p><p>实现思路：单 Token 特殊处理，然后处理外围括号情况，然后确定最后计算的运算符，分割成 <code>left</code> 和 <code>right</code> 两部分，然后递归解决，最后合并，</p><ul><li>函数 <code>checkExtraP</code> 判断 <code>tokens[l..r]</code> 是否外围为括号且括号匹配正常。</li><li>函数 <code>getReg</code> 根据寄存器名获取寄存器值，使用了 <code>regMap</code></li><li>数组 <code>regMap</code> 标识寄存器名与对应的偏移量（<code>cpu.gpr</code>）</li></ul><h5 id="函数-expr"><a class="markdownIt-Anchor" href="#函数-expr"></a> 函数 expr</h5><p>对 <code>expr.h/expr</code> 的实现，调用了 <code>make_token</code> 和 <code>evalWithToken</code>。</p><h4 id="uic"><a class="markdownIt-Anchor" href="#uic"></a> ui.c</h4><p>监视器 CUI 部分。</p><h5 id="函数族-fc2color"><a class="markdownIt-Anchor" href="#函数族-fc2color"></a> 函数族 fc2color</h5><p>控制台字体颜色控制。</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>fc2red</code></td><td style="text-align:left">前景色设为红色</td></tr><tr><td style="text-align:left"><code>fc2green</code></td><td style="text-align:left">前景色设为绿色</td></tr><tr><td style="text-align:left"><code>fc2yellow</code></td><td style="text-align:left">前景色设为黄色</td></tr><tr><td style="text-align:left"><code>fc2blue</code></td><td style="text-align:left">前景色设为蓝色</td></tr><tr><td style="text-align:left"><code>fc2purple</code></td><td style="text-align:left">前景色设为紫色</td></tr><tr><td style="text-align:left"><code>csClear</code></td><td style="text-align:left">清除所有控制台设置</td></tr></tbody></table><h5 id="函数族-cmd_item"><a class="markdownIt-Anchor" href="#函数族-cmd_item"></a> 函数族 cmd_item</h5><p>不同命令的实现。</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>cmd_help</code></td><td style="text-align:left">获取帮助</td></tr><tr><td style="text-align:left"><code>cmd_q</code></td><td style="text-align:left">退出</td></tr><tr><td style="text-align:left"><code>cmd_c</code></td><td style="text-align:left">继续执行（调用 <code>cpu_exec(-1)</code>，实现在 <code>src/monitor/cpu-exec.c</code>）</td></tr><tr><td style="text-align:left"><code>cmd_si</code></td><td style="text-align:left">执行单步指令</td></tr><tr><td style="text-align:left"><code>cmd_info name</code></td><td style="text-align:left">查看信息</td></tr><tr><td style="text-align:left"><code>cmd_x N expr</code></td><td style="text-align:left">显示地址从 <code>expr</code> 的值开始的 <code>N</code> 个字节值</td></tr><tr><td style="text-align:left"><code>cmd_p expr</code></td><td style="text-align:left">计算表达式的值</td></tr><tr><td style="text-align:left"><code>cmd_w expr</code></td><td style="text-align:left">新建监视点，监视表达式为 <code>expr</code></td></tr><tr><td style="text-align:left"><code>cmd_d no</code></td><td style="text-align:left">删除指定编号的监视点</td></tr></tbody></table><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd_info</span><br></pre></td></tr></table></figure><ul><li><code>r</code> 打印所有寄存器信息</li><li><code>w</code> 打印所有监视点信息</li></ul></li></ul><h5 id="数组-cmd_table"><a class="markdownIt-Anchor" href="#数组-cmd_table"></a> 数组 cmd_table</h5><table><thead><tr><th style="text-align:left">成员</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>name</code></td><td style="text-align:left">命令名（用于识别命令）</td></tr><tr><td style="text-align:left"><code>description</code></td><td style="text-align:left">命令描述（用于帮助列表）</td></tr><tr><td style="text-align:left"><code>handler</code></td><td style="text-align:left">命令实现函数指针</td></tr></tbody></table><h5 id="函数-ui_mainloop"><a class="markdownIt-Anchor" href="#函数-ui_mainloop"></a> 函数 ui_mainloop</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ui_mainloop</span><span class="params">(<span class="keyword">int</span> is_batch_mode)</span></span>;</span><br></pre></td></tr></table></figure><p>NEMU 以及其 CUI 主循环，不断读取命令，并执行。</p><ul><li>如果是批处理模式（<code>is_batch_mode</code> 为真），则直接执行应用程序，不监听用户命令。</li></ul><h3 id="diff-test"><a class="markdownIt-Anchor" href="#diff-test"></a> diff-test/</h3><p>差异测试实现。</p><blockquote><p>如果有一种方法能够表达指令的正确行为, 我们就可以基于这种方法来进行类似assert()的检查了。那么, 究竟什么地方表达了指令的正确行为呢? 最直接的, 当然就是i386手册了, 但是我们恰恰就是根据i386手册中的指令行为来在NEMU中实现指令的, 同一套方法不能既用于实现也用于检查. 如果有一个i386手册的参考实现就好了. 嘿! 我们用的真机不就是根据i386手册实现出来的吗? 我们让在NEMU中执行的每条指令也在真机中执行一次, 然后对比NEMU和真机的状态, 如果NEMU和真机的状态不一致, 我们就捕捉到error了! 这实际上是一种非常奏效的测试方法, 在软件测试领域称为differential testing(后续简称DiffTest). 我们刚才提到了&quot;状态&quot;, 那&quot;状态&quot;具体指的是什么呢? 我们在PA1中已经认识到, 计算机就是一个数字电路. 那么, “计算机的状态&quot;就恰恰是那些时序逻辑部件的状态, 也就是寄存器和内存的值. 其实仔细思考一下, 计算机执行指令, 就是修改这些时序逻辑部件的状态的过程. 要检查指令的实现是否正确, 只要检查这些时序逻辑部件中的值是否一致就可以了! DiffTest可以非常及时地捕捉到error, 第一次发现NEMU的寄存器或内存的值与真机不一样的时候, 就是因为当时执行的指令实现有误导致的. 这时候其实离error非常接近, 防止了error进一步传播的同时, 要回溯找到fault也容易得多. 多么美妙的功能啊! 背后还蕴含着计算机本质的深刻原理! 但很遗憾, 不要忘记了, 真机上是运行了操作系统GNU/Linux的, 而NEMU中的测试程序是运行在x86-nemu上的, 我们无法在native中运行编译到x86-nemu的AM程序. 所以, 我们需要的不仅是一个i386手册的正确实现, 而且需要在上面能正确运行x86-nemu的AM程序. 事实上, QEMU就是一个不错的参考实现. 它是一个虚拟出来的完整的x86计算机系统, 而NEMU的目标只是虚拟出x86的一个子集, 能在NEMU上运行的程序, 自然也能在QEMU上运行. 因此, 为了通过DiffTest的方法测试NEMU实现的正确性, 我们让NEMU和QEMU逐条指令地执行同一个客户程序. 双方每执行完一条指令, 就检查各自的寄存器和内存的状态, 如果发现状态不一致, 就马上报告错误, 停止客户程序的执行.</p></blockquote><h4 id="diff-testh"><a class="markdownIt-Anchor" href="#diff-testh"></a> diff-test.h</h4><p>定义了宏 <code>DIFFTEST_REG_SIZE</code> 规定访问的寄存器大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DIFFTEST_REG_SIZE (sizeof(uint32_t) * 9) <span class="comment">// GRPs + EIP</span></span></span><br></pre></td></tr></table></figure><h4 id="refc"><a class="markdownIt-Anchor" href="#refc"></a> ref.c</h4><p>在 DUT(Design Under Test, 测试对象)和 REF(Reference, 参考实现) 之间定义了一组 API。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从DUT host memory的 src 处拷贝 n 字节到REF guest memory的 dest 处</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">difftest_memcpy_from_dut</span><span class="params">(<span class="keyword">paddr_t</span> dest, <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 获取REF的寄存器状态到 r </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">difftest_getregs</span><span class="params">(<span class="keyword">void</span> *r)</span></span>;</span><br><span class="line"><span class="comment">// 设置REF的寄存器状态为 r </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">difftest_setregs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *r)</span></span>;</span><br><span class="line"><span class="comment">// 让REF执行 n 条指令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">difftest_exec</span><span class="params">(<span class="keyword">uint64_t</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 初始化REF的DiffTest功能</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">difftest_init</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>其中寄存器状态 <code>r</code> 要求寄存器的值按照某种顺序排列，若未按要求顺序排列， <code>difftest_getregs()</code> 和 <code>difftest_setregs()</code> 的行为是未定义的. REF 需要实现这些 API，DUT会使用这些 API 来进行 DiffTest 。</li></ul><h4 id="diff-testc"><a class="markdownIt-Anchor" href="#diff-testc"></a> diff-test.c</h4><p>定义了变量 <code>is_skip_ref</code>，<code>is_skip_dut</code> 用于标记忽视一些指令处的比对。（可结合 <code>difftest_step</code> 实现） 定义了函数 <code>difftest_skip_ref</code>，<code>difftest_skip_dut</code> 标记上述变量。</p><h5 id="函数-init_difftest"><a class="markdownIt-Anchor" href="#函数-init_difftest"></a> 函数 init_difftest</h5><p>初始化 Diff-Test。</p><ul><li>打开动态库文件 <code>ref_so_file</code></li><li>从动态库中分别读取上述 API 的符号</li><li>对 REF 的 DIffTest功能进行初始化，此时会启动 REF，代码还会对 REF 的状态进行一些初始化工作，REF 运行在后台，因此将看不到 REF 的任何输出</li><li>将 DUT 的 guest memory 拷贝到 REF 中</li><li>将 DUT 的寄存器状态拷贝到 REF 中</li></ul><h5 id="函数-difftest_step"><a class="markdownIt-Anchor" href="#函数-difftest_step"></a> 函数 difftest_step</h5><p>用于逐条指令执行后的状态对比。它会在 <code>exec_wrapper()</code> 的最后被调用。在这里读取 REF 的寄存器并与 NEMU 寄存器状态比对。</p><h2 id="misc"><a class="markdownIt-Anchor" href="#misc"></a> misc/</h2><h3 id="logoc"><a class="markdownIt-Anchor" href="#logoc"></a> logo.c</h3><p>定义了字符数组 <code>logo</code> 存储 i386 Manual Logo。用于 <code>inv</code> 指令（位于 <code>special.c</code> 中）。</p><h1 id="4-tools"><a class="markdownIt-Anchor" href="#4-tools"></a> 4 tools/</h1><h2 id="gen-exprc"><a class="markdownIt-Anchor" href="#gen-exprc"></a> gen-expr.c</h2><p>生成 C 表达式，用于测试表达式求值功能。</p><h2 id="qemu-diff"><a class="markdownIt-Anchor" href="#qemu-diff"></a> qemu-diff</h2><p>QEMU 实现，用于 Diff-Test。编译成动态库 <code>qemu-so</code>，传入 nemu 的 <code>-d</code> 参数中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计组" scheme="https://Dragonliu2022.github.io/categories/计组/"/>
    
    
  </entry>
  
  <entry>
    <title>PA答疑之IDEX和IDEXW</title>
    <link href="https://dragonliu2022.github.io/2022/04/23/PA%E7%AD%94%E7%96%91%E4%B9%8BIDEX%E5%92%8CIDEXW/"/>
    <id>https://dragonliu2022.github.io/2022/04/23/PA%E7%AD%94%E7%96%91%E4%B9%8BIDEX%E5%92%8CIDEXW/</id>
    <published>2022-04-23T06:43:37.000Z</published>
    <updated>2022-04-23T08:23:06.932Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-问题"><a class="markdownIt-Anchor" href="#1-问题"></a> 1 问题</h1><p><code>IDEX</code>其实就是相当于<code>IDEXW(,,0)</code>？可是最后一个参数不是操作数宽度吗？为什么会有0呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDEXW(id, ex, w)   &#123;concat(decode_, id), concat(exec_, ex), w&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDEX(id, ex)       IDEXW(id, ex, 0)</span></span><br></pre></td></tr></table></figure><p>学妹的问题我不会🥦，于是请舍友帮忙解答，记录下。</p><h1 id="2-指令的执行周期"><a class="markdownIt-Anchor" href="#2-指令的执行周期"></a> 2 指令的执行周期</h1><h2 id="21-取指instruction-fetch-if"><a class="markdownIt-Anchor" href="#21-取指instruction-fetch-if"></a> 2.1 取指(instruction fetch, IF)</h2><p>取指令要做的事情自然就是将 <code>eip</code> 指向的指令从内存读入到CPU中。</p><h2 id="22-译码instruction-decode-id"><a class="markdownIt-Anchor" href="#22-译码instruction-decode-id"></a> 2.2 译码(instruction decode, ID)</h2><p>CPU拿到一条指令之后，可以通过查表的方式得知这条指令的操作数和操作码。这个过程叫译码。</p><p>计算机现在已经有存储器和寄存器了，它们都可以存放操作数，指令中也可以存放立即数，也可能还有二次译码的处理。</p><h2 id="23-执行execute-ex"><a class="markdownIt-Anchor" href="#23-执行execute-ex"></a> 2.3 执行(execute, EX)</h2><p>执行阶段就是真正完成指令的工作。现在 TRM 只有加法器这一个执行部件，必要的时候,，只需要往加法器输入两个源操作数, 就能得到执行的结果了。之后还要把结果写回到目的操作数中, 可能是寄存器, 也可能是内存。</p><h2 id="24-更新-eip"><a class="markdownIt-Anchor" href="#24-更新-eip"></a> 2.4 更新 <code>eip</code></h2><p>执行完一条指令之后，CPU就要执行下一条指令。在这之前，CPU 需要更新 <code>eip</code> 的值，让 <code>eip</code> 加上刚才执行完的指令的长度, 即可指向下一条指令的位置。</p><h1 id="3-一条指令在nemu中的执行过程"><a class="markdownIt-Anchor" href="#3-一条指令在nemu中的执行过程"></a> 3 一条指令在NEMU中的执行过程</h1><h2 id="31-idex与idexw"><a class="markdownIt-Anchor" href="#31-idex与idexw"></a> 3.1 IDEX与IDEXW</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  DHelper decode;</span><br><span class="line">  EHelper execute;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span>;</span><br><span class="line">&#125; opcode_entry;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDEXW(id, ex, w)   &#123;concat(decode_, id), concat(exec_, ex), w&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDEX(id, ex)       IDEXW(id, ex, 0)</span></span><br><span class="line"></span><br><span class="line">opcode_entry opcode_table [<span class="number">512</span>] = &#123;</span><br><span class="line">  <span class="comment">/* 0x00 */</span>IDEXW(G2E, add, <span class="number">1</span>), IDEX(G2E, add), IDEXW(E2G, add, <span class="number">1</span>), IDEX(E2G, add),</span><br><span class="line">  <span class="comment">/* 0x04 */</span>IDEXW(I2a, add, <span class="number">1</span>), IDEX(I2a, add), EMPTY, EMPTY,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IDEXW</code>中的<code>w</code>也就是结构体<code>opcode_entry</code>中的<code>width</code>。</p><h2 id="32-过程"><a class="markdownIt-Anchor" href="#32-过程"></a> 3.2 过程</h2><h3 id="321-mainc"><a class="markdownIt-Anchor" href="#321-mainc"></a> 3.2.1 main.c</h3><p>nemu运行起来，主函数 <code>nemu/src/main.c</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* Initialize the monitor. */</span></span><br><span class="line">  <span class="keyword">int</span> is_batch_mode = init_monitor(argc, argv);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Receive commands from user. */</span></span><br><span class="line">  ui_mainloop(is_batch_mode);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="322-ui_mainloop"><a class="markdownIt-Anchor" href="#322-ui_mainloop"></a> 3.2.2 ui_mainloop()</h3><p>执行<code>ui_mainloop</code>函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ui_mainloop</span><span class="params">(<span class="keyword">int</span> is_batch_mode)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (is_batch_mode) &#123; <span class="comment">//批处理</span></span><br><span class="line">    cmd_c(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 处理传来的字符串</span></span><br><span class="line">  ...</span><br><span class="line">    <span class="comment">// 执行指令</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_CMD; i ++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cmd, cmd_table[i].name) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmd_table[i].handler(args) &lt; <span class="number">0</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == NR_CMD) &#123; <span class="built_in">printf</span>(<span class="string">"Unknown command '%s'\n"</span>, cmd); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="323-cmd_c"><a class="markdownIt-Anchor" href="#323-cmd_c"></a> 3.2.3 cmd_c()</h3><p>例如在nemu下执行<code>c</code>命令（继续运行被暂停的程序至结束）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cmd_c</span><span class="params">(<span class="keyword">char</span> *args)</span> </span>&#123;</span><br><span class="line">  cpu_exec(<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="324-cpu_exec"><a class="markdownIt-Anchor" href="#324-cpu_exec"></a> 3.2.4 cpu_exec()</h3><p>然后调用cpu_exec函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Simulate how the CPU works. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpu_exec</span><span class="params">(<span class="keyword">uint64_t</span> n)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> (; n &gt; <span class="number">0</span>; n --) &#123;</span><br><span class="line">    <span class="comment">/* Execute one instruction, including instruction fetch,</span></span><br><span class="line"><span class="comment">     * instruction decode, and the actual execution. */</span></span><br><span class="line">    exec_wrapper(print_flag);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="325-exec_wrapper"><a class="markdownIt-Anchor" href="#325-exec_wrapper"></a> 3.2.5 exec_wrapper()</h3><blockquote><p><strong><code>exec_wrapper()</code> 的执行过程</strong>：</p><p>首先将当前的 <code>eip</code> 保存到全局译码信息 <code>decoding</code> 的成员 <code>seq_eip</code> 中,然后将其地址被作为参数送进<code>exec_real()</code> 函数中。<code>seq</code> 代表顺序的意思, 当代码从 <code>exec_real()</code> 返回时, <code>decoding.seq_eip</code> 将会指向下一条指令的地址.<code>exec_real()</code> 函数通过宏 <code>make_EHelper</code> 来定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> make_EHelper(name) void concat(exec_, name) (vaddr_t *eip)</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>其含义是&quot;定义一个执行阶段相关的helper函数&quot;, 这些函数都带有一个参数<code>eip</code>。NEMU通过不同的helper函数来模拟不同的步骤.</p></blockquote><p>调用了exec_wrapper函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exec_wrapper</span><span class="params">(<span class="keyword">bool</span> print_flag)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  decoding.seq_eip = cpu.eip;</span><br><span class="line">  exec_real(&amp;decoding.seq_eip);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取当前cpu的eip，然后执行exec_real函数。</p><h3 id="326-exec_real"><a class="markdownIt-Anchor" href="#326-exec_real"></a> 3.2.6 exec_real()</h3><blockquote><p>在 <code>exec_real()</code> 中:</p><ul><li>首先通过 <code>instr_fetch()</code> 函数(在<code>nemu/include/cpu/exec.h</code>中定义)进行<strong>取指</strong>, 得到指令的第一个字节, 将其解释成 <code>opcode</code> 并记录在全局译码信息 <code>decoding</code> 中；</li><li>根据 <code>opcode</code> 查阅译码查找表, 得到操作数的宽度信息, 并通过调用 <code>set_width()</code> 函数将其记录在全局译码信息 <code>decoding</code> 中；</li><li>调用 <code>idex()</code> 对指令进行进一步的译码和执行。</li></ul></blockquote><p>因为宏定义，exec_real也就是make_EHelper(real)函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> make_EHelper(name) void concat(exec_, name) (vaddr_t *eip)</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">make_EHelper(real) &#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> opcode = instr_fetch(eip, <span class="number">1</span>);</span><br><span class="line">  decoding.opcode = opcode;</span><br><span class="line">  set_width(opcode_table[opcode].<span class="built_in">width</span>);</span><br><span class="line">  idex(eip, &amp;opcode_table[opcode]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>decoding是保存当前单条命令译码结果的结构体。</p><h4 id="3261-set_width解决问题"><a class="markdownIt-Anchor" href="#3261-set_width解决问题"></a> 3.2.6.1 set_width()（解决问题）</h4><p><strong>set_width函数使用到了width</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_width</span><span class="params">(<span class="keyword">int</span> <span class="built_in">width</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">width</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">width</span> = decoding.is_operand_size_16 ? <span class="number">2</span> : <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  decoding.src.<span class="built_in">width</span> = decoding.dest.<span class="built_in">width</span> = decoding.src2.<span class="built_in">width</span> = <span class="built_in">width</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>set_width函数中表明：如果width设置0，就可能是2字节或4字节；如果不设置就是width的值；就是设置操作数（src+dest）的宽度。</strong></p><h4 id="3262-idex"><a class="markdownIt-Anchor" href="#3262-idex"></a> 3.2.6.2 idex()</h4><p>set_width函数之后执行idex函数，译码+执行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Instruction Decode and EXecute */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">idex</span><span class="params">(<span class="keyword">vaddr_t</span> *eip, opcode_entry *e)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* eip is pointing to the byte next to opcode */</span></span><br><span class="line">  <span class="keyword">if</span> (e-&gt;decode)</span><br><span class="line">    e-&gt;decode(eip);</span><br><span class="line">  e-&gt;execute(eip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会调用译码查找表中的相应的译码函数进行操作数的<strong>译码</strong>. 译码函数统一通过宏 <code>make_DHelper</code> 来定义(在 <code>nemu/src/cpu/decode/decode.c</code> 中)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> make_DHelper(name) void concat(decode_, name) (vaddr_t *eip)</span></span><br></pre></td></tr></table></figure><blockquote><p>它们的名字主要采用 <strong>i386 手册附录 A</strong>中的操作数表示记号, 例如 <code>I2r</code> 表示将立即数移入寄存器, 其中 <code>I</code> 表示立即数, <code>2</code> 表示英文 <code>to</code>, <code>r</code> 表示通用寄存器, 更多的记号请参考 <strong>i386 手册</strong>.译码函数会把指令中的操作数信息分别记录在全局译码信息 <code>decoding</code> 中。</p><p>这些译码函数会进一步分解成各种不同操作数的译码的组合, 以实现操作数译码的解耦. 操作数译码函数统一通过宏 <code>make_DopHelper</code> 来定义 (在 <code>nemu/src/cpu/decode/decode.c</code> 中, <code>decode_op_rm()</code> 除外):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">#<span class="meta-keyword">define</span> make_DopHelper(name) void concat(decode_op_, name) (vaddr_t *eip, Operand *op, bool load_val)</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>它们的名字主要采用 <strong>i386 手册附录 A</strong> 中的操作数表示记号. 操作数译码函数会把操作数的信息记录在结构体 <code>op</code> 中, 如果操作数在指令中, 就会通过 <code>instr_fetch()</code> 将它们从 <code>eip</code> 所指向的内存位置取出. 为了使操作数译码函数更易于复用, 函数中的 <code>load_val</code> 参数会控制是否需要将该操作数读出到全局译码信息 <code>decoding</code> 供后续使用. 例如如果一个内存操作数是源操作数, 就需要将这个操作数从内存中读出来供后续执行阶段来使用; 如果它仅仅是一个目的操作数, 就不需要从内存读出它的值了, 因为执行这条指令并不需要这个值, 而是将新数据写入相应的内存位置.</p></blockquote><p><code>idex()</code> 函数中的译码过程结束之后, 会调用译码查找表中的相应的执行函数来进行真正的<strong>执行</strong>操作. 执行函数统一通过宏 <code>make_EHelper</code> 来定义, 它们的名字是指令操作本身. 执行函数通过 RTL 来描述指令真正的执行功能(RTL 将在下文介绍). 其中 <code>operand_write()</code> 函数(在 <code>nemu/src/cpu/decode/decode.c</code> 中定义) 会根据第一个参数中记录的类型的不同进行相应的写操作, 包括写寄存器和写内存.</p><p>从 <code>idex()</code> 返回后, <code>exec_real()</code> 最后会通过 <code>update_eip()</code> 对 <code>eip</code> 进行更新。</p><h3 id="327-指令执行结束后"><a class="markdownIt-Anchor" href="#327-指令执行结束后"></a> 3.2.7 指令执行结束后</h3><p>执行完后，再次返回cpu_exec函数的for循环：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Simulate how the CPU works. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpu_exec</span><span class="params">(<span class="keyword">uint64_t</span> n)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> (; n &gt; <span class="number">0</span>; n --) &#123;</span><br><span class="line">    <span class="comment">/* Execute one instruction, including instruction fetch,</span></span><br><span class="line"><span class="comment">     * instruction decode, and the actual execution. */</span></span><br><span class="line">    exec_wrapper(print_flag);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环上述流程，直到你指定的步数（c命令是-1，也就是最大值，也就是执行全部）。</p><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://zhong-kangwei.gitee.io/ics-pa-gitbook-2022/pa2/2.1.html" target="_blank" rel="noopener">讲义</a></li><li><a href="http://www.stardustdl.top/posts/learning/nju-icspa-analytics-nemu/" target="_blank" rel="noopener">NJU ICS Programming Assignment 代码分析 - NEMU</a></li><li><a href="https://ilern.github.io/2021/01/12/NJU-ics-2020-%E6%A6%82%E8%A6%81/#%E8%AF%B7%E6%95%B4%E7%90%86%E4%B8%80%E6%9D%A1%E6%8C%87%E4%BB%A4%E5%9C%A8NEMU%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B" target="_blank" rel="noopener">NJU ics 2020 概要</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="计组" scheme="https://Dragonliu2022.github.io/categories/计组/"/>
    
    
  </entry>
  
  <entry>
    <title>深度学习中的一些名词</title>
    <link href="https://dragonliu2022.github.io/2022/04/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%90%8D%E8%AF%8D/"/>
    <id>https://dragonliu2022.github.io/2022/04/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%90%8D%E8%AF%8D/</id>
    <published>2022-04-22T13:53:40.000Z</published>
    <updated>2022-04-25T14:10:08.886Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-参数"><a class="markdownIt-Anchor" href="#1-参数"></a> 1 参数</h1><h2 id="11-batch"><a class="markdownIt-Anchor" href="#11-batch"></a> 1.1 batch</h2><p>两种解释：</p><ol><li>对于一个有 2000 个训练样本的数据集。将 2000 个样本分成大小为 500 的 <strong>batch</strong>，那么完成一个 <strong>epoch</strong> 需要 4 个 <strong>iteration</strong>。</li><li>如果把准备训练数据比喻成一块准备打火锅的牛肉，那么<strong>epoch</strong>就是整块牛肉，batch就是切片后的牛肉片，<strong>iteration</strong>就是涮一块牛肉片。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">512</span>  <span class="comment"># batch的大小</span></span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/71f31c105879" target="_blank" rel="noopener">深度学习训练之Batch</a></p><h2 id="12"><a class="markdownIt-Anchor" href="#12"></a> 1.2</h2><h1 id="2-网络层"><a class="markdownIt-Anchor" href="#2-网络层"></a> 2 网络层</h1><h2 id="21-嵌入层"><a class="markdownIt-Anchor" href="#21-嵌入层"></a> 2.1 嵌入层</h2><p>嵌入层将词元的索引映射到其特征向量。该层的权重是一个矩阵，其行数等于字典大小（<code>input_dim</code>），列数等于每个标记的向量维数（<code>output_dim</code>）。在词嵌入模型训练之后，这个权重就是我们所需要的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">embed = nn.Embedding(num_embeddings=<span class="number">20</span>, embedding_dim=<span class="number">4</span>)</span><br></pre></td></tr></table></figure><h1 id="3-函数"><a class="markdownIt-Anchor" href="#3-函数"></a> 3 函数</h1><h1 id="4-其他"><a class="markdownIt-Anchor" href="#4-其他"></a> 4 其他</h1><h2 id="41-二元交叉熵损失"><a class="markdownIt-Anchor" href="#41-二元交叉熵损失"></a> 4.1 二元交叉熵损失</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="AI" scheme="https://Dragonliu2022.github.io/categories/AI/"/>
    
    
    <category term="深度学习" scheme="https://Dragonliu2022.github.io/tags/深度学习/"/>
    
  </entry>
  
  <entry>
    <title>hexo d报错</title>
    <link href="https://dragonliu2022.github.io/2022/04/19/hexo-d%E6%8A%A5%E9%94%99/"/>
    <id>https://dragonliu2022.github.io/2022/04/19/hexo-d%E6%8A%A5%E9%94%99/</id>
    <published>2022-04-19T03:10:19.000Z</published>
    <updated>2022-04-19T04:06:00.964Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-报错"><a class="markdownIt-Anchor" href="#1-报错"></a> 1 报错</h1><p>hexo d 命令报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/c/Users/Dragon Liu/.ssh/config: line 5: Bad configuration option: password</span><br><span class="line">/c/Users/Dragon Liu/.ssh/config: terminating, 1 bad configuration options</span><br><span class="line">fatal: Could not <span class="built_in">read</span> from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br><span class="line">[41mFATAL[49m Something<span class="string">'s wrong. Maybe you can find the solution here: [4mhttps://hexo.io/docs/troubleshooting.html[24m</span></span><br><span class="line"><span class="string">[33mError: Spawn failed</span></span><br><span class="line"><span class="string">    at ChildProcess.&lt;anonymous&gt; (E:\01 Blog_work\Hexo-Blog\node_modules\hexo-deployer-git\node_modules\hexo-util\lib\spawn.js:51:21)</span></span><br><span class="line"><span class="string">    at ChildProcess.emit (events.js:200:13)</span></span><br><span class="line"><span class="string">    at ChildProcess.cp.emit (E:\01 Blog_work\Hexo-Blog\node_modules\hexo-deployer-git\node_modules\cross-spawn\lib\enoent.js:34:29)</span></span><br><span class="line"><span class="string">    at Process.ChildProcess._handle.onexit (internal/child_process.js:272:12)[39m</span></span><br></pre></td></tr></table></figure><h1 id="2-解决"><a class="markdownIt-Anchor" href="#2-解决"></a> 2 解决</h1><h2 id="21-情况1"><a class="markdownIt-Anchor" href="#21-情况1"></a> 2.1 情况1</h2><p><code>ssh -T git@github.com</code> 测试无法连接：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E:\01 Blog_work\Hexo-Blog&gt;ssh -T git@github.com</span><br><span class="line">C:\\Users\\Dragon Liu/.ssh/config: line 5: Bad configuration option: password</span><br><span class="line">C:\\Users\\Dragon Liu/.ssh/config: terminating, 1 bad configuration options</span><br></pre></td></tr></table></figure><p>原因是之前vscode下载插件Remote - SSH时配置了此文件：</p><img src="https://s2.loli.net/2022/04/19/EF7GobKALXv1jr3.png" width="800" height="300" alt="图片名称" align="center" id="186"><p>删除<code>config</code>文件即可测试成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E:\01 Blog_work\Hexo-Blog&gt;ssh -T git@github.com</span><br><span class="line">Warning: Permanently added the ECDSA host key <span class="keyword">for</span> IP address <span class="string">'140.82.112.3'</span> to the list of known hosts.</span><br><span class="line">Hi Dragonliu2018! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure><p>然后<code>hexo d</code>也可以成功。</p><h2 id="22-情况2"><a class="markdownIt-Anchor" href="#22-情况2"></a> 2.2 情况2</h2><p>hexo原本部署到GitHub，现在需要另一个hexo-blog来写Algorithm部分，然后部署到gitee，hexo d后出现报错。</p><p><code>ssh -T git@gitee.com</code> 测试无法连接：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E:\01 Blog_work\Hexo-Blog-Algorithm&gt;ssh -T git@gitee.com</span><br><span class="line">Warning: Permanently added the ED25519 host key <span class="keyword">for</span> IP address <span class="string">'180.97.125.228'</span> to the list of known hosts.</span><br><span class="line">git@gitee.com: Permission denied (publickey).</span><br></pre></td></tr></table></figure><p>原因是没有在 Gitee 中添加 SSH 公钥，复制<code>id_rsa_pub</code> 文件内容，然后打开 gitee 个人设置里面的 安全设置 - SSH公钥，标题可以随便取，把粘贴的内容复制到公钥里面，点击确定就可以：</p><img src="https://s2.loli.net/2022/04/19/yJIVgfYDMd2A7ne.png" width="900" height="250" alt="图片名称" align="center" id="187"><img src="https://s2.loli.net/2022/04/19/75BPQXYca9IuO2C.png" width="900" height="500" alt="图片名称" align="center" id="188"><p>此时测试成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E:\01 Blog_work\Hexo-Blog-Algorithm&gt;ssh -T git@gitee.com</span><br><span class="line">Hi [36;01mDragon-Liu[0m! You<span class="string">'ve [32msuccessfully[0m authenticated, but GITEE.COM does not provide shell access.</span></span><br></pre></td></tr></table></figure><p>然后<code>hexo d</code>即可成功。</p><blockquote><p><strong>吐槽</strong>：</p><ol><li>很容易部署失败：提示可能包含违禁违规内容。</li><li>后期如果新增了文章，执行 <code>hexo g -d</code>后 ，还需要更新 Gitee Pages 服务</li></ol></blockquote><h1 id="x-参考"><a class="markdownIt-Anchor" href="#x-参考"></a> X 参考</h1><ul><li><a href="https://blog.csdn.net/qq_38157825/article/details/112783631" target="_blank" rel="noopener">Hexo 部署到 Gitee</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="环境与工具" scheme="https://Dragonliu2022.github.io/categories/环境与工具/"/>
    
    
    <category term="Hexo" scheme="https://Dragonliu2022.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>大数据训练营项目《北京二手房交易数据分析平台》整理</title>
    <link href="https://dragonliu2022.github.io/2022/04/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%AE%AD%E7%BB%83%E8%90%A5%E9%A1%B9%E7%9B%AE%E3%80%8A%E5%8C%97%E4%BA%AC%E4%BA%8C%E6%89%8B%E6%88%BF%E4%BA%A4%E6%98%93%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%E3%80%8B%E6%95%B4%E7%90%86/"/>
    <id>https://dragonliu2022.github.io/2022/04/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%AE%AD%E7%BB%83%E8%90%A5%E9%A1%B9%E7%9B%AE%E3%80%8A%E5%8C%97%E4%BA%AC%E4%BA%8C%E6%89%8B%E6%88%BF%E4%BA%A4%E6%98%93%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0%E3%80%8B%E6%95%B4%E7%90%86/</id>
    <published>2022-04-18T05:10:43.000Z</published>
    <updated>2022-04-18T16:02:57.639Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1 简介</h1><p>北京二手房交易数据分析平台：收集二手房交易数据，利用大数据技术进行处理，大屏展示结果  。</p><h1 id="2-工作流程"><a class="markdownIt-Anchor" href="#2-工作流程"></a> 2 工作流程</h1><ol><li><strong>数据收集</strong>：爬取二手房交易网站的数据（链家、贝壳等）</li><li><strong>数据预处理</strong>：不同的数据源，不同的数据结构，垃圾数据，对收集到的大数据集合进行预处理</li><li><strong>数据存储、处理与分析（我负责）</strong>：搭建hadoop环境，将数据文件上传hdfs，通过mapreduce进行数据分析等</li><li><strong>数据可视化</strong>：后端使用java、前端使用echarts模板等进行展示</li></ol><h1 id="3-负责"><a class="markdownIt-Anchor" href="#3-负责"></a> 3 负责</h1><ul><li><strong>集群</strong>：3台centos虚拟机</li><li><strong>名词解释</strong>：<ul><li>hadoop：Hadoop是一个能够对大量数据进行<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%84%E7%90%86" target="_blank" rel="noopener">分布式处理</a>的<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6" target="_blank" rel="noopener">软件</a>框架。 <a href="https://baike.baidu.com/item/Hadoop/3526507" target="_blank" rel="noopener">https://baike.baidu.com/item/Hadoop/3526507</a><ul><li>hdfs：分布式文件系统 <a href="https://baike.baidu.com/item/hdfs/4836121" target="_blank" rel="noopener">https://baike.baidu.com/item/hdfs/4836121</a></li><li>mapreduce：是一种编程模型，用于大规模数据集（大于1TB）的并行运算 <a href="https://baike.baidu.com/item/MapReduce/133425" target="_blank" rel="noopener">https://baike.baidu.com/item/MapReduce/133425</a></li></ul></li><li>hive：Hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供类SQL查询功能。 <a href="https://developer.aliyun.com/article/100911" target="_blank" rel="noopener">https://developer.aliyun.com/article/100911</a></li><li>sqoop：主要用于在Hadoop(Hive)与传统的数据库(mysql、postgresql…)间进行数据的传递   <a href="https://baike.baidu.com/item/sqoop/5033853" target="_blank" rel="noopener">https://baike.baidu.com/item/sqoop/5033853</a></li></ul></li></ul><h1 id="4-项目架构图"><a class="markdownIt-Anchor" href="#4-项目架构图"></a> 4 项目架构图</h1><p><img src="https://s2.loli.net/2022/03/23/FPK2J3Ozo71Veav.png" alt></p><h1 id="5-困难"><a class="markdownIt-Anchor" href="#5-困难"></a> 5 困难</h1><ul><li>hadoop集群搭建失败：版本没用对</li><li></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="大数据" scheme="https://Dragonliu2022.github.io/categories/大数据/"/>
    
    
    <category term="待补充" scheme="https://Dragonliu2022.github.io/tags/待补充/"/>
    
  </entry>
  
  <entry>
    <title>《世事如书，我只爱你这一句》书籍</title>
    <link href="https://dragonliu2022.github.io/2022/04/17/%E3%80%8A%E4%B8%96%E4%BA%8B%E5%A6%82%E4%B9%A6%EF%BC%8C%E6%88%91%E5%8F%AA%E7%88%B1%E4%BD%A0%E8%BF%99%E4%B8%80%E5%8F%A5%E3%80%8B%E4%B9%A6%E7%B1%8D/"/>
    <id>https://dragonliu2022.github.io/2022/04/17/%E3%80%8A%E4%B8%96%E4%BA%8B%E5%A6%82%E4%B9%A6%EF%BC%8C%E6%88%91%E5%8F%AA%E7%88%B1%E4%BD%A0%E8%BF%99%E4%B8%80%E5%8F%A5%E3%80%8B%E4%B9%A6%E7%B1%8D/</id>
    <published>2022-04-17T14:34:04.000Z</published>
    <updated>2022-04-17T16:10:08.246Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1 简介</h1><p>朱生豪：“醒来觉得甚是爱你。”</p><p>张爱玲：“因为爱过，所以慈悲；因为懂得，所以宽容。”</p><p>林徽因：“答案很长，我得用一生去回答你，准备好听我了吗？”</p><p>钱钟书：“我见到她之前，从未想到要结婚；我娶了她十几年，从未后悔娶她；也从未想过要娶别的女人。”</p><p>沈从文说：“我走过许多地方的路，行过许多地方的桥，看过许多次数的云，喝过许多种类的酒，却只爱过一个正当最好年龄的人。”</p><p>央视朗读者盛赞，温暖了一个世纪的民国爱情故事。20对民国才子佳人的缱绻情书，有梁思成与林徽因的“门当户对四月天”，有林语堂与廖翠凤的“焚证报卿缠绵意”，有徐志摩与陆小曼的“离悲成欢有绝期”，也有胡兰成与张爱玲的“终成饭粘萎尘泥”，一字字，一句句，令人心生暖意，不禁想回到那个年代，去同他们一起谈天说地，抑或静下心来给心上人，写一封暖暖的情书。</p><p>关于民国美好的爱情故事，是印刻在我们记忆里的传奇，我们不断回忆，不断打磨，把思念书写成文字，把故事打磨成璞玉。最终，裁成四月的天。</p><h1 id="2-作者"><a class="markdownIt-Anchor" href="#2-作者"></a> 2 作者</h1><p>特立独行的猪先生，编剧、民国史研究者。因热爱民国史，致力于把枯燥的历史用年轻人喜闻乐见的方式表述出来，创有历史游记节目“猪游记”，现为独立自媒体人。</p><p>作者访遍书中人物故居，翻阅现存史料记载，游历了各个名人博物馆，并整理了他们当年的信件及书稿，历数年写就成书。</p><p>作者完全摒弃了市面上诸多历史书籍误读的地方，并一一实地考察校正，为我们真实还原了那个时期民国才子佳人的爱情故事，完整重现了他们可歌可泣的爱情历程。</p><h1 id="3-摘抄"><a class="markdownIt-Anchor" href="#3-摘抄"></a> 3 摘抄</h1><center>一刹那的爱意，可以永恒</center><p><strong>醒来觉得甚是爱你 朱生豪&amp;宋清如</strong></p><blockquote><p>朱生豪在给宋清如的信中写道：“要是我们两人一同在雨声里做梦，那意境是如何不同，或者一同在雨声里失眠，那也是何等有味。”</p><hr><p>我是宋清如至上主义者。</p><hr><p>要是世上只有我们两个人多么好，我一定要把你欺负得哭不出来。</p><hr><p>我爱你也许并不为什么理由，虽然可以有理由，例如你聪明，你纯洁，你可爱，你是好人等，但主要的原因大概是你全然适合我的趣味。因此你仍知道我是自私的，故不用感激我。</p></blockquote><p><strong>从今往后，咱们只有死别，再无生离 钱钟书&amp;杨绛</strong></p><blockquote><p>有的时候，人和人的缘分，一面就能注定。</p><hr><p>后来两人再次见面，约在了清华大学工字厅。钱钟书说道：“我没有订婚。”杨绛答：“我也没有男朋友。”</p><p>对话就是这样直白，一旦遇到了自己心动的那个人，不需要太多的言语，从对方的瞳孔里，你会看到光。</p><hr><p>缠绵悱恻好文章，粉恋香凄足断肠。答报情痴无别物，辛酸一把泪千行。</p><p>依穰小妹剧关心，髾瓣多情一往深。别后经时无只字，居然惜墨抵兼金。</p><p>良宵苦被睡相谩，猎猎风声测测寒。如此星辰如此月，与谁指点与谁看。</p><p>困人节气奈何天，泥煞衾函梦不圆。苦雨泼寒宵似水，百虫声里怯孤眠。</p></blockquote><p><strong>我明白你会来，所以我等 沈从文&amp;张兆和</strong></p><blockquote><p>沈从文这个从乡下走出来的男子遇见清秀典雅的张兆和，便爱得一发不可收拾，他按捺不住内心狂热的爱慕。他把爱慕之情化作情书，第一封情书的开头就直白地写道：</p><p>不知道为什么，我突然爱上了你！</p><hr><p>张兆和对于爱的理解是对的，爱是双方的，需要灵魂的契合，爱就是爱，不爱就是不爱。爱不是感动，不是单方面的付出，当爱掺杂了太多的不平等时，这份爱也就不再能给相爱的人带来快乐。</p></blockquote><p><strong>因为懂得，所以慈悲 张爱玲&amp;胡兰成</strong></p><blockquote><p>张爱玲说：“见了他，她变得很低很低，低到尘埃里，但她心里是欢喜的，从尘埃里开出花来。”</p></blockquote><p><strong>明月装饰了你的窗子，你装饰了别人的梦 卞之琳&amp;张充和</strong></p><blockquote><p>那一抹笑，像是一朵莲花，盛开在那清波碧水间，荡起了一圈一圈涟漪，倩影映射在他的瞳孔里，在他明亮细腻的心里，扎下了根。</p><hr><p>这首诗便是《断章》：</p><p>你站在桥上看风景，</p><p>看风景的人在楼上看你。</p><p>明月装饰了你的窗子，</p><p>你装饰了别人的梦。</p><hr><p>张充和无奈地说道：“从来大家都这么问，我说：他没有说请客，我怎么能说不来呢？他从来没有认真跟我表白过，写信说的也只是日常普通的事，只是写得有点啰唆。</p><hr><p>不得不承认，在我们的生命中，有些人哪怕是很多年没见，你早已忘记了她的声音，脑海中模糊了她的容颜，但再次相遇时，那感觉却永远不会变。</p></blockquote><p><strong>你是燕在梁间的呢喃，你是人间的四月天 梁思成&amp;林徽因</strong></p><blockquote><p>中国有句俗话，‘文章是自己的好，老婆是人家的好’。可是对我来说是，老婆是自己的好，文章是老婆的好，我不否认和林徽因在一起有时很累，因为她的思想太活跃，和她在一起必须和她同样的反应敏捷才行，不然就跟不上她。</p></blockquote><p><strong>心里挂念一个人，从此便有一座城 金岳霖&amp;林徽因</strong></p><blockquote><p>金岳霖听闻后不禁恸哭，在林徽因的追悼会上，金岳霖眼泪没停过，并为她送上了一副挽联：</p><p>一身诗意千寻瀑<br>万古人间四月天</p><hr><p>我们能想象，他在想什么，他或许会想起总布胡同的那段时光，那天，他第一次见到林徽因笑靥如花的样子，就像那四月的花，开在了那个初春，扎根在了他的心里；他或许会想起西南联大的艰苦岁月，会想起林徽因的一颦一笑、一步一印，往事一幕一幕在眼前晃过，活着的他又何尝不想去见她？心里挂念一个人，从此便有一座城。</p><hr><p>人生在世，是该相信点什么的。</p><p>相信爱情，相信遇见与离别；相信未来，会有那样一个人，在不远处等着你；相信一切都是最好的安排；相信美好的事即将发生。</p></blockquote><p><strong>风华是一指流沙，苍老是一段年华 徐志摩&amp;陆小曼</strong></p><blockquote><p>这是婚后陆小曼写给王映霞的信里的话，可谓一针见血。这点她没有林徽因明白得早，当年林徽因就知道徐志摩喜欢的自己并不是真实的自己，而是他自己臆想出来的林徽因。</p></blockquote><p><strong>彪悍的婚姻，不需要解释 胡适&amp;江冬秀</strong></p><blockquote><p>…</p></blockquote><p><strong>小白象与小刺猬，他们相拥而爱 鲁迅&amp;许广平</strong></p><blockquote><p>鲁迅说：“我脾气不好。”</p><p>许广平说：“因为你是先生，我多少让你些，如果是年龄相仿的对手，我不会这样的。”</p></blockquote><p><strong>你许我岁月静好，我还你现世安稳 巴金&amp;萧珊</strong></p><blockquote><p>一生选一人，择一城，生同眠，死同穴，生生世世都要在一起。巴金与萧珊二十多年相濡以沫，两个人在一起，朝着相同的方向努力，相互扶持，这就是最好的爱情。</p></blockquote><p><strong>陪伴是最长情的爱恋，相守是最美好的婚姻 林语堂&amp;廖翠凤</strong></p><blockquote><p>结婚的时候，林语堂做了一件奇事，他把结婚证书一把火烧掉了。</p><p>他说了这样一句话：“把婚书烧了吧，因为婚书只是离婚时才用得着。”</p><p>张爱玲说：“也许每一个男子全都有过这样的两个女人，至少两个，娶了红玫瑰，久而久之，红的变了墙上的一抹蚊子血，白的还是床前明月光，娶了白玫瑰，白的便是衣服上沾的一粒饭粘子，红的却是心口上一颗朱砂痣。</p><hr><p>廖翠凤的一生是甜蜜的、快乐的。人生中最幸福的事就是和同床共枕的那个人一起嘻嘻闹闹，一起看着彼此鬓角渐白、牙齿渐松，然后相对掩嘴偷笑，彼此相依，共度一生。</p></blockquote><p><strong>爱情和婚姻，就该是这般模样 梁实秋&amp;程季淑</strong></p><blockquote><p>程季淑去世后，梁实秋说：“我像一棵树，突然一声霹雳，电火殛毁了半劈的树干，还剩下半株，有枝有叶，还活着，但是生意尽矣。两个人手拉着手的走下山，一个突然倒下去，另一个只好踉踉跄跄地独自继续他的旅程！</p><hr><p>娶妻如此，夫复何求。<br>平生伴侣，亦友亦妻。</p></blockquote><p><strong>他们的爱情，如荷塘清风般淡雅 朱自清&amp;陈竹隐</strong></p><blockquote><p>一九三一年六月十二日，朱自清在情书中写道：“隐，一见你的眼睛，我便清醒起来，我更喜欢看你那晕红的双腮，黄昏时的霞彩似的，谢谢你给我力量。</p><hr><p>原来，生活可以美好，只是过去忘了去寻找。</p></blockquote><p><strong>君对我情断义绝，我偏长出倔强花朵 徐志摩&amp;张幼仪</strong></p><blockquote><p>张幼仪其实长得不差，她自己也说： 我身材不错，还长着一双大眼睛，也是被人夸大的。</p></blockquote><p><strong>生同眠，死同穴，生生世世都要在一起 吴文藻&amp;冰心</strong></p><blockquote><p>冰心：“爱在右，同情在左，走在生命路的两旁，随时撒种，随时开花，将这一径长途，点缀得香花弥漫，使穿枝拂叶的行人，踏着荆棘，不觉得痛苦，有泪可落，也不是悲凉。”</p><hr><p>生同眠，死同穴，天地合，不可与君绝，这大抵就是世间最圆满的爱情了。</p><blockquote><p><strong>此处化用</strong>：汉代<a href="https://so.gushiwen.cn/authorv_2128926194cd.aspx" target="_blank" rel="noopener">佚名</a>的《上邪》</p><p>我欲与君相知，长命无绝衰。<br><strong>山无陵</strong>，江水为竭，冬雷震震，夏雨雪，<strong>天地合，乃敢与君绝！</strong></p></blockquote></blockquote><p><strong>你走，我当你没来过 徐悲鸿&amp;蒋碧微</strong></p><blockquote><p>但蒋碧微拒绝了，并拒绝了六次，无论这个男人在她面前表现得多么悔恨。蒋碧微对徐悲鸿说：“你来，我相信你不会走；你走，我当你没来过。”</p></blockquote><p><strong>在你的生命中，我将孤独地老去 鲁迅&amp;朱安</strong></p><blockquote><p>这是母亲给我的一件礼物，我只能好好地供养她，爱情是我所不知道的。</p><hr><p>朱安明白自己这一生的命运，明白她追随鲁迅一辈子，与他也只能是两条平行线，此生没有相交的可能。她终其一生，都不会是那个与鲁迅温馨相伴的女子。</p><hr><p>朱安的一生，是悲剧的一生，如她自己所说：鲁迅与她不好，她想好好地服侍他，一切顺着他，将来总会好的。</p><p>然而一切没有变好，她与鲁迅越走越远，她就这样在岁月中蹉跎了自己的一生。就像那只蜗牛，一点一点地往上爬，她相信总有一天能爬到墙顶，走进鲁迅的心里，但鲁迅终究不是胡适，朱安也不是江冬秀，她拼尽余生的力气终究也没能成为鲁迅心口上的一颗朱砂痣。</p></blockquote><p><strong>最好的爱情，便是我懂你 张伯驹&amp;潘素</strong></p><blockquote><p>…</p></blockquote><p><strong>微风吹动了我的头发，教我如何不想她 赵元任&amp;杨步伟</strong></p><blockquote><p>…</p></blockquote><h1 id="4-自评"><a class="markdownIt-Anchor" href="#4-自评"></a> 4 自评</h1><p>大四上学期一段时间特别喜欢看欧丽娟关于爱情的视频，其中她推荐了这本书《世事如书，我只爱你这一句》。</p><p>向来欣赏民国才子佳人，但是将其冠以<code>择一人终老，携一人白首</code>的刻板印象，未免有些不公平，对此我有心理准备，于是安静地期待地翻开了这本书。</p><hr><p>（待补充）</p><hr><p>我明白你会来，所以我等。等到最好的我，去遇到更好的你。</p><h1 id="5-他评"><a class="markdownIt-Anchor" href="#5-他评"></a> 5 他评</h1><p>xxx</p><h1 id="6-拓展"><a class="markdownIt-Anchor" href="#6-拓展"></a> 6 拓展</h1><p>是否被拍成影视作品？（无）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="阅读" scheme="https://Dragonliu2022.github.io/categories/阅读/"/>
    
    
    <category term="书评" scheme="https://Dragonliu2022.github.io/tags/书评/"/>
    
  </entry>
  
  <entry>
    <title>MR(merge request) vs PR(pull request)</title>
    <link href="https://dragonliu2022.github.io/2022/04/15/MR-merge-request-vs-PR-pull-request/"/>
    <id>https://dragonliu2022.github.io/2022/04/15/MR-merge-request-vs-PR-pull-request/</id>
    <published>2022-04-15T08:04:41.000Z</published>
    <updated>2022-04-18T11:31:16.498Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p><strong>转载</strong>：<a href="https://mp.weixin.qq.com/s?__biz=MzkwNzI0MzQ2NQ==&amp;mid=2247489125&amp;idx=2&amp;sn=735299f1744b1074e54cbeeaeadc1e9c&amp;source=41#wechat_redirect" target="_blank" rel="noopener">啥是 PR？啥又是MR？</a></p></blockquote><h1 id="1-引入"><a class="markdownIt-Anchor" href="#1-引入"></a> 1 引入</h1><p>在团队中我承担了<code>Committer</code> 的责任，也就是帮同事们检视代码（<code>Code Review</code>）和合入代码，经常听到有同事在群里喊：“大佬，帮我合个 PR”，“大佬，我刚提交了一个 MR，帮忙合一下，急着出补丁”。我有点懵了，<code>PR</code> 和 <code>MR</code> 到底哪个才是正确的，这两个到底有什么区别，我决定先搞清楚这两个概念再合入他们的代码。[手动滑稽]</p><h1 id="2-什么是pull-request"><a class="markdownIt-Anchor" href="#2-什么是pull-request"></a> 2 什么是Pull Request？</h1><p><code>PR</code> 的全称是<code>Pull Request</code>，经常用 <code>Github</code> 的同学对这个肯定很熟悉了。Github 聚集了4000万开发者，过亿的开源项目，如果想给别人的开源仓库贡献代码，通常是先 <code>fork</code> 别人的项目，然后本地修改完成提交到自己的个人 fork 仓库，最后提交 PR 等待别人合入你的代码。</p><p>Github 的工作流（fork 工作流）：</p><img src="https://s2.loli.net/2022/04/15/CLTr3VjuGOwJUBg.png" width="400" height="400" alt="fork 工作流" align="center" id="150"><p>我们重点看一下第6步，小明写完代码了想合入到原作者的仓库，新建了一个“<code>pull request</code>”，拉请求？这明明是推啊，小明将自己的修改推到原作者的仓，感觉叫“<code>push request</code>”比较合适吧。</p><p>既然 Github 坚持叫“<code>pull request</code>”，我们试着理解一下它的思路，小明写完代码了心里肯定是在想：<code>原作者大神，我改了点东西，你快把我的修改拉回去吧</code>。站在原作者的角度思考，叫pull request好像也说得过去，每天有大量的人从我这里 fork 代码走，我只会拉取我感兴趣的代码回来。</p><p>我好像把自己说服了。</p><h1 id="3-什么是-merge-request"><a class="markdownIt-Anchor" href="#3-什么是-merge-request"></a> 3 什么是 Merge Request？</h1><p>MR 的全称是 <code>Merge Request</code>，相信玩过 Gitlab 的同学都知道这个。</p><p>插播一下，Github这么好用了为什么还有人玩 Gitlab，这就要几年前说起了。在微软没有收购 Github 之前，Github 上面所有的项目必须是公开的，也就是说自己很渣的代码也必须要公开，不能藏着噎着。但是在一些小的公司或者创业团队，代码这种核心资产是不希望被公开，他们迫切需要私密仓这种需求，所以很多人都选择了 Gitlab。当然后面 Github 也放开了私有仓库，这是后话了。</p><p>merge 工作流：</p><img src="https://s2.loli.net/2022/04/15/q4NIh1H7ZVA9CR2.png" width="500" height="400" alt="merge 工作流" align="center" id="151"><p>团队中每个人都从远程仓库 develop 分支拉取代码，本地基于 develop 分支新建特性分支，修改完代码将特性分支推到远程仓，紧接着新建 Merge Request 期望将自己的特性分支合入 develop 分支。</p><p>从上面这个流程来看Merge Request 就是将自己的特性分支合入到主干分支。</p><h1 id="4-pull-request-vs-merge-request"><a class="markdownIt-Anchor" href="#4-pull-request-vs-merge-request"></a> 4 Pull Request VS Merge Request</h1><p>总结一下上面两个例子。</p><p>Github 是玩 fork 模式的，开发者提交自己的代码新建 Pull Request，请求原作者：“把我的代码拉回去吧”。</p><p>Gitlab 是玩分支模式的，开发者提交自己的代码新建 Merge Request，想将自己的特性分支合并到主干。</p><p>上面总结的好像很有道理，但是不要忘了，Github 也可以玩分支模式，Gitlab 也可以玩 fork 模式，更令人无语的是：</p><p>Github 上合并分支还是叫 Pull Request；Gitlab 上fork 模式也是叫 Merge Request；</p><p>不行，这种答案我没法接受，去 stackoverflow上搜一些大家是怎么理解的。果然有一个帖子很火：</p><p>Pull request vs Merge request</p><p>有一个回答摘取了 Gitlab 的官方解释：</p><blockquote><p>Merge or pull requests are created in a git management application and ask an assigned person to merge two branches. Tools such as GitHub and Bitbucket choose the name pull request since the first manual action would be to pull the feature branch. Tools such as GitLab and Gitorious choose the name merge request since that is the final action that is requested of the assignee. In this article we’ll refer to them as merge requests.</p></blockquote><p>翻译过来简单理解就是：这两个没有本质区别，站在不同立场说法不一样而已。</p><p><strong>好了，官方已经盖棺定论了，这两个就是一个东西，不要纠结啦~</strong></p><h1 id="5-疯狂吐槽"><a class="markdownIt-Anchor" href="#5-疯狂吐槽"></a> 5 疯狂吐槽</h1><p>对于初学者来说，Github 的 pull request 确实让人难以理解，我们去各大网站看看用户的声音。</p><p>StackOverflow：</p><img src="https://s2.loli.net/2022/04/15/f8jlvChkSD5FBxi.png" width="600" height="400" alt="merge 工作流" align="center" id="152"><p>知乎：</p><img src="https://s2.loli.net/2022/04/15/LGJDK7hlTadr3Pn.png" width="600" height="400" alt="merge 工作流" align="center" id="153"><p>从国外到国内都有大量的用户对这个名字不理解，明明是提交提交代码，为什么是 pull request，有些人甚至怀疑是名字打错了。</p><p>如果让我来给 Github 取名字，我可能会取：</p><ul><li><code>push request</code> 推请求</li><li><code>merge request</code> 合并请求</li></ul><p>想多了，不会有如果。[嘿哈]</p><h1 id="6-总结"><a class="markdownIt-Anchor" href="#6-总结"></a> 6 总结</h1><p><code>Pull Request</code> 和<code>Merge Request</code> 本质上都是合入代码，只是站在不同角度有不同的说法而已，因此在学习和工作中无论用哪一个都没有问题。</p><p>鼓励大家在 GitHub上多多提交 PR，为个人简历加分</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="环境与工具" scheme="https://Dragonliu2022.github.io/categories/环境与工具/"/>
    
    
    <category term="Git" scheme="https://Dragonliu2022.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>《代码整洁之道 clean code》笔记</title>
    <link href="https://dragonliu2022.github.io/2022/04/15/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%20clean%20code%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>https://dragonliu2022.github.io/2022/04/15/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%20clean%20code%E3%80%8B%E7%AC%94%E8%AE%B0/</id>
    <published>2022-04-15T07:43:14.000Z</published>
    <updated>2022-04-18T14:18:55.189Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><ul><li>《代码整洁之道 Clean Code》Robert C. Martin 著 韩磊 译 人民邮电出版社 2020</li><li>《Clean Code(评注版)》Robert C. Martin 著 韩磊 评注 电子工业出版社 2012</li></ul></blockquote><h1 id="ch2-meaningful-names有意义的命名"><a class="markdownIt-Anchor" href="#ch2-meaningful-names有意义的命名"></a> Ch2 Meaningful Names(有意义的命名)</h1><h2 id="21-use-intention-revealing-names名副其实"><a class="markdownIt-Anchor" href="#21-use-intention-revealing-names名副其实"></a> 2.1 Use Intention-Revealing Names(名副其实)</h2><p>如果名称需要注释来补充，那就算不上名副其实。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d;<span class="comment">//消逝的时间，以日计</span></span><br><span class="line"><span class="keyword">int</span> elapsedTimeInDays;</span><br></pre></td></tr></table></figure><h2 id="22-avoid-disinformation避免误导"><a class="markdownIt-Anchor" href="#22-avoid-disinformation避免误导"></a> 2.2 Avoid Disinformation(避免误导)</h2><p>程序员必须避免留下掩藏代码本意的错误线索。应当避免使用与本意相悖的词。</p><ul><li><p>缩写形式常常带来误导。编写三角计算程序，hp是hypotenuse(直角三角形的斜边)缩写，但也是UNIX平台或类UNIX平台的专有名称。</p></li><li><p>一些词对于程序员有特殊含义，如List：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">accountList;<span class="comment">//一组账号，如果账号的容器并List，就会引起错误的判断。</span></span><br><span class="line"><span class="comment">// 可以换成</span></span><br><span class="line">accountGroup;</span><br><span class="line">bunchOfAccounts;</span><br></pre></td></tr></table></figure></li><li><p>不使用差异较小的名称，不易区分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XYZControllerForEfficientHandlingOfStrings;</span><br><span class="line">XYZControllerForEfficientStorageOfStrings;</span><br></pre></td></tr></table></figure></li><li><p>不用小写字母<code>l</code>和大写字母<code>O</code>做为变量名，容易与数字<code>1</code>和<code>0</code>混淆</p></li></ul><h2 id="23-make-meaningful-distinctions做有意义的区分"><a class="markdownIt-Anchor" href="#23-make-meaningful-distinctions做有意义的区分"></a> 2.3 Make Meaningful Distinctions(做有意义的区分)</h2><ul><li>以数字系列命名：<code>a1,a2,a3...aN</code></li><li>废话：Product类、ProductInfo类、ProductData类三者名称不同，但是意思无区别</li></ul><h2 id="24-use-pronounceable-names使用可读命名"><a class="markdownIt-Anchor" href="#24-use-pronounceable-names使用可读命名"></a> 2.4 Use Pronounceable Names(使用可读命名)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Data genymdhms;<span class="comment">//生成日期，年、月、日、时、分、秒</span></span><br><span class="line">Data generationTimestamp;<span class="comment">//改进</span></span><br></pre></td></tr></table></figure><h2 id="25-use-searchable-names使用可搜索命名"><a class="markdownIt-Anchor" href="#25-use-searchable-names使用可搜索命名"></a> 2.5 Use Searchable Names(使用可搜索命名)</h2><p>不使用单字母名称和数字常量，在代码中找数字<code>7</code>要比找<code>MAX_CLASSES_PER_STUDENT</code>容易多；单字母名称可用在短方法的本地变量(local variables inside short methods)，如循环中的计数因子<code>i</code>，名称长短应与其作用域大小相对应。</p><h2 id="26-avoid-encoding避免编码"><a class="markdownIt-Anchor" href="#26-avoid-encoding避免编码"></a> 2.6 Avoid Encoding(避免编码)</h2><p>把类型或作用域加进命名中，徒然增加了读懂命名的负担。带编码的名称也不便发音，容易打错。</p><ul><li><p>匈牙利语标记法：</p><ul><li>在变量名中用缩写标记变量的类型。</li><li>在Windows的C语言API时代，编译器并不做类型检查，程序员需要匈牙利语标记法来帮助自己记住类型。</li><li>现代编程语言具有更丰富的类型系统，编译器也记得并强制使用类型。而且，人们趋向于使用更小的类、更短的方法，好让每个变量的定义都在视野范围之内。所以，如今HN和其他类型的编码方式纯属多余。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhoneNumber phoneString;<span class="comment">//类型发生变化时，名称并不发生变化</span></span><br></pre></td></tr></table></figure></li><li><p>成员前缀：不必使用<code>m_</code>前缀来表明成员变量</p></li><li><p>接口和实现(Interfaces and Implementations)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// build an Abstract Factory for the creation of shapes</span></span><br><span class="line">ShapeFactory;<span class="comment">//比较好</span></span><br><span class="line">IShapeFactory;<span class="comment">//I前缀表示接口，是废话</span></span><br><span class="line">ShapeFactoryImp;<span class="comment">//实现比接口好一些</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="27-avoid-mental-mapping避免惯性思维"><a class="markdownIt-Anchor" href="#27-avoid-mental-mapping避免惯性思维"></a> 2.7 Avoid Mental Mapping(避免惯性思维)</h2><p>不应当让读者在脑中把你的名称翻译为他们熟知的名称；这种问题经常出现在选择是使用问题领域术语还是解决方案领域术语时。</p><blockquote><p>聪明程序员和专业程序员之间的区别在于，专业程序员了解，明确是王道。专业程序员善用其能，编写其他人能理解的代码。</p></blockquote><h2 id="28-class-names类名"><a class="markdownIt-Anchor" href="#28-class-names类名"></a> 2.8 Class Names(类名)</h2><ul><li>类名和对象名应该是名词或名词短语，如Customer、WikiPage、Account 和AddressParser。</li><li>避免使用Manager、Processor、Data或Info这样的类名。</li><li>类名不应当是动词。</li></ul><h2 id="29-method-names方法名"><a class="markdownIt-Anchor" href="#29-method-names方法名"></a> 2.9 Method Names(方法名)</h2><ul><li><p>方法名应当是动词或动词短语，如postPayment、deletePage 或save。</p></li><li><p>属性访问器、修改器和断言(accessors, mutators, predicates)应该根据其值命名，并依Javabean 标准1加上get、set和is前缀。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name=employee.getName();</span><br><span class="line">customer.setName(<span class="string">"mike"</span>);</span><br><span class="line"><span class="keyword">if</span>(paycheck.isPosted())...</span><br></pre></td></tr></table></figure></li><li><p>重载构造器时，使用描述了参数的静态工厂方法名(static factory methods)。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Complex fulcrumPoint=Complex.FromRealNumber(<span class="number">23.0</span>);</span><br><span class="line"><span class="comment">// 通常好于</span></span><br><span class="line">Complex fulcrumPoint=<span class="keyword">new</span> Complex(<span class="number">23.0</span>);</span><br></pre></td></tr></table></figure><p>可以考虑将相应的构造器设置为private，强制使用这种命名手段。</p></li></ul><h2 id="210-dont-be-cute别抖机灵"><a class="markdownIt-Anchor" href="#210-dont-be-cute别抖机灵"></a> 2.10 Don’t Be Cute(别抖机灵)</h2><p>别用俗语、俚语。</p><h2 id="211-pick-one-word-per-concept每个概念对应一个词"><a class="markdownIt-Anchor" href="#211-pick-one-word-per-concept每个概念对应一个词"></a> 2.11 Pick One Word per Concept(每个概念对应一个词)</h2><p>给每个抽象概念选一个词，并且一以贯之。例如：</p><ul><li>fetch、retrieve和get虽有区别，但在前后一致、团队一致的情况下，可以任取其一，一以贯之。</li><li>还有controller、manager、driver</li></ul><h2 id="212-dont-pun别用双关语"><a class="markdownIt-Anchor" href="#212-dont-pun别用双关语"></a> 2.12 Don’t Pun(别用双关语)</h2><p>避免将同一单词用于不同目的。“一词一义”原则</p><h2 id="213-use-solution-domain-names使用解决方案领域名称"><a class="markdownIt-Anchor" href="#213-use-solution-domain-names使用解决方案领域名称"></a> 2.13 Use Solution Domain Names(使用解决方案领域名称)</h2><p>只有程序员才会读你的代码，所以尽量用那些计算机科学（Computer Science，CS）术语、算法名、模式名、数学术语。</p><h2 id="214-use-problem-domain-names使用问题领域名称"><a class="markdownIt-Anchor" href="#214-use-problem-domain-names使用问题领域名称"></a> 2.14 Use Problem Domain Names(使用问题领域名称)</h2><p>如果不能用程序员熟悉的术语来命名，就采用从所涉问题领域而来的名称。这样负责维护代码的程序员就能去请教领域专家了。</p><blockquote><p>优秀的程序员和设计师，其工作之一就是分离解决方案领域和问题领域的概念。</p></blockquote><h2 id="215-add-meaningful-context添加有意义的语境"><a class="markdownIt-Anchor" href="#215-add-meaningful-context添加有意义的语境"></a> 2.15 Add Meaningful Context(添加有意义的语境)</h2><p>用有良好命名的类、函数或名称空间来放置名称给读者提供语境，如果没这么做，给名称添加前缀。比如：firstName、lastName、street、houseNumber、city、state和zipcode的变量</p><ol><li>如果他们在一起，很明确是构成了一个地址；</li><li>如果只有state，那么很难猜测是地址的一部分；</li><li>可以添加前缀addrFirstName、addrLastName、addrState等，以此提供语境；</li><li>更好的方案是创建名为Address的类。</li></ol><h2 id="216-dont-add-gratutous-context不要添加没用的语境"><a class="markdownIt-Anchor" href="#216-dont-add-gratutous-context不要添加没用的语境"></a> 2.16 Don’t Add Gratutous Context(不要添加没用的语境)</h2><p>只要短名称足够清楚，就要比长名称好，别给名称添加不必要的语境。</p><p>比如：设若有一个名为“加油站豪华版”（Gas Station Deluxe）的应用，每个类不要添加GSD前缀。</p><h1 id="ch3-functions函数"><a class="markdownIt-Anchor" href="#ch3-functions函数"></a> Ch3 Functions(函数)</h1><h2 id="31-small短小"><a class="markdownIt-Anchor" href="#31-small短小"></a> 3.1 Small(短小)</h2><ul><li>if语句、else语句、while 语句等，其中的代码块应该只有一行。该行大抵应该是一个函数调用语句。这样不但能保持函数短小，而且，因为块内调用的函数拥有较具说明性的名称，从而增加了文档上的价值。</li><li>这也意味着函数不应该大到足以容纳嵌套结构。所以，<strong>函数的缩进层级不该多于一层或两层</strong>。当然，这样的函数易于阅读和理解。</li></ul><h2 id="32-do-one-thing只做一件事"><a class="markdownIt-Anchor" href="#32-do-one-thing只做一件事"></a> 3.2 Do One Thing(只做一件事)</h2><p>如果函数只是做了该函数名下同一抽象层上的步骤，则函数还是只做了一件事。</p><p>只做一件事的函数无法被合理地切分为多个区段。</p><h2 id="33-one-level-of-abstraction-per-function每个函数一个抽象层级"><a class="markdownIt-Anchor" href="#33-one-level-of-abstraction-per-function每个函数一个抽象层级"></a> 3.3 One Level of Abstraction per Function(每个函数一个抽象层级)</h2><p>要确保函数只做一件事，函数中的语句都要在同一抽象层级上。</p><p>自顶向下读代码：向下规则。让代码拥有自顶向下的阅读顺序，让每个函数后面都跟着位于下一抽象层级的函数，这样一来，在查看函数列表时，就能循抽象层级向下阅读了。</p><h2 id="34-switch-statementsswitch语句"><a class="markdownIt-Anchor" href="#34-switch-statementsswitch语句"></a> 3.4 Switch Statements(Switch语句)</h2><p>利用多态能够确保每个switch都埋藏在较低的抽象层级，而且永远不重复。</p><h2 id="35-use-descriptive-names使用描述性的名称"><a class="markdownIt-Anchor" href="#35-use-descriptive-names使用描述性的名称"></a> 3.5 Use Descriptive Names(使用描述性的名称)</h2><ul><li>沃德原则：“如果每个例程都让你感到深合己意，那就是整洁代码。” 函数越短小、功能越集中，就越便于取个好名字。</li><li>长而具有描述性的名称，比短而令人费解的名称好，比描述性的长注释好。</li><li>命名方式要保持一致。使用与模块名一脉相承的短语、名词和动词给函数命名。</li></ul><h2 id="36-function-arguments函数参数"><a class="markdownIt-Anchor" href="#36-function-arguments函数参数"></a> 3.6 Function Arguments(函数参数)</h2><p>最理想的参数数量是零（零参数函数），其次是一（单参数函数），再次是二（双参数函数），应尽量避免三（三参数函数）。有足够特殊的理由才能用三个以上参数（多参数函数）。</p><ul><li><p>标识参数：尽量不向函数传入布尔值；</p></li><li><p>参数对象：如果函数看来需要两个、三个或三个以上参数，就说明其中一些参数应该封装为类了。例如，下面两个声明的差别：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Circle <span class="title">makeCircle</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y, <span class="keyword">double</span> radius)</span></span>;</span><br><span class="line"><span class="function">Circle <span class="title">makeCircle</span><span class="params">(Point center, <span class="keyword">double</span> radius)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>参数列表：有时，我们想要向函数传入数量可变的参数。例如，String.format方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String.format(<span class="string">"s worked $.2f hours."</span>, name, hours);</span><br></pre></td></tr></table></figure><p>如果可变参数像上例中那样被同等对待，就和类型为List的单个参数没什么两样。这样一来，String.formate实则是二元函数。下列 String.format的声明也很明显是二元的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">format</span><span class="params">(String format, Object...args)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="37-have-no-side-effects无副作用"><a class="markdownIt-Anchor" href="#37-have-no-side-effects无副作用"></a> 3.7 Have No Side Effects(无副作用)</h2><p>函数承诺只做一件事，但还是会做其他被藏起来的事。有时，它会对自己类中的变量做出未能预期的改动。有时，它会把变量搞成向函数传递的参数或是系统全局变量。无论哪种情况，都是具有破坏性的，会导致古怪的时序性耦合及顺序依赖。</p><h2 id="38-command-query-separation分隔指令和询问"><a class="markdownIt-Anchor" href="#38-command-query-separation分隔指令和询问"></a> 3.8 Command Query Separation(分隔指令和询问)</h2><p>函数要么做什么事，要么回答什么事，但二者不可得兼。函数应该修改某对象的状态，或是返回该对象的有关信息。两样都干常会导致混乱。</p><ol><li>有两种指令与查询混杂的情况：查询某个状态，再根据状态执行操作；执行某个操作，返回该操作的执行情况。</li><li>最常见的就是函数执行某项操作，其布尔类型的返回值代表操作成功与否。</li></ol><h2 id="39-prefer-exceptions-to-returning-error-codes使用异常代替返回错误码"><a class="markdownIt-Anchor" href="#39-prefer-exceptions-to-returning-error-codes使用异常代替返回错误码"></a> 3.9 Prefer Exceptions to Returning Error Codes(使用异常代替返回错误码)</h2><h2 id="310-dont-repeat-yourself别重复自己"><a class="markdownIt-Anchor" href="#310-dont-repeat-yourself别重复自己"></a> 3.10 Don’t Repeat Yourself(别重复自己)</h2><p>重复可能是软件中一切邪恶的根源。许多原则与实践规则都是为控制与消除重复而创建。例如，</p><ul><li>考德（Codd）数据库范式都是为消灭数据重复而服务；</li><li>面向对象编程是如何将代码集中到基类，从而避免了冗余。</li><li>面向方面编程（Aspect Oriented Programming）、面向组件编程（Component Oriented Programming）多少也都是消除重复的一种策略。</li></ul><h2 id="311-structured-programming结构化编程"><a class="markdownIt-Anchor" href="#311-structured-programming结构化编程"></a> 3.11 Structured Programming(结构化编程)</h2><ul><li>Dijkstra认为，每个函数、函数中的每个代码块都应该有一个入口、一个出口。意味着在每个函数中只该有一个return语句，循环中不能有break 或continue 语句，而且不能有任何 goto语句。</li><li>但对于小函数，这些规则助益不大。只有在大函数中，这些规则才会有明显的好处。</li><li>所以，只要函数保持短小，偶尔出现的returm、break 或continue语句没有坏处，甚至还比单入单出原则更具有表达力。另外一方面，goto只在大函数中才有道理，所以应该尽量避免使用。</li></ul><h2 id="312-如何写出这样的函数"><a class="markdownIt-Anchor" href="#312-如何写出这样的函数"></a> 3.12 如何写出这样的函数</h2><p>并不是一开始就按照规则写函数，需要打磨。</p><h1 id="ch4-comments注释"><a class="markdownIt-Anchor" href="#ch4-comments注释"></a> Ch4 Comments(注释)</h1><ol><li>注释最多也就是一种必须的恶。若编程语言足够有表达力，或者我们长于用这些语言来表达意图，就不需要注释。</li><li>代码在发动，演化；注释不总是随之变动；而代码是唯一真正准确的信息来源。</li></ol><h2 id="41-comments-do-not-make-up-for-bad-code注释不能弥补糟糕的代码"><a class="markdownIt-Anchor" href="#41-comments-do-not-make-up-for-bad-code注释不能弥补糟糕的代码"></a> 4.1 Comments Do Not Make Up for Bad Code(注释不能弥补糟糕的代码)</h2><h2 id="42-explain-yourself-in-code用代码来阐述"><a class="markdownIt-Anchor" href="#42-explain-yourself-in-code用代码来阐述"></a> 4.2 Explain Yourself in Code(用代码来阐述)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式1</span></span><br><span class="line"><span class="comment">//Check to see if the employee is eligible for full benefits </span></span><br><span class="line"><span class="keyword">if</span> ((employee.flags &amp; HOURLY_FLAG) &amp;&amp; (employee.age &gt;<span class="number">65</span>))</span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="keyword">if</span> (employee.isEligibleForFu11Benefits())</span><br></pre></td></tr></table></figure><h2 id="43-good-comments好注释"><a class="markdownIt-Anchor" href="#43-good-comments好注释"></a> 4.3 Good Comments(好注释)</h2><p>有些注释是必须的，也是有利的。</p><ol><li><p>法律信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Copyright (C)2003,2004,2005 by Object Mentor, Inc. All rights reserved.</span></span><br><span class="line"><span class="comment">//Released under the terms of the GNU General Public License version 2 or later.</span></span><br></pre></td></tr></table></figure></li><li><p>提供信息的注释。以下注释解释了某个抽象方法的返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Returns an instance of the Responder being tested.</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Responder <span class="title">responderInstance</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>对意图的解释</p></li><li><p>阐释：有时，注释把某些晦涩难明的参数或返回值的意义翻译为某种可读形式，也会是有用的。这类注释在低层抽象中较为常见，也应该只出现在低层抽象中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompareTo</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WikiPagePath a=PathParser. parse(<span class="string">"PageA"</span>); </span><br><span class="line">    WikiPagePath ab=PathParser. parse(<span class="string">"PageA. PageB"</span>);</span><br><span class="line">    WikiPagePath b=PathParser. parse(<span class="string">"PageB"</span>); </span><br><span class="line">    WikiPagePath aa=PathParser. parse(<span class="string">"PageA. PageA"</span>); </span><br><span class="line">    WikiPagePath bb=PathParser. parse(<span class="string">"PageB. PageB"</span>);</span><br><span class="line">    WikiPagePath ba=PathParser. parse(<span class="string">"PageB. PageA"</span>); </span><br><span class="line">    </span><br><span class="line">    assertTrue(a. compareTo(a)==<span class="number">0</span>);<span class="comment">//a==a</span></span><br><span class="line">    assertTrue(a. compareTo(b)!=<span class="number">0</span>);<span class="comment">//a!=b </span></span><br><span class="line">    assertTrue(ab. compareTo(ab)==<span class="number">0</span>);<span class="comment">//ab==ab </span></span><br><span class="line">    assertTrue(a. compareTo(b)==-<span class="number">1</span>);<span class="comment">//a&lt;b </span></span><br><span class="line">    assertTrue(aa. compareTo(ab)==-<span class="number">1</span>);<span class="comment">//aa&lt; ab </span></span><br><span class="line">    assertTrue(ba. compareTo(bb)==-<span class="number">1</span>);<span class="comment">//ba&lt;bb </span></span><br><span class="line">    assertTrue(b. compareTo(a)==<span class="number">1</span>);<span class="comment">//b&gt;a </span></span><br><span class="line">    assertTrue(ab. compareTo(aa)==<span class="number">1</span>);<span class="comment">//ab&gt;aa </span></span><br><span class="line">    assertTrue(bb. compareTo (ba)==<span class="number">1</span>);<span class="comment">//bb&gt;ba</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>警示：有时，用于警告其他程序员会出现某种后果的注释也是有用的。</p></li><li><p>TODO注释：有时用//TODO形式在源代码中放置要做的工作列表。如今，大多数好IDE都提供了特别的手段来定位所有TODO注释，所以TODO注释变得多余。</p></li><li><p>放大(Amplification)：注释可以用来放大某种看来不合理之物的重要性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String listItemContent=match.group(<span class="number">3</span>).trim();</span><br><span class="line"><span class="comment">//the trim is real important. It removes the starting//spaces that could cause the itam to be recognized</span></span><br><span class="line"><span class="comment">//as another list.</span></span><br><span class="line"><span class="keyword">new</span> ListItemwidget(<span class="keyword">this</span>, listItemContent, <span class="keyword">this</span>.level+<span class="number">1</span>); </span><br><span class="line"><span class="keyword">return</span> buildList(text.substring(match. end()));</span><br></pre></td></tr></table></figure></li><li><p>公共API中的Javadoc</p></li></ol><h2 id="44-bad-comments坏注释"><a class="markdownIt-Anchor" href="#44-bad-comments坏注释"></a> 4.4 Bad Comments(坏注释)</h2><ol><li><p>Mumbling：自言自语的注释，往往是作者边写代码边整理思路时留下的。</p></li><li><p>多余的注释(Redundant Comments)：对足够小的函数不需要再做注释，但是一些关键业务函数加上“他是用来做什么”之类的注释。</p></li><li><p>误导性注释(Misleading Comments)</p></li><li><p>循规式注释(Mandated Comments)：每个函数都要有Javadoc 或每个变量都要有注释的规矩是愚蠢可笑的。</p></li><li><p>日志式注释(Journal Comments)：很久以前，在模块开始处创建并维护这些记录还算有道理。那时，我们还没有源代码控制系统可用。如今，这种冗长的记录只会让模块变得凌乱不堪，应当全部删除。</p></li><li><p>废话注释(Noise Comments)</p></li><li><p>可怕的废话(Scary Noise)：Javadoc 也可能是废话。</p></li><li><p>Don’t Use a Comment When You can Use a Function or a Variable.</p></li><li><p>位置标记(Position Markers)</p></li><li><p>括号后面的注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (...) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="comment">//while</span></span><br></pre></td></tr></table></figure></li><li><p>归属与署名：源代码控制系统非常善于记住是谁在何时添加了什么，源代码控制系统是这类信息最好的归属地。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Added by Rick*/</span></span><br></pre></td></tr></table></figure></li><li><p>注释掉的代码：20世纪60年代，曾经有那么一段时间，注释掉的代码可能有用，但现在源代码控制系统记住不要的代码。</p></li><li><p>HTML注释</p></li><li><p>非本地信息：假如你一定要写注释，请确保它描述了离它最近的代码，别在本地注释的上下文环境中给出系统级的信息。</p></li><li><p>信息过多：别在注释中添加有趣的历史性话题或者无关的细节描述。</p></li><li><p>不明显的联系：注释及其描述的代码之间的联系应该显而易见。</p></li><li><p>函数头：短函数不需要太多描述。为只做一件事的短函数选个好名字，通常要比写函数头注释要好。</p></li><li><p>非公共代码中的Javadoc</p></li></ol><h1 id="ch5-formatting格式"><a class="markdownIt-Anchor" href="#ch5-formatting格式"></a> Ch5 Formatting(格式)</h1><h2 id="51-vertical-formatting垂直格式"><a class="markdownIt-Anchor" href="#51-vertical-formatting垂直格式"></a> 5.1 Vertical Formatting(垂直格式)</h2><p>有可能用大多数为200行、最长500行的单个文件构造出色的系统。尽管这并非不可违背的原则，也应该乐于接受。短文件通常比长文件易于理解。</p><ol><li><p>Vertical Openness Between Concepts(间隔)：在封包声明、导入声明和每个函数之间，都有空白行隔开。每个空白行都是一条线索，标识出新的独立概念。</p></li><li><p>Vertical Density(靠近)：紧密相关的代码应该互相靠近</p></li><li><p>Vertical Distance(垂直距离)：</p><ul><li><p>变量声明：变量声明应尽可能靠近其使用位置。因为函数很短，本地变量应该在函数的顶部出现。循环中的控制变量应该总是在循环语句中声明。</p></li><li><p>实体变量应该在类的顶部声明。关于实体变量应该放在哪里，争论不断。在C++中，通常会采用所谓“剪刀原则”（scissors rule），所有实体变量都放在底部。而在Java中，惯例是放在类的顶部。</p><blockquote><p>关于“剪刀原则”较为确切的解释：在类的头文件中，公共部分放在前面，私有部分放到后面，这样就可以用剪刀将文件一分为二，上半部分是该类的可用部分。</p></blockquote></li><li><p>相关函数：若某个函数调用了另外一个，就应该把它们放到一起，而且<strong>调用者应该尽可能放在被调用者上面</strong>。</p></li><li><p>概念相关：概念相关的代码应该放到一起。相关性越强，彼此之间的距离就该越短。这些函数有着极强的概念相关性，因为他们拥有共同的命名模式，执行同一基础任务的不同变种。互相调用是第二位的。即便没有互相调用，也应该放在一起。</p></li></ul></li></ol><h2 id="52-horizontal-formatting横向格式"><a class="markdownIt-Anchor" href="#52-horizontal-formatting横向格式"></a> 5.2 Horizontal Formatting(横向格式)</h2><ul><li><p>尽力保持代码行短小。死守80个字符的上限有点僵化，不反对代码行长度达到100个字符或120个字符。</p></li><li><p>无需拖动滚动条到右边的原则。但近年来显示器越来越宽，而年轻程序员又能将显示字符缩小到如此程度，屏幕上甚至能容纳200个字符的宽度。作者的上限是<strong>120</strong>个字符。</p></li></ul><ol><li><p>Horizontal Openness and Density(区隔与靠近)：使用空格字符将彼此紧密相关的事物连接到一起，也用空格字符把相关性较弱的事物分隔开。请看以下函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Func</span><span class="params">(String line)</span></span>&#123;<span class="comment">//不在函数名和左圆括号之间加空格,是函数与其参数密切相关；把参数隔开，是参数互相分离的</span></span><br><span class="line">lineCount++;</span><br><span class="line">    <span class="keyword">int</span> lineSize = line.length(); <span class="comment">//在赋值操作符周围加上空格字符，分隔表达式左边、右边</span></span><br><span class="line">    (-b + c) / (<span class="number">2</span>*a);<span class="comment">//空格表示运算顺序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>水平对齐：汇编语言程序使用水平对齐来强调某些程序结构，但是C、C++、Java不需要。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>    intNumber;</span><br><span class="line"><span class="keyword">float</span>  floatNumber;</span><br><span class="line"><span class="keyword">double</span> doubleNumber;</span><br></pre></td></tr></table></figure></li><li><p>缩进：在短小的if 语句、while循环或小函数中不要违反缩进规则。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...) &#123;<span class="keyword">return</span> ;&#125;</span><br></pre></td></tr></table></figure></li><li><p>空范围：while或for语句的语句体为空，尽量不使用。如果无法避免，就确保空范围体的缩进，用括号包围起来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式1</span></span><br><span class="line"><span class="keyword">while</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="keyword">while</span> (...)</span><br><span class="line">;</span><br></pre></td></tr></table></figure></li></ol><h2 id="53-team-rules团队规则"><a class="markdownIt-Anchor" href="#53-team-rules团队规则"></a> 5.3 Team Rules(团队规则)</h2><h1 id="ch6-objects-and-data-structures对象和数据结构"><a class="markdownIt-Anchor" href="#ch6-objects-and-data-structures对象和数据结构"></a> Ch6 Objects and Data Structures(对象和数据结构)</h1><h2 id="61-data-abstraction数据抽象"><a class="markdownIt-Anchor" href="#61-data-abstraction数据抽象"></a> 6.1 Data Abstraction(数据抽象)</h2><p>数据本体是否一定要隐藏起来，也要视使用场合而定；公共变量存在的原因就是其他类总会有存取他的需要。</p><p>不要乱加取值器和赋值器而曝露其内部结构。</p><h2 id="62-dataobjects-anti-symmetrey数据-对象的反对称性"><a class="markdownIt-Anchor" href="#62-dataobjects-anti-symmetrey数据-对象的反对称性"></a> 6.2 Data/Objects Anti-Symmetrey(数据、对象的反对称性)</h2><p>对象把数据隐藏于抽象之后，曝露操作数据的函数。数据结构曝露其数据，没有提供有意义的函数。</p><h2 id="63-the-law-of-demeter得墨忒耳律"><a class="markdownIt-Anchor" href="#63-the-law-of-demeter得墨忒耳律"></a> * 6.3 The Law of Demeter(得墨忒耳律)</h2><p>著名的得墨忒耳律（The Law of Demeter）认为，模块不应了解它所操作对象的内部情形。<br>更准确地说，得墨忒耳律认为，类C的方法f只应该调用以下对象的方法：</p><ul><li>C</li><li>由f创建的对象；</li><li>作为参数传递给f的对象；</li><li>由C的实体变量持有的对象。</li></ul><p>方法不应调用由任何函数返回的对象的方法。</p><h2 id="64-data-transfer-objects数据传送对象"><a class="markdownIt-Anchor" href="#64-data-transfer-objects数据传送对象"></a> 6.4 Data Transfer Objects(数据传送对象)</h2><p>最为精练的数据结构，是一个只有公共变量、没有函数的类。这种数据结构有时被称为数据传送对象，或DTO（Data Transfer Objects）。DTO是非常有用的结构，尤其是在与数据库通信、或解析套接字传递的消息之类场景中。在应用程序代码里一系列将原始数据转换为数据库的翻译过程中，它们往往是排头兵。</p><h1 id="ch7-error-handling错误处理"><a class="markdownIt-Anchor" href="#ch7-error-handling错误处理"></a> * Ch7 Error Handling(错误处理)</h1><p>错误处理很重要，但如果它搞乱了代码逻辑，就是错误的做法。</p><h2 id="71-使用异常而非返回码"><a class="markdownIt-Anchor" href="#71-使用异常而非返回码"></a> 7.1 使用异常而非返回码</h2><h2 id="72-write-your-try-catch-finally-statement-first"><a class="markdownIt-Anchor" href="#72-write-your-try-catch-finally-statement-first"></a> 7.2 Write Your Try-Catch-Finally Statement First</h2><h2 id="73-use-unchecked-exceptions使用不可控异常"><a class="markdownIt-Anchor" href="#73-use-unchecked-exceptions使用不可控异常"></a> 7.3 Use Unchecked Exceptions(使用不可控异常)</h2><p>可控异常的代价就是违反开放/闭合原则。如果你在方法中抛出可控异常，而catch 语句在三个层级之上，你就得在catch 语句和抛出异常处之间的每个方法签名中声明该异常。这意味着对软件中较低层级的修改，都将波及较高层级的签名。修改好的模块必须重新构建、发布，即便它们自身所关注的任何东西都没改动过。</p><h2 id="74-provide-context-with-exceptions给出异常发生的环境说明"><a class="markdownIt-Anchor" href="#74-provide-context-with-exceptions给出异常发生的环境说明"></a> 7.4 Provide Context with Exceptions(给出异常发生的环境说明)</h2><ul><li>抛出的每个异常，都应当提供足够的环境说明，以便判断错误的来源和处所。在Java中，你可以从任何异常里得到堆栈踪迹（stack trace）；然而，堆栈踪迹却无法告诉你该失败操作的初衷。</li><li>应创建信息充分的错误消息，并和异常一起传递出去。在消息中，包括失败的操作和失败类型。如果你的应用程序有日志系统，传递足够的信息给catch块，并记录下来。</li></ul><h2 id="75-define-exception-classes-in-terms-of-a-callers-needs依照调用者需要定义异常类"><a class="markdownIt-Anchor" href="#75-define-exception-classes-in-terms-of-a-callers-needs依照调用者需要定义异常类"></a> 7.5 Define Exception Classes in Terms of a Caller’s Needs(依照调用者需要定义异常类)</h2><p>对错误分类有很多方式。可以依其来源分类：是来目组件还是其他地方？或依其类型分类：是设备错误、网络错误还是编程错误？不过，当我们在应用程序中定义异常类时，最重要的考虑应该是他们如何被捕获。</p><h2 id="76-define-the-normal-flow定义常规流程"><a class="markdownIt-Anchor" href="#76-define-the-normal-flow定义常规流程"></a> 7.6 Define the Normal Flow(定义常规流程)</h2><h2 id="77-dont-return-null"><a class="markdownIt-Anchor" href="#77-dont-return-null"></a> 7.7 Don’t Return Null</h2><h2 id="78-dont-pass-null不传递null值"><a class="markdownIt-Anchor" href="#78-dont-pass-null不传递null值"></a> 7.8 Don’t Pass Null(不传递null值)</h2><h1 id="ch8-boundaries边界"><a class="markdownIt-Anchor" href="#ch8-boundaries边界"></a> * Ch8 Boundaries(边界)</h1><h2 id="81-using-third-party-code使用第三方代码"><a class="markdownIt-Anchor" href="#81-using-third-party-code使用第三方代码"></a> 8.1 Using Third-Party Code(使用第三方代码)</h2><p>第三方程序包和框架提供者追求普适性，这样就能在多个环境中工作，吸引广泛的用户。而使用者则想要集中满足特定需求的接口，这样会导致系统边界上出现问题。</p><h2 id="82-浏览和学习边界"><a class="markdownIt-Anchor" href="#82-浏览和学习边界"></a> 8.2 浏览和学习边界</h2><p>编写测试来浏览和理解第三方代码。</p><h1 id="ch9-unit-tests单元测试"><a class="markdownIt-Anchor" href="#ch9-unit-tests单元测试"></a> Ch9 Unit Tests(单元测试)</h1><h2 id="91-tdd三定律"><a class="markdownIt-Anchor" href="#91-tdd三定律"></a> 9.1 TDD三定律</h2><blockquote><p>TDD是<strong>测试驱动开发</strong>（Test-Driven Development）的英文简称，是敏捷开发中的一项核心实践和技术，也是一种设计方法论。TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。TDD虽是敏捷方法的核心实践，但不只适用于<a href="https://baike.baidu.com/item/XP/776028" target="_blank" rel="noopener">XP</a>（Extreme Programming），同样可以适用于其他开发方法和过程。</p></blockquote><p>三定律：</p><ol><li>在编写不能通过的单元测试前，不能编写生成代码；</li><li>只可编写刚好无法通过的单元测试，不能编译也算不通过；</li><li>只可编写刚好足以通过当前失败测试的生产代码。</li></ol><h2 id="92-keeping-tests-clean保持测试整洁"><a class="markdownIt-Anchor" href="#92-keeping-tests-clean保持测试整洁"></a> 9.2 Keeping Tests Clean(保持测试整洁)</h2><p>测试代码与生产代码一样重要。</p><p>测试能给软件带来各种好处，flexibilities(可扩展性)、relabilities(可靠性)等。</p><h2 id="93-clean-tests整洁的测试"><a class="markdownIt-Anchor" href="#93-clean-tests整洁的测试"></a> 9.3 Clean Tests(整洁的测试)</h2><h2 id="94-one-assert-per-test每个测试一个断言"><a class="markdownIt-Anchor" href="#94-one-assert-per-test每个测试一个断言"></a> 9.4 One Assert per Test(每个测试一个断言)</h2><ul><li>有流派认为，JUnit中每个测试函数都应该有且只有一个断言语句。</li><li>单个测试中的断言数量应该最小化。</li></ul><h2 id="95-first"><a class="markdownIt-Anchor" href="#95-first"></a> 9.5 F.I.R.S.T.</h2><ul><li>**快速（Fast）**测试应该够快。测试应该能快速运行。测试运行缓慢，你就不会想要频繁地运行它。如果你不频繁运行测试，就不能尽早发现问题，也无法轻易修正，从而也不能轻而易举地清理代码。最终，代码就会腐坏。</li><li>**独立（Independent）**测试应该相互独立。某个测试不应为下一个测试设定条件。你应该可以单独运行每个测试，及以任何顺序运行测试。当测试互相依赖时，头一个没通过就会导致一连串的测试失败，使问题诊断变得困难，隐藏了下级错误。</li><li>**可重复（Repeatable）**测试应当可在任何环境中重复通过。你应该能够在生产环境、质检环境中运行测试，也能够在无网络的列车上用笔记本电脑运行测试。如果测试不能在任意环境中重复，你就总会有个解释其失败的接口。当环境条件不具备时，你也会无法运行测试。</li><li>**自足验证（Self-Validating）**测试应该有布尔值输出。无论是通过或失败，你不应该查看日志文件来确认测试是否通过。你不应该手工对比两个不同文本文件来确认测试是否通过。如果测试不能自足验证，对失败的判断就会变得依赖主观，而运行测试也需要更长的手工操作时间。</li><li>**及时（Timely）**测试应及时编写。单元测试应该恰好在使其通过的生产代码之前编写。如果在编写生产代码之后编写测试，你会发现生产代码难以测试。你可能会认为某些生产代码本身难以测试。你可能不会去设计可测试的代码。</li></ul><h1 id="ch10-classes类"><a class="markdownIt-Anchor" href="#ch10-classes类"></a> Ch10 Classes(类)</h1><h2 id="101-class-organization类的组织"><a class="markdownIt-Anchor" href="#101-class-organization类的组织"></a> 10.1 Class Organization(类的组织)</h2><p>遵循标准的Java约定，类应该从一组变量列表开始。如果有公共静态常量，应该先出现。然后是私有静态变量，以及私有实体变量。很少会有公共变量。公共函数应跟在变量列表之后。我们喜欢把由某个公共函数调用的私有工具函数紧随在该公共函数后面。这符合了自顶向下原则，让程序读起来就像一篇报纸文章。</p><h2 id="102-class-should-be-small类应该短小"><a class="markdownIt-Anchor" href="#102-class-should-be-small类应该短小"></a> 10.2 Class Should Be Small!(类应该短小)</h2><p>对于函数，我们通过计算代码行数衡量大小。对于类，我们采用不同的衡量方法，计算权责（responsibility）。</p><ol><li><p>单一权责原则：一个类应该只有一个发生变化的原因。</p></li><li><p>内聚：</p><ul><li>类应该只有少量实体变量。类中的每个方法都应该操作一个或多个这种变量。通常而言，方法操作的变量越多，就越黏聚到类上。如果一个类中的每个变量都被每个方法所使用，则该类具有最大的内聚性。</li><li>一般来说，创建这种极大化内聚类是既不可取也不可能的；另一方面，我们希望内聚性保持在较高位置。内聚性高，意味着类中的方法和变量互相依赖、互相结合成一个逻辑整体。</li></ul></li><li><p>保持内聚性就会得到许多短小的类</p></li></ol><h2 id="103-organizing-for-change为了修改而组织"><a class="markdownIt-Anchor" href="#103-organizing-for-change为了修改而组织"></a> 10.3 Organizing for Change(为了修改而组织)</h2><blockquote><p>依赖倒置原则(DIP)：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</p></blockquote><p>DIP认为类应当依赖于抽象而不是依赖于具体细节。</p><h1 id="ch11-systems系统"><a class="markdownIt-Anchor" href="#ch11-systems系统"></a> * Ch11 Systems(系统)</h1><h2 id="111-separate-constructing-a-system-from-using-it将系统的构造与使用分开"><a class="markdownIt-Anchor" href="#111-separate-constructing-a-system-from-using-it将系统的构造与使用分开"></a> 11.1 Separate Constructing a System from Using It(将系统的构造与使用分开)</h2><ol><li>分解main</li><li>工厂</li><li>依赖注入</li></ol><h2 id="112-scaling-up扩容"><a class="markdownIt-Anchor" href="#112-scaling-up扩容"></a> 11.2 Scaling Up(扩容)</h2><h2 id="113-java-proxiesjava代理"><a class="markdownIt-Anchor" href="#113-java-proxiesjava代理"></a> 11.3 Java Proxies(Java代理)</h2><h2 id="114-pure-java-aop-frameworks纯java-aop框架"><a class="markdownIt-Anchor" href="#114-pure-java-aop-frameworks纯java-aop框架"></a> 11.4 Pure Java AOP Frameworks(纯Java AOP框架)</h2><h2 id="115-aspectj-aspectsaspectj的方面"><a class="markdownIt-Anchor" href="#115-aspectj-aspectsaspectj的方面"></a> 11.5 AspectJ Aspects(AspectJ的方面)</h2><h2 id="116-test-drive-the-system-architecture测试驱动系统框架"><a class="markdownIt-Anchor" href="#116-test-drive-the-system-architecture测试驱动系统框架"></a> 11.6 Test Drive the System Architecture(测试驱动系统框架)</h2><h2 id="117-optimize-decision-making优化决策"><a class="markdownIt-Anchor" href="#117-optimize-decision-making优化决策"></a> 11.7 Optimize Decision Making(优化决策)</h2><h1 id="ch12-emergence迭进"><a class="markdownIt-Anchor" href="#ch12-emergence迭进"></a> Ch12 Emergence(迭进)</h1><p>Kent Beck关于简单设计的四条规则：</p><ol><li>运行所有测试；</li><li>不可重复；</li><li>表达了程序员的意图；</li><li>尽可能减少类和方法的数量；</li></ol><p>以上规则按其重要程度排列。</p><h1 id="ch13-concurrency并发编程"><a class="markdownIt-Anchor" href="#ch13-concurrency并发编程"></a> * Ch13 Concurrency(并发编程)</h1><blockquote><p>“对象是过程的抽象。线程是调度的抽象。”   一James O Coplien</p></blockquote><h2 id="131-并发防御原则"><a class="markdownIt-Anchor" href="#131-并发防御原则"></a> 13.1 并发防御原则</h2><ol><li>单一权责原则：分离并发相关代码与其他代码</li><li>限制数据作用域：谨记数据封装；严格限制对可能被共享的数据的访问。</li><li>使用数据副本</li><li>线程尽可能独立：尝试将数据分解到可被独立线程（可能在不同处理器上）操作的独立子集。</li></ol><h1 id="ch14-successive-refinement逐步改进"><a class="markdownIt-Anchor" href="#ch14-successive-refinement逐步改进"></a> Ch14 Successive Refinement(逐步改进)</h1><h1 id="ch15-junit-internalsjunit内幕"><a class="markdownIt-Anchor" href="#ch15-junit-internalsjunit内幕"></a> * Ch15 JUnit Internals(JUnit内幕)</h1><h1 id="ch16-refactoring-serialdate重构-serialdate"><a class="markdownIt-Anchor" href="#ch16-refactoring-serialdate重构-serialdate"></a> * Ch16 Refactoring SerialDate(重构 SerialDate)</h1><h1 id="ch17-smells-and-heuristics味道与启发"><a class="markdownIt-Anchor" href="#ch17-smells-and-heuristics味道与启发"></a> * Ch17 Smells and Heuristics(味道与启发)</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="阅读" scheme="https://Dragonliu2022.github.io/categories/阅读/"/>
    
    
    <category term="IT书籍" scheme="https://Dragonliu2022.github.io/tags/IT书籍/"/>
    
    <category term="重构" scheme="https://Dragonliu2022.github.io/tags/重构/"/>
    
  </entry>
  
  <entry>
    <title>i南航自动打卡</title>
    <link href="https://dragonliu2022.github.io/2022/04/13/i%E5%8D%97%E8%88%AA%E8%87%AA%E5%8A%A8%E6%89%93%E5%8D%A1/"/>
    <id>https://dragonliu2022.github.io/2022/04/13/i%E5%8D%97%E8%88%AA%E8%87%AA%E5%8A%A8%E6%89%93%E5%8D%A1/</id>
    <published>2022-04-13T04:17:36.000Z</published>
    <updated>2022-05-28T02:29:46.927Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-引言"><a class="markdownIt-Anchor" href="#1-引言"></a> 1 引言</h1><p><strong>需求</strong>：每天的i南航打卡比较难受，想自动化处理此事。</p><p><strong>声明</strong>：学习与技术讨论，勿实操！！！</p><h1 id="2-解决"><a class="markdownIt-Anchor" href="#2-解决"></a> 2 解决</h1><p>解决思路主要用四种：</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:left">优点</th><th style="text-align:left">缺点</th></tr></thead><tbody><tr><td style="text-align:center">快捷指令</td><td style="text-align:left">1. 方便；<br>2. 打卡失败与否，提醒明显</td><td style="text-align:left">1. 只适用于iPhone和iPad；<br>2. 会上传cookie，安全性无法保障；<br>3. 由于是别人编写的快捷指令，更新受制于人。</td></tr><tr><td style="text-align:center">Curl指令</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:center">Post请求</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:center">selenium模拟</td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><ol><li><strong>编写快捷指令</strong></li><li></li></ol><h2 id="21-ios系统"><a class="markdownIt-Anchor" href="#21-ios系统"></a> 2.1  IOS系统</h2><p>iPhone和iPad可以使用快捷指令，体验感较好。</p><p>But最近i南航签到界面增加了字段，目前（2022年4月13日）打卡虽然可以成功，但是健康码是黄色的。快捷指令的作者当前未更新，自己不会改。🥦</p><p>(2022年4月14日)打卡恢复正常。</p><ul><li><p><a href="https://blog.cvvv.me/posts/a67c.html" target="_blank" rel="noopener">博客教程：使用快捷指令自动进行i·南航健康打卡</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1CY41137Af" target="_blank" rel="noopener">B站教程：【南航】【i南航打卡】iOS/iPadOS快捷指令i南航自动打卡教程</a></p></li></ul><h2 id="22-linux客户机或服务器"><a class="markdownIt-Anchor" href="#22-linux客户机或服务器"></a> 2.2 Linux客户机或服务器</h2><p>wood的项目：<a href="https://github.com/Wood1314/inuaa" target="_blank" rel="noopener">i南航校外自动打卡小工具</a></p><h2 id="23-windows待完成"><a class="markdownIt-Anchor" href="#23-windows待完成"></a> 2.3 Windows（待完成）</h2><p>上面wood的项目是通过Linux服务器运行脚本，邮件通知提醒打卡成功。</p><p>对脚本稍作修改，迁移到Windows上来，实现定时运行脚本+Windows自带的消息通知。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="未分类" scheme="https://Dragonliu2022.github.io/categories/未分类/"/>
    
    
    <category term="待补充" scheme="https://Dragonliu2022.github.io/tags/待补充/"/>
    
  </entry>
  
  <entry>
    <title>Linux操作手册</title>
    <link href="https://dragonliu2022.github.io/2022/04/13/Linux%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/"/>
    <id>https://dragonliu2022.github.io/2022/04/13/Linux%E6%93%8D%E4%BD%9C%E6%89%8B%E5%86%8C/</id>
    <published>2022-04-13T02:14:47.000Z</published>
    <updated>2022-04-13T04:08:07.035Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="1-命令"><a class="markdownIt-Anchor" href="#1-命令"></a> 1 命令</h1><h2 id="11-基本"><a class="markdownIt-Anchor" href="#11-基本"></a> 1.1 基本</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">touch file <span class="comment">#创建文件</span></span><br><span class="line">mkdir dir <span class="comment">#新建目录</span></span><br><span class="line">cp -r src target <span class="comment">#复制文件(夹)</span></span><br><span class="line">rm -rf dir <span class="comment">#强制删除文件(夹)</span></span><br><span class="line">mv src target <span class="comment">#移动或重命名文件(夹)</span></span><br><span class="line"><span class="built_in">cd</span> <span class="comment">#切换目录</span></span><br><span class="line"><span class="built_in">pwd</span> <span class="comment">#查看当前目录</span></span><br><span class="line">man &lt;command_name&gt; <span class="comment">#获得某个命令的说明和使用方式的详细介绍</span></span><br><span class="line">who am i <span class="comment">#查看用户</span></span><br><span class="line">su &lt;user&gt; <span class="comment">#可以切换到用户 user</span></span><br><span class="line">su - &lt;user&gt; <span class="comment">#切换用户，但是同时用户的环境变量和工作目录也会跟着改变成目标用户所对应的</span></span><br><span class="line">sudo adduser &lt;user&gt; <span class="comment">#新建用户</span></span><br><span class="line">groups &lt;user&gt; <span class="comment">#查看自己属于的用户组</span></span><br><span class="line">sudo usermod -G sudo &lt;user&gt; <span class="comment">#将用户添加到sudo用户组</span></span><br><span class="line">sudo deluser &lt;user&gt; --remove-home <span class="comment">#删除用户，参数是在删除用户时候会一并将该用户的工作目录一并删除</span></span><br><span class="line">sudo groupdel &lt;group&gt; <span class="comment">#删除用户组，倘若该群组中仍包括某些用户，则必须先删除这些用户后，才能删除群组</span></span><br><span class="line"><span class="comment"># 修改权限</span></span><br><span class="line">chmod 777 file <span class="comment">#读写执行rwx二进制位数分别是210，文件有三组固定的权限，拥有者，所属用户组，其他用户</span></span><br><span class="line">chmod gou-rw file <span class="comment">#g(group用户组)、o(others其他用户)、u(user用户)，+ - 表示增加和去掉相应的权限</span></span><br><span class="line">file &lt;file&gt; <span class="comment">#查看文件类型</span></span><br><span class="line"><span class="comment">#查看文件</span></span><br><span class="line">cat -n file <span class="comment">#参数是显示行号</span></span><br><span class="line">nl -b a file <span class="comment">#与上面一样</span></span><br><span class="line">nl -b t file <span class="comment">#只列出非空行，默认</span></span><br><span class="line">head/tail -n 1 file <span class="comment">#只看文件首部尾部一行</span></span><br><span class="line">head/tail -f file <span class="comment">#这个参数可以实现不停地读取某个文件的内容并显示，实现实时监视</span></span><br></pre></td></tr></table></figure><h2 id="12-压缩解压"><a class="markdownIt-Anchor" href="#12-压缩解压"></a> 1.2 压缩/解压</h2><h3 id="121-gzip"><a class="markdownIt-Anchor" href="#121-gzip"></a> 1.2.1 gzip</h3><ul><li><p>压缩后的格式为：*.gz</p></li><li><p>这种压缩方式不能保存原文件；且不能压缩目录</p></li><li><p>命令举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">压缩</span></span><br><span class="line">gzip file</span><br><span class="line"><span class="meta">#</span><span class="bash">解压</span></span><br><span class="line">gunzip file.gz</span><br></pre></td></tr></table></figure></li></ul><h3 id="122-tar"><a class="markdownIt-Anchor" href="#122-tar"></a> 1.2.2 tar</h3><ul><li><p>命令选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-z(gzip)      用gzip来压缩/解压缩文件</span><br><span class="line">-j(bzip2)     用bzip2来压缩/解压缩文件</span><br><span class="line">-v(verbose)   详细报告tar处理的文件信息</span><br><span class="line">-c(create)    创建新的档案文件</span><br><span class="line">-x(extract)   解压缩文件或目录</span><br><span class="line">-f(file)      使用档案文件或设备，这个选项通常是必选的。</span><br></pre></td></tr></table></figure></li><li><p>命令举例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">压缩</span></span><br><span class="line">tar -zvcf file.tar.gz file</span><br><span class="line">tar -jvcf file.tar.bz2 file</span><br><span class="line"><span class="meta">#</span><span class="bash">解压</span></span><br><span class="line">tar -zvxf file.tar.gz </span><br><span class="line">tar -jvxf file.tar.bz2</span><br></pre></td></tr></table></figure></li></ul><h3 id="123-zip"><a class="markdownIt-Anchor" href="#123-zip"></a> 1.2.3 zip</h3><ul><li><p>与gzip相比：1）可以压缩目录； 2）可以保留原文件</p></li><li><p>命令选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-r(recursive)    递归压缩目录内的所有文件和目录</span><br></pre></td></tr></table></figure></li><li><p>命令举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">压缩</span></span><br><span class="line">zip -r dir.zip dir</span><br><span class="line"><span class="meta">#</span><span class="bash">解压</span></span><br><span class="line">unzip dir.zip</span><br></pre></td></tr></table></figure></li></ul><h1 id="2-快捷键"><a class="markdownIt-Anchor" href="#2-快捷键"></a> 2 快捷键</h1><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>Ctrl+c</code></td><td style="text-align:center">强行终止当前程序</td></tr><tr><td style="text-align:center"><code>Ctrl+z</code></td><td style="text-align:center">将当前程序放到后台运行，恢复到前台为命令<code>fg</code></td></tr><tr><td style="text-align:center"><code>Ctrl+a</code></td><td style="text-align:center">将光标移至输入行头，相当于<code>Home</code>键</td></tr><tr><td style="text-align:center"><code>Ctrl+e</code></td><td style="text-align:center">将光标移至输入行末，相当于<code>End</code>键</td></tr><tr><td style="text-align:center"><code>Ctrl+k</code></td><td style="text-align:center">删除从光标所在位置到行末</td></tr><tr><td style="text-align:center"><code>Alt+Backspace</code></td><td style="text-align:center">向前删除一个单词</td></tr><tr><td style="text-align:center"><code>Shift+PgUp</code></td><td style="text-align:center">将终端显示向上滚动</td></tr><tr><td style="text-align:center"><code>Shift+PgDn</code></td><td style="text-align:center">将终端显示向下滚动</td></tr></tbody></table><h1 id="3-通配符"><a class="markdownIt-Anchor" href="#3-通配符"></a> 3 通配符</h1><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><code>*</code></td><td style="text-align:center">匹配 0 或多个字符</td></tr><tr><td style="text-align:center"><code>?</code></td><td style="text-align:center">匹配任意一个字符</td></tr><tr><td style="text-align:center"><code>[list]</code></td><td style="text-align:center">匹配 list 中的任意单一字符</td></tr><tr><td style="text-align:center"><code>[^list]</code></td><td style="text-align:center">匹配 除 list 中的任意单一字符以外的字符</td></tr><tr><td style="text-align:center"><code>[c1-c2]</code></td><td style="text-align:center">匹配 c1-c2 中的任意单一字符 如：[0-9][a-z]</td></tr><tr><td style="text-align:center"><code>{string1,string2,...}</code></td><td style="text-align:center">匹配 string1 或 string2 (或更多)其一字符串</td></tr><tr><td style="text-align:center"><code>{c1..c2}</code></td><td style="text-align:center">匹配 c1-c2 中全部字符 如{1…10}</td></tr></tbody></table><h1 id="4-目录结构"><a class="markdownIt-Anchor" href="#4-目录结构"></a> 4 目录结构</h1><img src="https://cdn.jsdelivr.net/gh/Dragonliu2018/FigureBed@master/img/4-1.png">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="环境与工具" scheme="https://Dragonliu2022.github.io/categories/环境与工具/"/>
    
    
  </entry>
  
</feed>
