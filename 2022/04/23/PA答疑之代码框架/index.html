<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000">
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top">
  
  
  <title>PA答疑之代码框架 | Dragon&#39;s Synthesis Blogs</title>
  <meta name="description" content="转载：NJU ICS Programming Assignment 代码分析 - NEMU   部分内容框架代码并不包含（如扩展的 Debug 宏），均为我为编码而添加的内容。采用 a_b 方式命名的多为原内容，采用 aB 方式命名的多为补充内容。由于此项目是 NJU ICS PA 的一部分，其中会包含与相关项目的互操作内容。  NEMU (NJU EMUlator) 是在 Linux 上的一个">
<meta property="og:type" content="article">
<meta property="og:title" content="PA答疑之代码框架">
<meta property="og:url" content="https://Dragonliu2022.github.io/2022/04/23/PA答疑之代码框架/index.html">
<meta property="og:site_name" content="Dragon Liu">
<meta property="og:description" content="转载：NJU ICS Programming Assignment 代码分析 - NEMU   部分内容框架代码并不包含（如扩展的 Debug 宏），均为我为编码而添加的内容。采用 a_b 方式命名的多为原内容，采用 aB 方式命名的多为补充内容。由于此项目是 NJU ICS PA 的一部分，其中会包含与相关项目的互操作内容。  NEMU (NJU EMUlator) 是在 Linux 上的一个">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2022-04-23T07:42:43.216Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PA答疑之代码框架">
<meta name="twitter:description" content="转载：NJU ICS Programming Assignment 代码分析 - NEMU   部分内容框架代码并不包含（如扩展的 Debug 宏），均为我为编码而添加的内容。采用 a_b 方式命名的多为原内容，采用 aB 方式命名的多为补充内容。由于此项目是 NJU ICS PA 的一部分，其中会包含与相关项目的互操作内容。  NEMU (NJU EMUlator) 是在 Linux 上的一个">
  <!-- Canonical links -->
  <link rel="canonical" href="https://Dragonliu2022.github.io/2022/04/23/PA答疑之代码框架/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Dragon Liu" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link href="//cdn.jsdelivr.net/npm/katex@0.9.0/dist/katex.min.css" rel="stylesheet">
  
  
  
  
</head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/dragonliu2018" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.png" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Dragon&#39;s Blogs</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Synthesis</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Nanjing, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/dragonliu2018" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</br>dragonliu2018@gmail.com</br>电脑端观看效果更佳！</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AI/">AI</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OS/">OS</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/大数据/">大数据</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/影视/">影视</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/未分类/">未分类</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/爬虫/">爬虫</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/环境与工具/">环境与工具</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计组/">计组</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/阅读/">阅读</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/音乐/">音乐</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CV/">CV</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IT书籍/">IT书籍</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/selenium/">selenium</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/书评/">书评</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/区块链/">区块链</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/待补充/">待补充</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/摘抄/">摘抄</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/深度学习/">深度学习</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/电影/">电影</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/电视剧/">电视剧</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/纪录片/">纪录片</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/重构/">重构</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/CV/" style="font-size: 13px;">CV</a> <a href="/tags/Git/" style="font-size: 13px;">Git</a> <a href="/tags/Hexo/" style="font-size: 13.6px;">Hexo</a> <a href="/tags/IT书籍/" style="font-size: 13px;">IT书籍</a> <a href="/tags/selenium/" style="font-size: 13.2px;">selenium</a> <a href="/tags/书评/" style="font-size: 13.8px;">书评</a> <a href="/tags/区块链/" style="font-size: 13px;">区块链</a> <a href="/tags/待补充/" style="font-size: 14px;">待补充</a> <a href="/tags/摘抄/" style="font-size: 13.2px;">摘抄</a> <a href="/tags/深度学习/" style="font-size: 13.2px;">深度学习</a> <a href="/tags/电影/" style="font-size: 13.4px;">电影</a> <a href="/tags/电视剧/" style="font-size: 13px;">电视剧</a> <a href="/tags/纪录片/" style="font-size: 13px;">纪录片</a> <a href="/tags/重构/" style="font-size: 13px;">重构</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/计组/">计组</a>
              </p>
              <p class="item-title">
                <a href="/2022/06/05/Lab3实验总结/" class="title">Lab3实验总结</a>
              </p>
              <p class="item-date">
                <time datetime="2022-06-05T12:52:07.000Z" itemprop="datePublished">2022-06-05</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/环境与工具/">环境与工具</a>
              </p>
              <p class="item-title">
                <a href="/2022/05/27/gdb调试/" class="title">gdb调试</a>
              </p>
              <p class="item-date">
                <time datetime="2022-05-27T05:24:18.000Z" itemprop="datePublished">2022-05-27</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/计组/">计组</a>
              </p>
              <p class="item-title">
                <a href="/2022/05/27/PA答疑之a4指令码报错/" class="title">PA答疑之a4指令码报错</a>
              </p>
              <p class="item-date">
                <time datetime="2022-05-27T05:06:36.000Z" itemprop="datePublished">2022-05-27</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/计组/">计组</a>
              </p>
              <p class="item-title">
                <a href="/2022/05/26/64位Ubuntu运行32位程序/" class="title">64位Ubuntu运行或调试32位程序</a>
              </p>
              <p class="item-date">
                <time datetime="2022-05-26T05:20:32.000Z" itemprop="datePublished">2022-05-26</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/AI/">AI</a>
              </p>
              <p class="item-title">
                <a href="/2022/05/16/MLP的pytorch实现/" class="title">MLP的pytorch实现</a>
              </p>
              <p class="item-date">
                <time datetime="2022-05-16T13:40:45.000Z" itemprop="datePublished">2022-05-16</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse   in  " id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-框架代码结构"><span class="toc-number">1.</span> <span class="toc-text"> 1 框架代码结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-include"><span class="toc-number">2.</span> <span class="toc-text"> 2 include/</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-nemuh"><span class="toc-number">2.1.</span> <span class="toc-text"> 2.1 nemu.h</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-macroh"><span class="toc-number">2.2.</span> <span class="toc-text"> 2.2 macro.h</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-commonh"><span class="toc-number">2.3.</span> <span class="toc-text"> 2.3 common.h</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-debugh"><span class="toc-number">2.4.</span> <span class="toc-text"> 2.4 debug.h</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-cpu"><span class="toc-number">2.5.</span> <span class="toc-text"> 2.5 cpu/</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#251-regh"><span class="toc-number">2.5.1.</span> <span class="toc-text"> 2.5.1 reg.h</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#结构体-cpu_state"><span class="toc-number">2.5.1.1.</span> <span class="toc-text"> 结构体 CPU_state</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#枚举"><span class="toc-number">2.5.1.2.</span> <span class="toc-text"> 枚举</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#252-decodeh"><span class="toc-number">2.5.2.</span> <span class="toc-text"> 2.5.2 decode.h</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#结构体-operand"><span class="toc-number">2.5.2.1.</span> <span class="toc-text"> 结构体 Operand</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#结构体-decodeinfo"><span class="toc-number">2.5.2.2.</span> <span class="toc-text"> 结构体 DecodeInfo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#结构体-modr_m"><span class="toc-number">2.5.2.3.</span> <span class="toc-text"> 结构体 ModR_M</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#结构体-sib"><span class="toc-number">2.5.2.4.</span> <span class="toc-text"> 结构体 SIB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#枚举-2"><span class="toc-number">2.5.2.5.</span> <span class="toc-text"> 枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#宏-make_dhelper-与函数族-decode_name"><span class="toc-number">2.5.2.6.</span> <span class="toc-text"> 宏 make_DHelper 与函数族 decode_name</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#253-exech"><span class="toc-number">2.5.3.</span> <span class="toc-text"> 2.5.3 exec.h</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#函数-instr_fetch"><span class="toc-number">2.5.3.1.</span> <span class="toc-text"> 函数 instr_fetch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#宏-make_ehelper-与-函数族-exec_name"><span class="toc-number">2.5.3.2.</span> <span class="toc-text"> 宏 make_EHelper 与 函数族 exec_name</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#254-reloph"><span class="toc-number">2.5.4.</span> <span class="toc-text"> 2.5.4 relop.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#255-cch"><span class="toc-number">2.5.5.</span> <span class="toc-text"> 2.5.5 cc.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#256-rtlh"><span class="toc-number">2.5.6.</span> <span class="toc-text"> 2.5.6 rtl.h</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rtl-基本指令"><span class="toc-number">2.5.6.1.</span> <span class="toc-text"> RTL 基本指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rtl-伪指令"><span class="toc-number">2.5.6.2.</span> <span class="toc-text"> RTL 伪指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#257-rtl-wrapperh"><span class="toc-number">2.5.7.</span> <span class="toc-text"> 2.5.7 rtl-wrapper.h</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-memory"><span class="toc-number">2.6.</span> <span class="toc-text"> 2.6 memory/</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#261-memoryh"><span class="toc-number">2.6.1.</span> <span class="toc-text"> 2.6.1 memory.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#262-mmuh"><span class="toc-number">2.6.2.</span> <span class="toc-text"> 2.6.2 mmu.h</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#结构体-gatedesc"><span class="toc-number">2.6.2.1.</span> <span class="toc-text"> 结构体 GateDesc</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-device"><span class="toc-number">2.7.</span> <span class="toc-text"> 2.7 device/</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#271-mmioh"><span class="toc-number">2.7.1.</span> <span class="toc-text"> 2.7.1 mmio.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#272-port-ioh"><span class="toc-number">2.7.2.</span> <span class="toc-text"> 2.7.2 port-io.h</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-monitor"><span class="toc-number">2.8.</span> <span class="toc-text"> 2.8 monitor/</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#281-exprh"><span class="toc-number">2.8.1.</span> <span class="toc-text"> 2.8.1 expr.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#282-monitorh"><span class="toc-number">2.8.2.</span> <span class="toc-text"> 2.8.2 monitor.h</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#283-watchpointh"><span class="toc-number">2.8.3.</span> <span class="toc-text"> 2.8.3 watchpoint.h</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#结构体-wp"><span class="toc-number">2.8.3.1.</span> <span class="toc-text"> 结构体 WP</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-util"><span class="toc-number">2.9.</span> <span class="toc-text"> 2.9 util/</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#291-c_oph"><span class="toc-number">2.9.1.</span> <span class="toc-text"> 2.9.1 c_op.h</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-src"><span class="toc-number">3.</span> <span class="toc-text"> 3 src/</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mainc"><span class="toc-number">3.1.</span> <span class="toc-text"> main.c</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cpu"><span class="toc-number">3.2.</span> <span class="toc-text"> cpu/</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#regc"><span class="toc-number">3.2.1.</span> <span class="toc-text"> reg.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#intrc"><span class="toc-number">3.2.2.</span> <span class="toc-text"> intr.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#decode"><span class="toc-number">3.2.3.</span> <span class="toc-text"> decode/</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#decodec"><span class="toc-number">3.2.3.1.</span> <span class="toc-text"> decode.c</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#宏-make_dophelper-与函数族-decode_op_name"><span class="toc-number">3.2.3.1.1.</span> <span class="toc-text"> 宏 make_DopHelper 与函数族 decode_op_name</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#modrmc"><span class="toc-number">3.2.3.2.</span> <span class="toc-text"> modrm.c</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exec"><span class="toc-number">3.2.4.</span> <span class="toc-text"> exec/</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ccc"><span class="toc-number">3.2.4.1.</span> <span class="toc-text"> cc.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#relopc"><span class="toc-number">3.2.4.2.</span> <span class="toc-text"> relop.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#all-instrh"><span class="toc-number">3.2.4.3.</span> <span class="toc-text"> all-instr.h</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#arithc"><span class="toc-number">3.2.4.4.</span> <span class="toc-text"> arith.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#controlc"><span class="toc-number">3.2.4.5.</span> <span class="toc-text"> control.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#data-movc"><span class="toc-number">3.2.4.6.</span> <span class="toc-text"> data-mov.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#logicc"><span class="toc-number">3.2.4.7.</span> <span class="toc-text"> logic.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#specialc"><span class="toc-number">3.2.4.8.</span> <span class="toc-text"> special.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#prefixc"><span class="toc-number">3.2.4.9.</span> <span class="toc-text"> prefix.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#systemc"><span class="toc-number">3.2.4.10.</span> <span class="toc-text"> system.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#execc"><span class="toc-number">3.2.4.11.</span> <span class="toc-text"> exec.c</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#结构体-opcode_entry"><span class="toc-number">3.2.4.11.1.</span> <span class="toc-text"> 结构体 opcode_entry</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#数组-opcode_table"><span class="toc-number">3.2.4.11.2.</span> <span class="toc-text"> 数组 opcode_table</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#函数-exec_wrapper"><span class="toc-number">3.2.4.11.3.</span> <span class="toc-text"> 函数 exec_wrapper</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#函数-exec_real"><span class="toc-number">3.2.4.11.4.</span> <span class="toc-text"> 函数 exec_real</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#函数-set_width"><span class="toc-number">3.2.4.11.5.</span> <span class="toc-text"> 函数 set_width</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#函数-idex"><span class="toc-number">3.2.4.11.6.</span> <span class="toc-text"> 函数 idex</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#函数-update_eip"><span class="toc-number">3.2.4.11.7.</span> <span class="toc-text"> 函数 update_eip</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#memory"><span class="toc-number">3.3.</span> <span class="toc-text"> memory/</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#memoryc"><span class="toc-number">3.3.1.</span> <span class="toc-text"> memory.c</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#device"><span class="toc-number">3.4.</span> <span class="toc-text"> device/</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#io"><span class="toc-number">3.4.1.</span> <span class="toc-text"> io/</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mmioc"><span class="toc-number">3.4.1.1.</span> <span class="toc-text"> mmio.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#port-ioc"><span class="toc-number">3.4.1.2.</span> <span class="toc-text"> port-io.c</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#devicec"><span class="toc-number">3.4.2.</span> <span class="toc-text"> device.c</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#函数-init_device"><span class="toc-number">3.4.2.1.</span> <span class="toc-text"> 函数 init_device</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数-device_update"><span class="toc-number">3.4.2.2.</span> <span class="toc-text"> 函数 device_update</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#serialc"><span class="toc-number">3.4.3.</span> <span class="toc-text"> serial.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#timerc"><span class="toc-number">3.4.4.</span> <span class="toc-text"> timer.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#keyboardc"><span class="toc-number">3.4.5.</span> <span class="toc-text"> keyboard.c</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vgac"><span class="toc-number">3.4.6.</span> <span class="toc-text"> vga.c</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#monitor"><span class="toc-number">3.5.</span> <span class="toc-text"> monitor/</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#monitorc"><span class="toc-number">3.5.1.</span> <span class="toc-text"> monitor.c</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#函数-init_monitor"><span class="toc-number">3.5.1.1.</span> <span class="toc-text"> 函数 init_monitor</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cpu-execc"><span class="toc-number">3.5.2.</span> <span class="toc-text"> cpu-exec.c</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#函数-cpu_exec"><span class="toc-number">3.5.2.1.</span> <span class="toc-text"> 函数 cpu_exec</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#debug"><span class="toc-number">3.5.3.</span> <span class="toc-text"> debug/</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#watchpointc"><span class="toc-number">3.5.3.1.</span> <span class="toc-text"> watchpoint.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exprc"><span class="toc-number">3.5.3.2.</span> <span class="toc-text"> expr.c</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#常量"><span class="toc-number">3.5.3.2.1.</span> <span class="toc-text"> 常量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#数组-rules"><span class="toc-number">3.5.3.2.2.</span> <span class="toc-text"> 数组 rules</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#数组-re"><span class="toc-number">3.5.3.2.3.</span> <span class="toc-text"> 数组 re</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#函数-init_regex"><span class="toc-number">3.5.3.2.4.</span> <span class="toc-text"> 函数 init_regex</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#结构体-token"><span class="toc-number">3.5.3.2.5.</span> <span class="toc-text"> 结构体 Token</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#函数-make_token"><span class="toc-number">3.5.3.2.6.</span> <span class="toc-text"> 函数 make_token</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#函数-evalwithtoken"><span class="toc-number">3.5.3.2.7.</span> <span class="toc-text"> 函数 evalWithToken</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#函数-expr"><span class="toc-number">3.5.3.2.8.</span> <span class="toc-text"> 函数 expr</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uic"><span class="toc-number">3.5.3.3.</span> <span class="toc-text"> ui.c</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#函数族-fc2color"><span class="toc-number">3.5.3.3.1.</span> <span class="toc-text"> 函数族 fc2color</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#函数族-cmd_item"><span class="toc-number">3.5.3.3.2.</span> <span class="toc-text"> 函数族 cmd_item</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#数组-cmd_table"><span class="toc-number">3.5.3.3.3.</span> <span class="toc-text"> 数组 cmd_table</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#函数-ui_mainloop"><span class="toc-number">3.5.3.3.4.</span> <span class="toc-text"> 函数 ui_mainloop</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#diff-test"><span class="toc-number">3.5.4.</span> <span class="toc-text"> diff-test/</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#diff-testh"><span class="toc-number">3.5.4.1.</span> <span class="toc-text"> diff-test.h</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#refc"><span class="toc-number">3.5.4.2.</span> <span class="toc-text"> ref.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#diff-testc"><span class="toc-number">3.5.4.3.</span> <span class="toc-text"> diff-test.c</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#函数-init_difftest"><span class="toc-number">3.5.4.3.1.</span> <span class="toc-text"> 函数 init_difftest</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#函数-difftest_step"><span class="toc-number">3.5.4.3.2.</span> <span class="toc-text"> 函数 difftest_step</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#misc"><span class="toc-number">3.6.</span> <span class="toc-text"> misc/</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#logoc"><span class="toc-number">3.6.1.</span> <span class="toc-text"> logo.c</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-tools"><span class="toc-number">4.</span> <span class="toc-text"> 4 tools/</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#gen-exprc"><span class="toc-number">4.1.</span> <span class="toc-text"> gen-expr.c</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qemu-diff"><span class="toc-number">4.2.</span> <span class="toc-text"> qemu-diff</span></a></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-PA答疑之代码框架" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      PA答疑之代码框架
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2022/04/23/PA答疑之代码框架/" class="article-date">
	  <time datetime="2022-04-23T07:21:37.000Z" itemprop="datePublished">2022-04-23</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/计组/">计组</a>
  </span>

        

        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2022/04/23/PA答疑之代码框架/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 10.6k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 42(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <blockquote>
<p><strong>转载</strong>：<a href="http://www.stardustdl.top/posts/learning/nju-icspa-analytics-nemu/" target="_blank" rel="noopener">NJU ICS Programming Assignment 代码分析 - NEMU</a></p>
</blockquote>
<blockquote>
<p>部分内容框架代码并不包含（如扩展的 Debug 宏），均为我为编码而添加的内容。采用 <code>a_b</code> 方式命名的多为原内容，采用 <code>aB</code> 方式命名的多为补充内容。由于此项目是 NJU ICS PA 的一部分，其中会包含与相关项目的互操作内容。</p>
</blockquote>
<p>NEMU (NJU EMUlator) 是在 Linux 上的一个 n86（x86 子集）模拟器，模拟了基本计算机系统的功能（内存，CPU等）。包含了：</p>
<ul>
<li>内存</li>
<li>CPU，寄存器</li>
<li>调试器（监视器）</li>
</ul>
<h1 id="1-框架代码结构"><a class="markdownIt-Anchor" href="#1-框架代码结构"></a> 1 框架代码结构</h1>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nanos-lite/</span><br><span class="line">navy-apps/</span><br><span class="line">nexus-am/</span><br><span class="line">nemu/               <span class="comment"># NEMU 项目</span></span><br><span class="line">    build/          <span class="comment"># 构建输出文件夹</span></span><br><span class="line">        nemu        <span class="comment"># NEMU 主程序（可执行文件）</span></span><br><span class="line">    include/        <span class="comment"># 头文件</span></span><br><span class="line">    src/            <span class="comment"># 源码文件</span></span><br><span class="line">    tools/          <span class="comment"># 工具文件</span></span><br><span class="line">    runall.sh       <span class="comment"># 测试 AM cputest 测试集 （nexus-am/tests/cputest）</span></span><br><span class="line">    Makefile        <span class="comment"># NEMU 构建命令</span></span><br><span class="line">    Makefile.git    <span class="comment"># NEMU Git 记录命令</span></span><br></pre></td></tr></table></figure>
<p>nemu部分：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">nemu</span><br><span class="line">├── include                         <span class="comment">#   存放全局使用的头文件 </span></span><br><span class="line">|    ├── common.h                    <span class="comment">#   公用的头文件 </span></span><br><span class="line">|    ├── cpu</span><br><span class="line">|    |    ├── decode.h                <span class="comment">#   译码相关</span></span><br><span class="line">|    |    ├── exec.h                  <span class="comment">#   执行相关 </span></span><br><span class="line">|    |    ├── reg.h                   <span class="comment">#   寄存器结构体的定义 </span></span><br><span class="line">|    |    └── rtl.h                   <span class="comment">#   RTL指令 </span></span><br><span class="line">|    ├── debug.h                     <span class="comment">#   一些方便调试用的宏 </span></span><br><span class="line">|    ├── device                      <span class="comment">#   设备相关 </span></span><br><span class="line">|    ├── macro.h                     <span class="comment">#   一些方便的宏定义 </span></span><br><span class="line">|    ├── memory                      <span class="comment">#   访问内存相关 </span></span><br><span class="line">|    ├── monitor</span><br><span class="line">|    |    ├── expr.h</span><br><span class="line">|    |    ├── monitor.h</span><br><span class="line">|    |    └── watchpoint.h            <span class="comment">#   监视点相关 </span></span><br><span class="line">|    └── nemu.h</span><br><span class="line">├── Makefile                        <span class="comment">#   指示NEMU的编译和链接 </span></span><br><span class="line">├── Makefile.git                    <span class="comment">#   git版本控制相关 </span></span><br><span class="line">├── runall.sh                       <span class="comment">#   一键测试脚本 </span></span><br><span class="line">└── src                             <span class="comment">#   源文件</span></span><br><span class="line">    ├── cpu</span><br><span class="line">    |    ├── decode                  <span class="comment">#   译码相关</span></span><br><span class="line">    |    ├── <span class="built_in">exec</span>                    <span class="comment">#   执行相关 </span></span><br><span class="line">    |    ├── intr.c                  <span class="comment">#   中断处理相关</span></span><br><span class="line">    |    └── reg.c                   <span class="comment">#   寄存器相关    </span></span><br><span class="line">    ├── device                      <span class="comment">#   设备相关</span></span><br><span class="line">    ├── main.c                        </span><br><span class="line">    ├── memory</span><br><span class="line">    |    └── memory.c</span><br><span class="line">    ├── misc</span><br><span class="line">    |    └── logo.c                  <span class="comment">#   "i386"的logo</span></span><br><span class="line">    └── monitor</span><br><span class="line">        ├── cpu-exec.c              <span class="comment">#   指令执行的主循环</span></span><br><span class="line">        ├── diff-test</span><br><span class="line">        ├── debug                   <span class="comment">#   简易调试器相关</span></span><br><span class="line">        |    ├── expr.c              <span class="comment">#   表达式求值的实现</span></span><br><span class="line">        |    ├── ui.c                <span class="comment">#   用户界面相关    </span></span><br><span class="line">        |    └── watchpoint.c        <span class="comment">#   监视点的实现</span></span><br><span class="line">        └── monitor.c</span><br></pre></td></tr></table></figure>
<h1 id="2-include"><a class="markdownIt-Anchor" href="#2-include"></a> 2 include/</h1>
<h2 id="21-nemuh"><a class="markdownIt-Anchor" href="#21-nemuh"></a> 2.1 nemu.h</h2>
<p>基础头文件。包含了 <code>commom.h</code>，<code>memory/memory.h</code>，<code>cpu/reg.h</code></p>
<h2 id="22-macroh"><a class="markdownIt-Anchor" href="#22-macroh"></a> 2.2 macro.h</h2>
<p>定义了一些字符串连接宏 <code>concat</code> 等</p>
<h2 id="23-commonh"><a class="markdownIt-Anchor" href="#23-commonh"></a> 2.3 common.h</h2>
<p>定义了一些类型别名。</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型别名</th>
<th style="text-align:center">原类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>rtlreg_t</code></td>
<td style="text-align:center"><code>uint32_t</code></td>
<td style="text-align:center">RTL寄存器</td>
</tr>
<tr>
<td style="text-align:center"><code>vaddr_t</code></td>
<td style="text-align:center"><code>uint32_t</code></td>
<td style="text-align:center">虚拟地址</td>
</tr>
<tr>
<td style="text-align:center"><code>paddr_t</code></td>
<td style="text-align:center"><code>uint32_t</code></td>
<td style="text-align:center">物理地址</td>
</tr>
<tr>
<td style="text-align:center"><code>ioaddr_t</code></td>
<td style="text-align:center"><code>uint16_t</code></td>
<td style="text-align:center">I/O 端口地址</td>
</tr>
</tbody>
</table>
<ul>
<li><code>relreg_t</code> 多用于寄存器访问</li>
<li><code>vaddr_t</code> <code>paddr_t</code> 多用于内存访问</li>
<li><code>ioaddr_t</code> 多用于设备 I/O 端口访问</li>
</ul>
<p>定义了一些控制编译方式的宏。</p>
<table>
<thead>
<tr>
<th style="text-align:center">宏</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>DEBUG</code></td>
<td style="text-align:center">启用调试</td>
</tr>
<tr>
<td style="text-align:center"><code>DIFF_TEST</code></td>
<td style="text-align:center">启用 diff-test</td>
</tr>
<tr>
<td style="text-align:center"><code>HAS_IOE</code></td>
<td style="text-align:center">启用输入输出扩展</td>
</tr>
</tbody>
</table>
<ul>
<li><code>DIFF_TEST</code> 可启用一个差异测试工具，参见 <code>tools/qemu-diff</code> 部分。</li>
<li><code>HAS_IOE</code> 启用输入输出设备，参见设备部分。</li>
</ul>
<h2 id="24-debugh"><a class="markdownIt-Anchor" href="#24-debugh"></a> 2.4 debug.h</h2>
<p>定义了便于调试的宏。</p>
<table>
<thead>
<tr>
<th style="text-align:center">宏</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>Log_write(format, ...)</code></td>
<td style="text-align:center">仅记录日志</td>
</tr>
<tr>
<td style="text-align:center"><code>printflog(format, ...)</code></td>
<td style="text-align:center">显示文本并记录日志</td>
</tr>
<tr>
<td style="text-align:center"><code>Log(format, ...)</code></td>
<td style="text-align:center">对 <code>printflog</code> 的扩展，包含当前文件，行，函数</td>
</tr>
<tr>
<td style="text-align:center"><code>Info(format, ...)</code></td>
<td style="text-align:center">对 <code>Log</code> 的扩展，日志级别：提示</td>
</tr>
<tr>
<td style="text-align:center"><code>Warning(format, ...)</code></td>
<td style="text-align:center">对 <code>Log</code> 的扩展，日志级别：警告</td>
</tr>
<tr>
<td style="text-align:center"><code>Error(format, ...)</code></td>
<td style="text-align:center">对 <code>Log</code> 的扩展，日志级别：错误</td>
</tr>
<tr>
<td style="text-align:center"><code>panic(format, ...)</code></td>
<td style="text-align:center">强制退出，显示文本并记录日志</td>
</tr>
<tr>
<td style="text-align:center"><code>Assert(cond [, format, ...])</code></td>
<td style="text-align:center">设置断言，失败时强制退出，显示文本并记录日志</td>
</tr>
<tr>
<td style="text-align:center"><code>TODO()</code></td>
<td style="text-align:center">标识待完成项，执行时会触发 <code>panic</code></td>
</tr>
</tbody>
</table>
<h2 id="25-cpu"><a class="markdownIt-Anchor" href="#25-cpu"></a> 2.5 cpu/</h2>
<h3 id="251-regh"><a class="markdownIt-Anchor" href="#251-regh"></a> 2.5.1 reg.h</h3>
<p>定义了寄存器结构，和辅助寄存器的一些宏和函数。</p>
<ul>
<li>外部数组 <code>regsl, regsw, regsb</code> 不同寄存器名。实现在 <code>src/cpu/reg.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">char</span>* regsl[];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">char</span>* regsw[];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">char</span>* regsb[];</span><br></pre></td></tr></table></figure>
<h4 id="结构体-cpu_state"><a class="markdownIt-Anchor" href="#结构体-cpu_state"></a> 结构体 CPU_state</h4>
<p>寄存器结构，包含了所有寄存器，均为无符号整数。</p>
<ul>
<li>对于 8 个通用寄存器，内部以 <code>gpr</code> 数组为基础结构，提供 <code>eax</code> 等别名方便访问。寄存器按照 i386 指令中寄存器标号顺序排列。可使用 <code>_16,_8[0],_8[1]</code> 访问寄存器低位部分。</li>
<li><code>eip</code> 当前执行指令位置寄存器</li>
<li><code>eflags</code>标志位寄存器（使用匿名结构体，可直接访问<code>CF,OF,ZF,SF</code>）
<ul>
<li><code>eflags</code> 初始化为 <code>0x2</code></li>
</ul>
</li>
<li><code>cs,ss,ds,es,fs,gs</code>程序段寄存器（仅为支持 diff-test）
<ul>
<li><code>cs</code> 初始化为 <code>8</code></li>
</ul>
</li>
<li><code>idtr</code>：48 位寄存器，存放 IDT (Interrupt Descriptor Table, 中断描述符表)的首地址和长度
<ul>
<li><code>limit</code> 16位，长度，单位：字节</li>
<li><code>base</code> 32位，IDT 基地址</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">函数/宏</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>reg_l(index)</code></td>
<td style="text-align:center">获取指定下标处寄存器32位值</td>
</tr>
<tr>
<td style="text-align:center"><code>reg_w(index)</code></td>
<td style="text-align:center">获取指定下标处寄存器低16位值</td>
</tr>
<tr>
<td style="text-align:center"><code>reg_b(index)</code></td>
<td style="text-align:center">获取指定下标处寄存器低8位值</td>
</tr>
<tr>
<td style="text-align:center"><code>reg_name(index,width)</code></td>
<td style="text-align:center">根据下标和位宽获得寄存器名</td>
</tr>
</tbody>
</table>
<blockquote>
<p>寄存器存储在变量 <code>cpu</code> 中。</p>
</blockquote>
<h4 id="枚举"><a class="markdownIt-Anchor" href="#枚举"></a> 枚举</h4>
<p>定义了形如 <code>R_NAME</code> 的寄存器枚举，其顺序与寄存器结构中的顺序一致。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; R_EAX, R_ECX, R_EDX, R_EBX, R_ESP, R_EBP, R_ESI, R_EDI &#125;;</span><br><span class="line"><span class="keyword">enum</span> &#123; R_AX, R_CX, R_DX, R_BX, R_SP, R_BP, R_SI, R_DI &#125;;</span><br><span class="line"><span class="keyword">enum</span> &#123; R_AL, R_CL, R_DL, R_BL, R_AH, R_CH, R_DH, R_BH &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="252-decodeh"><a class="markdownIt-Anchor" href="#252-decodeh"></a> 2.5.2 decode.h</h3>
<p>定义了用于指令译码的结构和函数。</p>
<h4 id="结构体-operand"><a class="markdownIt-Anchor" href="#结构体-operand"></a> 结构体 Operand</h4>
<p>操作数。</p>
<table>
<thead>
<tr>
<th style="text-align:left">成员</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>type</code></td>
<td style="text-align:left">类型（见下方枚举）</td>
</tr>
<tr>
<td style="text-align:left"><code>width</code></td>
<td style="text-align:left">位宽</td>
</tr>
<tr>
<td style="text-align:left"><code>val</code></td>
<td style="text-align:left">实际值</td>
</tr>
<tr>
<td style="text-align:left"><code>str</code></td>
<td style="text-align:left">原串（用于调试输出）</td>
</tr>
<tr>
<td style="text-align:left"><code>reg</code></td>
<td style="text-align:left">寄存器下标</td>
</tr>
<tr>
<td style="text-align:left"><code>addr</code></td>
<td style="text-align:left">内存地址</td>
</tr>
<tr>
<td style="text-align:left"><code>imm</code></td>
<td style="text-align:left">立即数</td>
</tr>
<tr>
<td style="text-align:left"><code>simm</code></td>
<td style="text-align:left">带符号立即数</td>
</tr>
</tbody>
</table>
<h4 id="结构体-decodeinfo"><a class="markdownIt-Anchor" href="#结构体-decodeinfo"></a> 结构体 DecodeInfo</h4>
<p>单条命令译码结果。</p>
<table>
<thead>
<tr>
<th style="text-align:left">成员</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">对应x86指令部分</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>opcode</code></td>
<td style="text-align:left">指令码</td>
<td style="text-align:left">opcode</td>
</tr>
<tr>
<td style="text-align:left"><code>seq_eip</code></td>
<td style="text-align:left">序列 EIP 位置</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>is_operand_size_16</code></td>
<td style="text-align:left">标识操作数是否为 16 位</td>
<td style="text-align:left">operand-size prefix</td>
</tr>
<tr>
<td style="text-align:left"><code>ext_opcode</code></td>
<td style="text-align:left">额外指令码</td>
<td style="text-align:left">ModR/M 中 opcode</td>
</tr>
<tr>
<td style="text-align:left"><code>is_jmp</code></td>
<td style="text-align:left">标识是否为跳转语句</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>jmp_eip</code></td>
<td style="text-align:left">跳转目标（绝对地址），仅对于跳转语句</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>src</code></td>
<td style="text-align:left">源操作数</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>src2</code></td>
<td style="text-align:left">第二个源操作数</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>dest</code></td>
<td style="text-align:left">目标操作数</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>assembly</code></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>asm_buf</code></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>p</code></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<ul>
<li><code>seq_eip</code> 随译码过程改变，最终停留在需要译码的下一个位置，可根据这一值实现 eip 更新。</li>
<li><code>is_operand_size_16</code> 多用于实现单命令存在 16 位，32 位两个版本的情况</li>
<li><code>ext_opcode</code> 用于实现 <code>sub /5</code> 这种根据第二个指令码 <code>/5</code> 区分不同指令的情况，在译码中使用 <code>make_group</code> 实现。</li>
<li><code>is_jmp</code> 多在运行时指定（如 <code>rtl_j</code> 函数），如果标记，则不会再根据 <code>seq_eip</code> 更新 eip</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">函数/宏</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>id_src</code></td>
<td style="text-align:left"><code>(&amp;decoding.src)</code></td>
</tr>
<tr>
<td style="text-align:left"><code>id_src2</code></td>
<td style="text-align:left"><code>(&amp;decoding.src2)</code></td>
</tr>
<tr>
<td style="text-align:left"><code>id_dest</code></td>
<td style="text-align:left"><code>(&amp;decoding.dest)</code></td>
</tr>
<tr>
<td style="text-align:left"><code>operand_write(Operand *, rtlreg_t *)</code></td>
<td style="text-align:left">根据第一个参数中记录的类型的不同进行相应的写操作，包括写寄存器和写内存</td>
</tr>
<tr>
<td style="text-align:left"><code>load_addr(vaddr_t *, ModR_M *, Operand *)</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>read_ModR_M(vaddr_t *, Operand *, bool, Operand *, bool)</code></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<blockquote>
<p>译码内容存储在变量 <code>decoding</code> 中。</p>
</blockquote>
<h4 id="结构体-modr_m"><a class="markdownIt-Anchor" href="#结构体-modr_m"></a> 结构体 ModR_M</h4>
<p>指令中的 ModR/M。</p>
<h4 id="结构体-sib"><a class="markdownIt-Anchor" href="#结构体-sib"></a> 结构体 SIB</h4>
<p>指令中的 SIB。</p>
<h4 id="枚举-2"><a class="markdownIt-Anchor" href="#枚举-2"></a> 枚举</h4>
<p>定义了操作数的类型 <code>OP_TYPE_REG</code>，<code>OP_TYPE_MEM</code>，<code>OP_TYPE_IMM</code>，分别为寄存器，内存，立即数。</p>
<h4 id="宏-make_dhelper-与函数族-decode_name"><a class="markdownIt-Anchor" href="#宏-make_dhelper-与函数族-decode_name"></a> 宏 make_DHelper 与函数族 decode_name</h4>
<p>由宏 <code>make_DHelper</code> 定义了一族函数（参数相同），用于指令译码，并定义了这些函数的指针类型 <code>DHelper</code>。</p>
<ul>
<li>设计目的：由于大量指令的操作数模式相似，将这一点提取出来，实现解耦。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> make_DHelper(name) void concat(decode_, name) (vaddr_t *eip)</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*DHelper)</span> <span class="params">(<span class="keyword">vaddr_t</span> *)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数族中部分函数命名规则（<strong>不全</strong>）：</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>I</code></td>
<td style="text-align:left">立即数</td>
</tr>
<tr>
<td style="text-align:left"><code>SI</code></td>
<td style="text-align:left">有符号立即数</td>
</tr>
<tr>
<td style="text-align:left"><code>E</code></td>
<td style="text-align:left">内存或寄存器（对应指令描述中的 r/m）</td>
</tr>
<tr>
<td style="text-align:left"><code>G</code></td>
<td style="text-align:left">通用寄存器</td>
</tr>
<tr>
<td style="text-align:left"><code>r</code></td>
<td style="text-align:left">单一寄存器</td>
</tr>
<tr>
<td style="text-align:left"><code>a</code></td>
<td style="text-align:left">指定寄存器为 <code>eax,ax,al</code></td>
</tr>
<tr>
<td style="text-align:left"><code>I2G</code></td>
<td style="text-align:left">立即数到通用寄存器</td>
</tr>
<tr>
<td style="text-align:left"><code>I_E2G</code></td>
<td style="text-align:left">立即数与内存或寄存器到通用寄存器</td>
</tr>
<tr>
<td style="text-align:left"><code>O</code></td>
<td style="text-align:left">未知</td>
</tr>
</tbody>
</table>
<ul>
<li><code>r</code> 一般用于寄存器信息存储在 <code>opcode</code> 中的情况</li>
<li>还有一些专用于特定指令的译码函数</li>
</ul>
<blockquote>
<p>建议结合 i386 手册附录 C 理解。</p>
</blockquote>
<p>函数族中特殊函数：</p>
<ul>
<li><code>J</code> 跳转指令解码。单操作数，存储到 <code>jmp_eip</code> 中。</li>
</ul>
<h3 id="253-exech"><a class="markdownIt-Anchor" href="#253-exech"></a> 2.5.3 exec.h</h3>
<p>定义了一些用于调试的指令打印宏：</p>
<table>
<thead>
<tr>
<th style="text-align:left">宏</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>print_asm</code></td>
<td style="text-align:left">打印指令</td>
</tr>
<tr>
<td style="text-align:left"><code>suffix_char</code></td>
<td style="text-align:left">根据宽度获取指令宽度后缀</td>
</tr>
<tr>
<td style="text-align:left"><code>print_asm_template1</code></td>
<td style="text-align:left">单操作数指令</td>
</tr>
<tr>
<td style="text-align:left"><code>print_asm_template2</code></td>
<td style="text-align:left">双操作数指令</td>
</tr>
<tr>
<td style="text-align:left"><code>print_asm_template3</code></td>
<td style="text-align:left">三操作数指令</td>
</tr>
</tbody>
</table>
<h4 id="函数-instr_fetch"><a class="markdownIt-Anchor" href="#函数-instr_fetch"></a> 函数 instr_fetch</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">instr_fetch</span><span class="params">(<span class="keyword">vaddr_t</span> *eip, <span class="keyword">int</span> len)</span></span></span><br></pre></td></tr></table></figure>
<p>从 <code>eip</code> 开始，读取 <code>len</code> 个字节，返回值，并自动增加 <code>eip</code>。</p>
<ul>
<li>设计目的：与机器的大端小端解耦。</li>
</ul>
<h4 id="宏-make_ehelper-与-函数族-exec_name"><a class="markdownIt-Anchor" href="#宏-make_ehelper-与-函数族-exec_name"></a> 宏 make_EHelper 与 函数族 exec_name</h4>
<p>用于定义一族函数（参数相同），用于指令执行，并定义了这些函数的指针类型 <code>EHelper</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> make_EHelper(name) void concat(exec_, name) (vaddr_t *eip)</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*EHelper)</span> <span class="params">(<span class="keyword">vaddr_t</span> *)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="254-reloph"><a class="markdownIt-Anchor" href="#254-reloph"></a> 2.5.4 relop.h</h3>
<p>定义了形如 <code>RELOP_NAME</code> 的枚举，标识不同类型的关系运算。对应了 <code>setcc,jcc</code> 命令的相应编码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">  <span class="comment">//            +-- unsign</span></span><br><span class="line">  <span class="comment">//            |   +-- sign</span></span><br><span class="line">  <span class="comment">//            |   |   +-- equal</span></span><br><span class="line">  <span class="comment">//            |   |   |   +-- invert</span></span><br><span class="line">  <span class="comment">//            |   |   |   |</span></span><br><span class="line">  RELOP_FALSE = <span class="number">0</span> | <span class="number">0</span> | <span class="number">0</span> | <span class="number">0</span>,</span><br><span class="line">  RELOP_TRUE  = <span class="number">0</span> | <span class="number">0</span> | <span class="number">0</span> | <span class="number">1</span>,</span><br><span class="line">  RELOP_EQ    = <span class="number">0</span> | <span class="number">0</span> | <span class="number">2</span> | <span class="number">0</span>,</span><br><span class="line">  RELOP_NE    = <span class="number">0</span> | <span class="number">0</span> | <span class="number">2</span> | <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  RELOP_LT    = <span class="number">0</span> | <span class="number">4</span> | <span class="number">0</span> | <span class="number">0</span>,</span><br><span class="line">  RELOP_LE    = <span class="number">0</span> | <span class="number">4</span> | <span class="number">2</span> | <span class="number">0</span>,</span><br><span class="line">  RELOP_GT    = <span class="number">0</span> | <span class="number">4</span> | <span class="number">2</span> | <span class="number">1</span>,</span><br><span class="line">  RELOP_GE    = <span class="number">0</span> | <span class="number">4</span> | <span class="number">0</span> | <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  RELOP_LTU   = <span class="number">8</span> | <span class="number">0</span> | <span class="number">0</span> | <span class="number">0</span>,</span><br><span class="line">  RELOP_LEU   = <span class="number">8</span> | <span class="number">0</span> | <span class="number">2</span> | <span class="number">0</span>,</span><br><span class="line">  RELOP_GTU   = <span class="number">8</span> | <span class="number">0</span> | <span class="number">2</span> | <span class="number">1</span>,</span><br><span class="line">  RELOP_GEU   = <span class="number">8</span> | <span class="number">0</span> | <span class="number">0</span> | <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="255-cch"><a class="markdownIt-Anchor" href="#255-cch"></a> 2.5.5 cc.h</h3>
<p>定义了函数 <code>get_cc_name</code> 根据编码获取指定关系运算字符串。</p>
<p>定义了 RTL 基本指令 <code>rtl_setcc</code> 用于根据当前关系运算和 eflags 寄存器标志位设置 dest。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_setcc</span><span class="params">(<span class="keyword">rtlreg_t</span>*, <span class="keyword">uint8_t</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="256-rtlh"><a class="markdownIt-Anchor" href="#256-rtlh"></a> 2.5.6 rtl.h</h3>
<p>定义和实现了一些 RTL 指令，用于提供对指令执行的底层建模。可使用这些操作将复杂指令分解成更简单的操作。</p>
<p>NEMU 中的 RTL 寄存器：</p>
<ul>
<li>x86的八个通用寄存器(在 <code>include/cpu/reg.h</code> 中定义)</li>
<li><code>id_src</code>, <code>id_src2</code> 和 <code>id_dest</code> 中的访存地址 <code>addr</code> 和操作数内容 <code>val</code> (在 <code>include/cpu/decode.h</code> 中定义). 从概念上看, 它们分别与MAR和 MDR有异曲同工之妙</li>
<li>临时寄存器 <code>t0~t3</code> 和 <code>at</code> (在 <code>src/cpu/decode/decode.c</code> 中定义)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">rtlreg_t</span> t0, t1, t2, t3, at;</span><br></pre></td></tr></table></figure>
<ul>
<li>宏<code>make_rtl_arith_logic</code>根据算术运算符名创建对应 RTL 基本指令和 RTL 指令，使用了<code>include/util/c_op.h</code>中的运算。
<ul>
<li>32位寄存器-寄存器类型的算术/逻辑运算</li>
<li>32位寄存器-立即数类型的算术/逻辑运算</li>
</ul>
</li>
<li>定义函数 <code>decoding_set_jmp(bool is_jmp)</code> ：将 当前指令标记为跳转（标记 <code>decoing.is_jmp</code>）</li>
<li>定义函数 <code>interpret_relop</code> ：实现两个值的关系运算，返回结果（实现在 <code>src/cpu/exec/relop.c</code></li>
</ul>
<h4 id="rtl-基本指令"><a class="markdownIt-Anchor" href="#rtl-基本指令"></a> RTL 基本指令</h4>
<p>特点：不需要使用临时寄存器, 可以看做是最基本的x86指令中的最基本的操作。 实现时添加了 <code>interpret_</code> 前缀，但在 <code>include/cpu/rtl-wrapper.h</code> 作用下，其它代码中使用到这些RTL基本指令时会自动添加 <code>interpret_</code> 前缀。</p>
<ul>
<li>立即数读入 <code>rtl_li</code></li>
<li>寄存器传输 <code>rtl_mv</code></li>
<li>32位寄存器-寄存器类型的算术/逻辑运算, 包括 <code>rtl_(add|sub|and|or|xor|shl|shr|sar|i?mul_[lo|hi]|i?div_[q|r])</code> , 这些运算的定义用到 <code>include/util/c_op.h</code> 中的C语言运算</li>
<li>被除数为64位的除法运算 <code>rtl_i?div64_[q|r]</code></li>
<li>guest内存访问 <code>rtl_lm</code> 和 <code>rtl_sm</code></li>
<li>host内存访问 <code>rtl_host_lm</code> 和 <code>rtl_host_sm</code></li>
<li>关系运算 <code>rtl_setrelop</code>, 具体可参考 <code>src/cpu/exec/relop.c</code></li>
<li>跳转, 包括直接跳转 <code>rtl_j</code> , 间接跳转 <code>rtl_jr</code> 和条件跳转 <code>rtl_jrelop</code></li>
<li>终止程序 <code>rtl_exit</code></li>
</ul>
<p>具体声明：</p>
<ul>
<li>未标明则函数修饰符均为 <code>static inline</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 立即数读入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interpret_rtl_li</span><span class="params">(<span class="keyword">rtlreg_t</span>* dest, <span class="keyword">uint32_t</span> imm)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄存器传输</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interpret_rtl_mv</span><span class="params">(<span class="keyword">rtlreg_t</span>* dest, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span> *src1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 32位寄存器-寄存器类型的算术/逻辑运算</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interpret_rtl_add</span> <span class="params">(<span class="keyword">rtlreg_t</span>* dest, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src1, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被除数为64位的除法运算</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interpret_rtl_div64_q</span><span class="params">(<span class="keyword">rtlreg_t</span>* dest,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src1_hi, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src1_lo, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// guest内存访问</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interpret_rtl_lm</span><span class="params">(<span class="keyword">rtlreg_t</span> *dest, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* addr, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interpret_rtl_sm</span><span class="params">(<span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* addr, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src1, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// host内存访问</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interpret_rtl_host_lm</span><span class="params">(<span class="keyword">rtlreg_t</span>* dest, <span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interpret_rtl_host_sm</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span> *src1, <span class="keyword">int</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关系运算</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interpret_rtl_setrelop</span><span class="params">(<span class="keyword">uint32_t</span> relop, <span class="keyword">rtlreg_t</span> *dest, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span> *src1, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span> *src2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interpret_rtl_j</span><span class="params">(<span class="keyword">vaddr_t</span> target)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interpret_rtl_jr</span><span class="params">(<span class="keyword">rtlreg_t</span> *target)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interpret_rtl_jrelop</span><span class="params">(<span class="keyword">uint32_t</span> relop, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span> *src1, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span> *src2, <span class="keyword">vaddr_t</span> target)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终止程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interpret_rtl_exit</span><span class="params">(<span class="keyword">int</span> state)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="rtl-伪指令"><a class="markdownIt-Anchor" href="#rtl-伪指令"></a> RTL 伪指令</h4>
<p>通过RTL基本指令或者已经实现的RTL伪指令来实现。</p>
<ul>
<li>32位寄存器-立即数类型的算术/逻辑运算, 包括 <code>rtl_(add|sub|and|or|xor|shl|shr|sar|i?mul_[lo|hi]|i?div_[q|r])_i</code></li>
<li>通用寄存器访问 <code>rtl_lr</code> 和 <code>rtl_sr</code></li>
<li>EFLAGS标志位的读写 <code>rtl_set_(CF|OF|ZF|SF)</code> 和 <code>rtl_get_(CF|OF|ZF|SF)</code></li>
<li>其它常用功能, 如按位取反 <code>rtl_not</code> ，符号扩展 <code>rtl_sext</code> 等</li>
</ul>
<p>具体声明：</p>
<ul>
<li>未标明则函数修饰符均为 <code>static inline</code>。</li>
<li>宏<code>make_rtl_setget_eflags</code>声明了需要实现的 EFLAGS标志位的读写 指令
<ul>
<li><code>rtl_set_name</code></li>
<li><code>rtl_get_name</code></li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 32位寄存器-立即数类型的算术/逻辑运算</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_addi</span> <span class="params">(<span class="keyword">rtlreg_t</span>* dest, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src1, <span class="keyword">int</span> imm)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 通用寄存器访问</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_lr</span><span class="params">(<span class="keyword">rtlreg_t</span>* dest, <span class="keyword">int</span> r, <span class="keyword">int</span> <span class="built_in">width</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_sr</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src1, <span class="keyword">int</span> <span class="built_in">width</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EFLAGS标志位的读写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_set_CF</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_get_CF</span> <span class="params">(<span class="keyword">rtlreg_t</span>* dest)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_set_OF</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_get_OF</span> <span class="params">(<span class="keyword">rtlreg_t</span>* dest)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_set_ZF</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_get_ZF</span> <span class="params">(<span class="keyword">rtlreg_t</span>* dest)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_set_SF</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_get_SF</span> <span class="params">(<span class="keyword">rtlreg_t</span>* dest)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据运算结构更新 ZF, SF 标志位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_update_ZF</span><span class="params">(<span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* result, <span class="keyword">int</span> <span class="built_in">width</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_update_SF</span><span class="params">(<span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* result, <span class="keyword">int</span> <span class="built_in">width</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_update_ZFSF</span><span class="params">(<span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* result, <span class="keyword">int</span> <span class="built_in">width</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按位取反</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_not</span><span class="params">(<span class="keyword">rtlreg_t</span> *dest, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 符号扩展</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_sext</span><span class="params">(<span class="keyword">rtlreg_t</span>* dest, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src1, <span class="keyword">int</span> <span class="built_in">width</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_push</span><span class="params">(<span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_pop</span><span class="params">(<span class="keyword">rtlreg_t</span>* dest)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 32位寄存器-立即数类型 关系运算</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_setrelopi</span><span class="params">(<span class="keyword">uint32_t</span> relop, <span class="keyword">rtlreg_t</span> *dest, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span> *src1, <span class="keyword">int</span> imm)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取符号位（最高位）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl_msb</span><span class="params">(<span class="keyword">rtlreg_t</span>* dest, <span class="keyword">const</span> <span class="keyword">rtlreg_t</span>* src1, <span class="keyword">int</span> <span class="built_in">width</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>我们定义RTL基本指令的时候, 约定了RTL基本指令不需要使用RTL临时寄存器. 但某些RTL伪指令需要使用临时寄存器存放中间结果, 才能实现其完整功能. 这样可能会带来寄存器覆盖的问题, 例如如下RTL指令序列:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1) rtl_mv(&amp;t0, &amp;t1);</span><br><span class="line">(2) rtl_sext(&amp;t1, &amp;t2, 1);  // use t0 temporarily</span><br><span class="line">(3) rtl_add(&amp;t2, &amp;t0, &amp;t1);</span><br></pre></td></tr></table></figure>
<p>如果实现(2)的时候恰好使用到了t0作为临时寄存器, 在(3)中使用的t0就不再是(1)的结果了, 从而产生非预期的结果.</p>
<p>为了尽可能避免上述问题, 我们有两条约定:</p>
<ul>
<li>实现RTL伪指令的时候, 尽可能不使用 <code>dest</code> 之外的寄存器存放中间结果. 由于 <code>dest</code> 最后会被写入新值, 其旧值肯定要被覆盖, 自然也可以安全地作为RTL伪指令的临时寄存器.</li>
<li>实在需要使用临时寄存器的时候, 使用 <code>at</code> . <code>at</code> 全称是assembly temporary, 是MIPS ABI中定义的一个特殊寄存器: 编译器并不会使用它, 它可以在编写汇编代码的时候安全地作为可使用的临时寄存器. 在这里， 我们借鉴它的功能来作如下约定: 不要在RTL伪指令的内部实现之外使用 <code>at</code> . 这样， <code>at</code> 就可以安全地作为RTL伪指令的临时寄存器了.</li>
</ul>
<h3 id="257-rtl-wrapperh"><a class="markdownIt-Anchor" href="#257-rtl-wrapperh"></a> 2.5.7 rtl-wrapper.h</h3>
<p>为 rtl.h 中定义的 RTL 基本指令的调用省去 <code>interpret_</code> 前缀。</p>
<h2 id="26-memory"><a class="markdownIt-Anchor" href="#26-memory"></a> 2.6 memory/</h2>
<h3 id="261-memoryh"><a class="markdownIt-Anchor" href="#261-memoryh"></a> 2.6.1 memory.h</h3>
<p>定义了访问内存的函数。使用数组 <code>pmem</code> 模拟内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">uint8_t</span> pmem[];</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">函数/宏</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>uint32_t vaddr_read(vaddr_t, int)</code></td>
<td style="text-align:left">从虚拟内存指定位置读取指定数目个字节</td>
</tr>
<tr>
<td style="text-align:left"><code>void vaddr_write(vaddr_t, uint32_t, int)</code></td>
<td style="text-align:left">向虚拟内存指定位置写入指定数目个字节</td>
</tr>
<tr>
<td style="text-align:left"><code>uint32_t paddr_read(paddr_t, int)</code></td>
<td style="text-align:left">从物理内存指定位置读取指定数目个字节</td>
</tr>
<tr>
<td style="text-align:left"><code>void paddr_write(paddr_t, uint32_t, int)</code></td>
<td style="text-align:left">向物理内存指定位置写入指定数目个字节</td>
</tr>
<tr>
<td style="text-align:left"><code>guest_to_host(p)</code></td>
<td style="text-align:left"><code>((void *)(pmem + (unsigned)p))</code></td>
</tr>
<tr>
<td style="text-align:left"><code>host_to_guest(p)</code></td>
<td style="text-align:left"><code>((paddr_t)((void *)p - (void *)pmem))</code></td>
</tr>
</tbody>
</table>
<h3 id="262-mmuh"><a class="markdownIt-Anchor" href="#262-mmuh"></a> 2.6.2 mmu.h</h3>
<p>(TODO)</p>
<h4 id="结构体-gatedesc"><a class="markdownIt-Anchor" href="#结构体-gatedesc"></a> 结构体 GateDesc</h4>
<p>指示中断操作的门描述符(Gate Descriptor)类型。门描述符是一个8字节的结构体, 里面包含着不少细节的信息, 在NEMU中简化了门描述符的结构, 只保留存在位P和偏移量OFFSET。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 31                23                15                7                0</span><br><span class="line">+-----------------+-----------------+---+-------------------------------+</span><br><span class="line">|           OFFSET 31..16           | P |          Don&apos;t care           |4</span><br><span class="line">+-----------------------------------+---+-------------------------------+</span><br><span class="line">|             Don&apos;t care            |           OFFSET 15..0            |0</span><br><span class="line">+-----------------+-----------------+-----------------+-----------------+</span><br></pre></td></tr></table></figure>
<p>在 <code>raise_intr</code>（定义在 <code>intr.c</code> 中）中使用。</p>
<table>
<thead>
<tr>
<th style="text-align:left">成员</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>offset_15_0</code></td>
<td style="text-align:left">Offset 低位部分</td>
</tr>
<tr>
<td style="text-align:left"><code>offset_31_16</code></td>
<td style="text-align:left">Offset 高位部分</td>
</tr>
<tr>
<td style="text-align:left"><code>present</code></td>
<td style="text-align:left">标识是否有效</td>
</tr>
</tbody>
</table>
<ul>
<li>为方便从内存中读取，使用 union 结构以及 <code>val0 val1</code> 域简化读写。</li>
<li>此结构体与 AM 中定义的 <code>GateDesc</code> （在 <code>arch/x86-nemu/include/x86.h</code> 中）结构相同。</li>
</ul>
<h2 id="27-device"><a class="markdownIt-Anchor" href="#27-device"></a> 2.7 device/</h2>
<h3 id="271-mmioh"><a class="markdownIt-Anchor" href="#271-mmioh"></a> 2.7.1 mmio.h</h3>
<p>对内存映射 I/O 编址方式的支持。注意，内存映射 I/O 的读写并不是面向 CPU 的。</p>
<blockquote>
<p>端口映射I/O把端口号作为I/O指令的一部分, 这种方法很简单, 但同时也是它最大的缺点. 指令集为了兼容已经开发的程序, 是只能添加但不能修改的. 这意味着, 端口映射I/O所能访问的I/O地址空间的大小, 在设计I/O指令的那一刻就已经决定下来了. 所谓I/O地址空间, 其实就是所有能访问的设备的地址的集合. 随着设备越来越多, 功能也越来越复杂, I/O地址空间有限的端口映射I/O已经逐渐不能满足需求了. 有的设备需要让CPU访问一段较大的连续存储空间, 如VGA的显存, 24色加上Alpha通道的1024x768分辨率的显存就需要3MB的编址范围. 于是内存映射I/O(memory-mapped I/O)应运而生. 内存映射I/O这种编址方式非常巧妙, 它是通过不同的物理内存地址给设备编址的. 这种编址方式将一部分物理内存&quot;重定向&quot;到I/O地址空间中, CPU尝试访问这部分物理内存的时候, 实际上最终是访问了相应的I/O设备, CPU却浑然不知. 这样以后, CPU就可以通过普通的访存指令来访问设备. 这也是内存映射I/O得天独厚的好处: 物理内存的地址空间和CPU的位宽都会不断增长, 内存映射I/O从来不需要担心I/O地址空间耗尽的问题. 从原理上来说, 内存映射I/O唯一的缺点就是, CPU无法通过正常渠道直接访问那些被映射到I/O地址空间的物理内存了. 但随着计算机的发展, 内存映射I/O的唯一缺点已经越来越不明显了: 现代计算机都已经是64位计算机, 物理地址线都有48根, 这意味着物理地址空间有256TB这么大, 从里面划出3MB的地址空间给显存, 根本就是不痛不痒. 正因为如此, 内存映射I/O成为了现代计算机主流的I/O编址方式: RISC架构只提供内存映射I/O的编址方式, 而PCI-e, 网卡, x86的APIC等主流设备, 都支持通过内存映射I/O来访问.</p>
</blockquote>
<blockquote>
<p>在 NEMU 中， video memory是唯一使用内存映射 I/O 方式访问的 I/O 空间。</p>
</blockquote>
<p>定义了类型 <code>mmio_callback_t</code> ，设备定义的回调函数，用以更新设备状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*<span class="keyword">mmio_callback_t</span>)</span><span class="params">(<span class="keyword">paddr_t</span>, <span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>void* add_mmio_map(paddr_t, int, mmio_callback_t)</code></td>
<td style="text-align:left">注册一个内存映射 I/O 映射关系，返回该映射关系的 I/O 空间首地址</td>
</tr>
<tr>
<td style="text-align:left"><code>int is_mmio(paddr_t)</code></td>
<td style="text-align:left">判断一个物理地址是否被映射到 I/O 空间，如果是，返回映射号, 否则返回 -1</td>
</tr>
<tr>
<td style="text-align:left"><code>uint32_t mmio_read(paddr_t, int, int)</code></td>
<td style="text-align:left">根据端口号和地址读取</td>
</tr>
<tr>
<td style="text-align:left"><code>void mmio_write(paddr_t, int, uint32_t, int)</code></td>
<td style="text-align:left">根据端口号和地址写入</td>
</tr>
</tbody>
</table>
<h3 id="272-port-ioh"><a class="markdownIt-Anchor" href="#272-port-ioh"></a> 2.7.2 port-io.h</h3>
<p>对端口映射 I/O 编址方式的支持。端口映射I/O(port-mapped I/O)， CPU使用专门的I/O指令对设备进行访问， 并把设备的地址称作端口号。 有了端口号以后， 在I/O指令中给出端口号， 就知道要访问哪一个设备寄存器了。</p>
<p>定义了类型 <code>pio_callback_t</code> ，设备定义的回调函数，用以更新设备状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*<span class="keyword">pio_callback_t</span>)</span><span class="params">(<span class="keyword">ioaddr_t</span>, <span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>void* add_pio_map(paddr_t, int, mmio_callback_t)</code></td>
<td style="text-align:left">注册一个端口映射 I/O 映射关系，返回该映射关系的 I/O 空间首地址</td>
</tr>
<tr>
<td style="text-align:left"><code>uint32_t pio_read_[l,w,b](ioaddr_t)</code></td>
<td style="text-align:left">面向 CPU 的端口 I/O 读接口</td>
</tr>
<tr>
<td style="text-align:left"><code>void pio_write_[l,w,b](ioaddr_t, uint32_t)</code></td>
<td style="text-align:left">面向 CPU 的端口 I/O 写接口</td>
</tr>
</tbody>
</table>
<h2 id="28-monitor"><a class="markdownIt-Anchor" href="#28-monitor"></a> 2.8 monitor/</h2>
<p>监视器部分（也包含 NEMU 执行主循环）。</p>
<h3 id="281-exprh"><a class="markdownIt-Anchor" href="#281-exprh"></a> 2.8.1 expr.h</h3>
<p>定义了计算表达式的值的函数 <code>expr</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">expr</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">bool</span> *)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="282-monitorh"><a class="markdownIt-Anchor" href="#282-monitorh"></a> 2.8.2 monitor.h</h3>
<p>定义了 NEMU 状态 变量 <code>nemu_state</code>，和枚举值 <code>NEMU_STOP, NEMU_RUNNING, NEMU_END, NEMU_ABORT</code>。 定义了 应用程序入口点 <code>ENTRY_START</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENTRY_START 0x100000</span></span><br></pre></td></tr></table></figure>
<h3 id="283-watchpointh"><a class="markdownIt-Anchor" href="#283-watchpointh"></a> 2.8.3 watchpoint.h</h3>
<h4 id="结构体-wp"><a class="markdownIt-Anchor" href="#结构体-wp"></a> 结构体 WP</h4>
<p>监视点结构。采用链表结构存储。</p>
<table>
<thead>
<tr>
<th style="text-align:left">成员</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>NO</code></td>
<td style="text-align:left">序号</td>
</tr>
<tr>
<td style="text-align:left"><code>next</code></td>
<td style="text-align:left">下一监视点指针</td>
</tr>
<tr>
<td style="text-align:left"><code>expr</code></td>
<td style="text-align:left">监视的表达式</td>
</tr>
<tr>
<td style="text-align:left"><code>lastVal</code></td>
<td style="text-align:left">表达式最近一次的值</td>
</tr>
</tbody>
</table>
<h2 id="29-util"><a class="markdownIt-Anchor" href="#29-util"></a> 2.9 util/</h2>
<h3 id="291-c_oph"><a class="markdownIt-Anchor" href="#291-c_oph"></a> 2.9.1 c_op.h</h3>
<p>定义了一些形如 <code>c_opname_type</code> 的宏，用于表示基础 C 运算。在 RTL基本指令中的寄存器运算指令中使用。</p>
<h1 id="3-src"><a class="markdownIt-Anchor" href="#3-src"></a> 3 src/</h1>
<h2 id="mainc"><a class="markdownIt-Anchor" href="#mainc"></a> main.c</h2>
<p>NEMU 主程序。</p>
<p>调用 <code>init_monitor</code> （实现在 <code>/src/monitor/monitor.c</code>）初始化监视器，并获取当前是否为批处理模式。 调用 <code>ui_mainloop</code> （实现在 <code>/src/monitor/debug/ui.c</code>）进行指令执行模拟。</p>
<h2 id="cpu"><a class="markdownIt-Anchor" href="#cpu"></a> cpu/</h2>
<h3 id="regc"><a class="markdownIt-Anchor" href="#regc"></a> reg.c</h3>
<p>实现了 <code>include/cpu/reg.h</code> 中的 <code>regsl,regsw,regsb</code>，同时实现寄存器实际定义：变量 <code>cpu</code>。</p>
<ul>
<li>函数 <code>reg_test</code>：测试寄存器结构定义（<code>CPU_state</code>）是否正确。</li>
</ul>
<h3 id="intrc"><a class="markdownIt-Anchor" href="#intrc"></a> intr.c</h3>
<p>函数 <code>void raise_intr(uint8_t NO, vaddr_t ret_addr)</code> 为 <code>int</code> 指令（在 <code>system.c</code> 中实现）的内部实现。 实现了触发中断或异常后的硬件处理：</p>
<ol>
<li>依次将EFLAGS, CS(代码段寄存器), EIP寄存器（返回地址）的值压入堆栈</li>
<li>根据中断码，从IDTR中读出IDT的首地址</li>
<li>根据异常号在IDT中进行索引, 找到一个门描述符</li>
<li>将门描述符中的offset域组合成目标地址</li>
<li>跳转到目标地址</li>
</ol>
<h3 id="decode"><a class="markdownIt-Anchor" href="#decode"></a> decode/</h3>
<p>指令译码相关。</p>
<h4 id="decodec"><a class="markdownIt-Anchor" href="#decodec"></a> decode.c</h4>
<p>实现了 <code>include/cpu/decode.h</code> 中的译码函数族，函数 <code>operand_write</code> 以及译码信息变量 <code>decoding</code>。 实现了 <code>include/cpu/rtl.h</code> 中的临时寄存器 <code>t0,t1,t2,t3,at</code> 和函数 <code>decoding_set_jmp</code>。</p>
<h5 id="宏-make_dophelper-与函数族-decode_op_name"><a class="markdownIt-Anchor" href="#宏-make_dophelper-与函数族-decode_op_name"></a> 宏 make_DopHelper 与函数族 decode_op_name</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> make_DopHelper(name) void concat(decode_op_, name) (vaddr_t *eip, Operand *op, bool load_val)</span></span><br></pre></td></tr></table></figure>
<p>译码函数会进一步分解成各种不同操作数的译码的组合，以实现操作数译码的解耦. 操作数译码函数统一通过宏 <code>make_DopHelper</code> 来定义 （<code>decode_op_rm</code> 除外）。 操作数译码函数会把操作数的信息记录在结构体 <code>op</code> 中, 如果操作数在指令中， 就会通过 <code>instr_fetch()</code> 将它们从 <code>eip</code> 所指向的内存位置取出. 为了使操作数译码函数更易于复用， 函数中的 <code>load_val</code> 参数会控制 是否需要将该操作数读出到全局译码信息 <code>decoding</code> 供后续使用. 例如如果一个内存操作数是源操作数, 就需要将这个操作数从内存中读出来供后续执行阶段来使用； 如果它仅仅是一个目的操作数， 就不需要从内存读出它的值了，因为执行这条指令并不需要这个值， 而是将新数据写入相应的内存位置.</p>
<p><code>decode_op_name</code> 函数族命名规则可参见 <code>decode_name</code> 函数族命名规则。</p>
<ul>
<li><code>decode_op_a</code> 是一个特例，其用于将操作数标记为寄存器 <code>ax</code> 或 <code>eax</code></li>
</ul>
<h4 id="modrmc"><a class="markdownIt-Anchor" href="#modrmc"></a> modrm.c</h4>
<p>实现了 <code>include/cpu/decode.h</code> 中的函数 <code>load_addr</code> 和 <code>read_ModR_M</code>。</p>
<h3 id="exec"><a class="markdownIt-Anchor" href="#exec"></a> exec/</h3>
<p>指令执行相关。</p>
<h4 id="ccc"><a class="markdownIt-Anchor" href="#ccc"></a> cc.c</h4>
<p>实现了 <code>include/cpu/cc.h</code> 中的函数 <code>rtl_setcc</code>。根据指定关系运算以及条件标志位设置 dest。</p>
<h4 id="relopc"><a class="markdownIt-Anchor" href="#relopc"></a> relop.c</h4>
<p>实现了 <code>include/cpu/relop.h</code> 中的函数 <code>interpret_relop</code>，使用 C语言关系运算符实现关系运算。</p>
<h4 id="all-instrh"><a class="markdownIt-Anchor" href="#all-instrh"></a> all-instr.h</h4>
<p>定义了已经实现的指令执行函数（在 <code>exec.c</code> 中使用）。</p>
<h4 id="arithc"><a class="markdownIt-Anchor" href="#arithc"></a> arith.c</h4>
<p>算术运算指令执行函数实现。</p>
<table>
<thead>
<tr>
<th style="text-align:left">指令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>add</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>sub</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>cmp</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>inc</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>dec</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>neg</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>adc</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>sbb</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>mul</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>imul1</code></td>
<td style="text-align:left">imul 单操作数</td>
</tr>
<tr>
<td style="text-align:left"><code>imul2</code></td>
<td style="text-align:left">imul 双操作数</td>
</tr>
<tr>
<td style="text-align:left"><code>imul3</code></td>
<td style="text-align:left">imul 三操作数</td>
</tr>
<tr>
<td style="text-align:left"><code>div</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>idiv</code></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h4 id="controlc"><a class="markdownIt-Anchor" href="#controlc"></a> control.c</h4>
<p>控制指令执行函数实现。</p>
<table>
<thead>
<tr>
<th style="text-align:left">指令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>jmp</code></td>
<td style="text-align:left">直接跳转</td>
</tr>
<tr>
<td style="text-align:left"><code>jmp_rm</code></td>
<td style="text-align:left">间接跳转</td>
</tr>
<tr>
<td style="text-align:left"><code>jcc</code></td>
<td style="text-align:left">条件跳转</td>
</tr>
<tr>
<td style="text-align:left"><code>call</code></td>
<td style="text-align:left">直接调用</td>
</tr>
<tr>
<td style="text-align:left"><code>call_rm</code></td>
<td style="text-align:left">间接调用</td>
</tr>
<tr>
<td style="text-align:left"><code>ret</code></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h4 id="data-movc"><a class="markdownIt-Anchor" href="#data-movc"></a> data-mov.c</h4>
<p>数据移动指令执行函数实现。</p>
<table>
<thead>
<tr>
<th style="text-align:left">指令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>mov</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>movsx</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>movzx</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>lea</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>push</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>pop</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>pusha</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>popa</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>leave</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>cltd</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>cwtl</code></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h4 id="logicc"><a class="markdownIt-Anchor" href="#logicc"></a> logic.c</h4>
<p>逻辑运算指令执行函数实现。</p>
<table>
<thead>
<tr>
<th style="text-align:left">指令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>test</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>and</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>xor</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>or</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>sar</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>shl</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>shr</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>setcc</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>not</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>rol</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>ror</code></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h4 id="specialc"><a class="markdownIt-Anchor" href="#specialc"></a> special.c</h4>
<p>特殊指令执行函数实现。</p>
<p>实现了 <code>include/cpu/rtl.h</code> 中的函数 <code>interpret_rtl_exit</code>。</p>
<table>
<thead>
<tr>
<th style="text-align:left">指令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>nop</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>inv</code></td>
<td style="text-align:left">非法指令</td>
</tr>
<tr>
<td style="text-align:left"><code>nemu_trap</code></td>
<td style="text-align:left">结束执行</td>
</tr>
</tbody>
</table>
<h4 id="prefixc"><a class="markdownIt-Anchor" href="#prefixc"></a> prefix.c</h4>
<p>定义了执行函数 <code>exec_real</code>。 定义并实现了执行函数 <code>exec_operand_size</code>。</p>
<ul>
<li><code>exec_operand_size</code> 以 16 位操作数执行指令（标记 <code>decoding.is_operand_size_16</code>）</li>
</ul>
<h4 id="systemc"><a class="markdownIt-Anchor" href="#systemc"></a> system.c</h4>
<p>系统相关指令实现。</p>
<table>
<thead>
<tr>
<th style="text-align:left">指令</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>lidt</code></td>
<td style="text-align:left">设置 IDTR 寄存器</td>
</tr>
<tr>
<td style="text-align:left"><code>mov_r2cr</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>mov_cr2r</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>int</code></td>
<td style="text-align:left">根据中断码进行中断跳转</td>
</tr>
<tr>
<td style="text-align:left"><code>iret</code></td>
<td style="text-align:left">从中断跳转返回</td>
</tr>
<tr>
<td style="text-align:left"><code>in</code></td>
<td style="text-align:left">读取端口映射 I/O</td>
</tr>
<tr>
<td style="text-align:left"><code>out</code></td>
<td style="text-align:left">写入端口映射 I/O</td>
</tr>
</tbody>
</table>
<ul>
<li>x86 提供了 in 和 out 指令用于访问设备，其中 in 指令用于将设备寄存器中的数据传输到 CPU 寄存器中，out 指令用于将 CPU 寄存器中的数据传送到设备寄存器中</li>
</ul>
<h4 id="execc"><a class="markdownIt-Anchor" href="#execc"></a> exec.c</h4>
<p>指令执行过程核心实现。</p>
<h5 id="结构体-opcode_entry"><a class="markdownIt-Anchor" href="#结构体-opcode_entry"></a> 结构体 opcode_entry</h5>
<p>译码查找表中元素。</p>
<table>
<thead>
<tr>
<th style="text-align:left">成员</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>DHelper decode</code></td>
<td style="text-align:left">译码函数指针</td>
</tr>
<tr>
<td style="text-align:left"><code>EHelper execute</code></td>
<td style="text-align:left">执行函数指针</td>
</tr>
<tr>
<td style="text-align:left"><code>width</code></td>
<td style="text-align:left">指令宽度</td>
</tr>
</tbody>
</table>
<h5 id="数组-opcode_table"><a class="markdownIt-Anchor" href="#数组-opcode_table"></a> 数组 opcode_table</h5>
<p>译码表。按指令第一个字节索引存放。分两段：单字节指令码和双字节指令码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">opcode_entry opcode_table [<span class="number">512</span>] = &#123;</span><br><span class="line">  <span class="comment">/* 0x00 */</span>	EMPTY, EMPTY, EMPTY, EMPTY,</span><br><span class="line">  <span class="comment">/* 0x04 */</span>	EMPTY, EMPTY, EMPTY, EMPTY,</span><br><span class="line">  <span class="comment">/* 0x08 */</span>	EMPTY, EMPTY, EMPTY, EMPTY,</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">宏</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>IDEXW(id, ex, w)</code></td>
<td style="text-align:left">根据译码函数名，执行函数名，宽度生成 <code>opcode_entry</code></td>
</tr>
<tr>
<td style="text-align:left"><code>IDEX(id, ex)</code></td>
<td style="text-align:left">根据译码函数名，执行函数名，以宽度 0 生成 <code>opcode_entry</code></td>
</tr>
<tr>
<td style="text-align:left"><code>EXW(ex, w)</code></td>
<td style="text-align:left">根据执行函数名，宽度，生成无译码函数的 <code>opcode_entry</code></td>
</tr>
<tr>
<td style="text-align:left"><code>EX(ex)</code></td>
<td style="text-align:left">根据执行函数名，生成宽度为 0 且无译码函数的 <code>opcode_entry</code></td>
</tr>
<tr>
<td style="text-align:left"><code>EMPTY</code></td>
<td style="text-align:left">未实现的命令，使用 <code>exec_inv</code>（定义在 <code>special.c</code> 中） 构造 <code>opcode_entry</code></td>
</tr>
<tr>
<td style="text-align:left"><code>make_group(name, item0, item1, item2, item3, item4, item5, item6, item7)</code></td>
<td style="text-align:left">用于实现 <code>sub /5</code> 这种根据第二个指令码 <code>/5</code> 区分不同指令的情况。会自动生成一个 <code>exec_name</code> 的统一执行函数，并根据 <code>decoding.ext_opcode</code> 分配到指定执行函数。</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDEXW(id, ex, w)   &#123;concat(decode_, id), concat(exec_, ex), w&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IDEX(id, ex)       IDEXW(id, ex, 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXW(ex, w)         &#123;NULL, concat(exec_, ex), w&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EX(ex)             EXW(ex, 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EMPTY              EX(inv)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> make_group(name, item0, item1, item2, item3, item4, item5, item6, item7) \</span></span><br><span class="line">  static opcode_entry concat(opcode_table_, name) [8] = &#123; \</span><br><span class="line">    <span class="comment">/* 0x00 */</span>	item0, item1, item2, item3, \</span><br><span class="line">    <span class="comment">/* 0x04 */</span>	item4, item5, item6, item7  \</span><br><span class="line">  &#125;; \</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">make_EHelper</span><span class="params">(name)</span> </span>&#123; \</span><br><span class="line">  idex(eip, &amp;concat(opcode_table_, name)[decoding.ext_opcode]); \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>make_group</code> 宏定义了一些组 <code>gp1</code> - <code>gp7</code>。对应于 80386 手册附录中组的划分。</p>
<h5 id="函数-exec_wrapper"><a class="markdownIt-Anchor" href="#函数-exec_wrapper"></a> 函数 exec_wrapper</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exec_wrapper</span><span class="params">(<span class="keyword">bool</span> print_flag)</span></span>;</span><br></pre></td></tr></table></figure>
<p>执行下一条指令。</p>
<ul>
<li>首先将当前的 <code>%eip</code> 保存到全局译码信息 <code>decoding</code> 的成员 <code>seq_eip</code> 中</li>
<li>然后将其地址被作为参数送进<code>exec_real()</code>函数中
<ul>
<li><code>seq</code> 代表顺序的意思, 当代码从 <code>exec_real()</code> 返回时，<code>decoding.seq_eip</code> 将会指向下一条指令的地址.</li>
</ul>
</li>
<li>调用 <code>update_eip</code> 更新 <code>%eip</code></li>
<li>调试模式下
<ul>
<li>记录日志（指令内容以及相关信息）</li>
<li>若 <code>print_flag</code> 为真，则显示 <code>decoding.asm_buf</code></li>
</ul>
</li>
</ul>
<h5 id="函数-exec_real"><a class="markdownIt-Anchor" href="#函数-exec_real"></a> 函数 exec_real</h5>
<ul>
<li>首先通过 <code>instr_fetch()</code> 函数(在 <code>include/cpu/exec.h</code> 中定义)进行取指， 得到指令的第一个字节, 将其解释成 <code>opcode</code> 并记录在全局译码信息 <code>decoding</code> 中.</li>
<li>根据 <code>opcode</code> 查阅译码查找表，得到操作数的宽度信息，并通过调用 <code>set_width()</code> 函数将其记录在全局译码信息 <code>decoding</code> 中</li>
<li>调用 <code>idex()</code> 对指令进行进一步的译码和执行</li>
</ul>
<h5 id="函数-set_width"><a class="markdownIt-Anchor" href="#函数-set_width"></a> 函数 set_width</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set_width</span><span class="params">(<span class="keyword">int</span> <span class="built_in">width</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>根据指令定义宽度（<code>opcode_entry.width</code>）指定所有操作数宽度（<code>decoding.src.width</code>）。</p>
<ul>
<li>如果定义宽度为 0，则采用译码结果（<code>decoding.is_operand_size_16</code>）</li>
</ul>
<h5 id="函数-idex"><a class="markdownIt-Anchor" href="#函数-idex"></a> 函数 idex</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Instruction Decode and EXecute */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">idex</span><span class="params">(<span class="keyword">vaddr_t</span> *eip, opcode_entry *e)</span></span>;</span><br></pre></td></tr></table></figure>
<p>调用译码查找表中的相应的译码函数（若存在）进行操作数的译码，译码过程结束之后, 会调用译码查找表中的相应的执行函数来进行真正的执行操作。</p>
<h5 id="函数-update_eip"><a class="markdownIt-Anchor" href="#函数-update_eip"></a> 函数 update_eip</h5>
<p>根据当前指令是否为跳转指令，更新 <code>%eip</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update_eip</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (decoding.is_jmp) &#123; decoding.is_jmp = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; cpu.eip = decoding.seq_eip; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="memory"><a class="markdownIt-Anchor" href="#memory"></a> memory/</h2>
<h3 id="memoryc"><a class="markdownIt-Anchor" href="#memoryc"></a> memory.c</h3>
<p>定义了宏 <code>PMEM_SIZE</code> 指定物理内存大小。 实现了 <code>include/memory/memory.h</code> 中的函数 <code>paddr_read</code>，<code>paddr_write</code>，<code>vaddr_read</code>，<code>vaddr_write</code>。</p>
<ul>
<li><code>vaddr_read, vaddr_write</code> 的实现调用了 <code>paddr_read</code> 和 <code>paddr_write</code>。</li>
<li>为支持内存映射 I/O，<code>paddr_read, paddr_write</code> 的实现加入了对内存映射 I/O 的判断。</li>
</ul>
<h2 id="device"><a class="markdownIt-Anchor" href="#device"></a> device/</h2>
<h3 id="io"><a class="markdownIt-Anchor" href="#io"></a> io/</h3>
<h4 id="mmioc"><a class="markdownIt-Anchor" href="#mmioc"></a> mmio.c</h4>
<p>定义了宏 <code>MMIO_SPACE_MAX</code> 指定内存映射空间大小。 定义了结构体 <code>MMIO_t</code> 保存 MMIO 信息。</p>
<p>实现了 <code>include/device/mmio.h</code> 中的函数。</p>
<ul>
<li>在 <code>mmio_read</code> 和 <code>mmio_write</code> 中，调用了回调函数。</li>
</ul>
<h4 id="port-ioc"><a class="markdownIt-Anchor" href="#port-ioc"></a> port-io.c</h4>
<p>定义了宏 <code>PORT_IO_SPACE_MAX</code> 指定内存映射空间大小。 定义了结构体 <code>PIO_t</code> 保存 MMIO 信息。</p>
<p>实现了 <code>include/device/port-io.h</code> 中的函数。</p>
<ul>
<li>在 <code>pio_read_common</code> 和 <code>pio_write_common</code> 中，调用了回调函数。</li>
<li>基于 <code>pio_read_common</code> 和 <code>pio_write_common</code> 实现了不同的端口读写函数</li>
</ul>
<h3 id="devicec"><a class="markdownIt-Anchor" href="#devicec"></a> device.c</h3>
<p>提供初始化和控制设备的一些函数。含有和SDL库相关的代码，NEMU使用SDL库来实现设备的模拟。</p>
<table>
<thead>
<tr>
<th style="text-align:left">宏</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>TIMER_HZ</code></td>
<td style="text-align:left">时钟频率</td>
</tr>
<tr>
<td style="text-align:left"><code>VGA_HZ</code></td>
<td style="text-align:left">VGA 刷新频率</td>
</tr>
</tbody>
</table>
<h4 id="函数-init_device"><a class="markdownIt-Anchor" href="#函数-init_device"></a> 函数 init_device</h4>
<p>用于初始化设备：串口， 时钟， 键盘， VGA四种设备。 其中在初始化 VGA 时还会进行一些和SDL相关的初始化工作， 包括创建窗口， 设置显示模式等. 最后还会注册一个100Hz的定时器， 每隔0.01秒就会调用一次 <code>device_update()</code> 函数。</p>
<h4 id="函数-device_update"><a class="markdownIt-Anchor" href="#函数-device_update"></a> 函数 device_update</h4>
<p>主要进行一些设备的模拟操作, 包括以50Hz的频率刷新屏幕, 以及检测是否有按键按下/释放.</p>
<p>需要说明的是， 代码中注册的定时器是虚拟定时器， 它只会在 NEMU 处于用户态的时候进行计时： 如果 NEMU 在 <code>ui_mainloop()</code> 中等待用户输入， 定时器将不会计时; 如果 NEMU 进行大量的输出， 定时器的计时将会变得缓慢. 因此除非你在进行调试， 否则尽量避免大量输出的情况， 从而影响定时器的工作。</p>
<h3 id="serialc"><a class="markdownIt-Anchor" href="#serialc"></a> serial.c</h3>
<p>串口设备。 模拟了串口的功能。 其大部分功能也被简化，只保留了数据寄存器和状态寄存器。串口初始化时会分别注册 <code>0x3F8</code> 和 <code>0x3FC</code> 处长度为1个字节的端口，分别作为数据寄存器和状态寄存器。由于NEMU串行模拟计算机系统的工作，串口的状态寄存器可以一直处于空闲状态; 每当CPU往数据寄存器中写入数据时，串口会将数据传送到主机的标准输出。</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数/宏</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>init_serial()</code></td>
<td style="text-align:left">初始化设备</td>
</tr>
<tr>
<td style="text-align:left"><code>SERIAL_PORT=0x3F8</code></td>
<td style="text-align:left">端口 I/O 地址</td>
</tr>
</tbody>
</table>
<h3 id="timerc"><a class="markdownIt-Anchor" href="#timerc"></a> timer.c</h3>
<p>时钟设备。 模拟了i8253计时器的功能. 计时器的大部分功能都被简化, 只保留了&quot;发起时钟中断&quot;的功能. 同时添加了一个自定义的RTC(Real Time Clock), 初始化时将会注册0x48处的端口作为RTC寄存器, CPU可以通过I/O指令访问这一寄存器, 获得当前时间(单位是ms).</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数/宏</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>init_timer()</code></td>
<td style="text-align:left">初始化设备</td>
</tr>
<tr>
<td style="text-align:left"><code>RTC_PORT=0x48</code></td>
<td style="text-align:left">端口 I/O 地址</td>
</tr>
</tbody>
</table>
<h3 id="keyboardc"><a class="markdownIt-Anchor" href="#keyboardc"></a> keyboard.c</h3>
<p>键盘设备。 模拟了i8042通用设备接口芯片的功能. 其大部分功能也被简化, 只保留了键盘接口. i8042初始化时会注册 <code>0x60</code> 处的端口（长度为 4）作为数据寄存器. 每当用户敲下/释放按键时, 将会把相应的键盘码放入数据寄存器, CPU可以通过端口I/O访问数据寄存器, 获得键盘码; 当无按键可获取时, 将会返回 <code>_KEY_NONE</code> . 在AM中, 我们约定通码的值为 <code>断码 | KEYDOWN_MASK</code>.</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数/宏</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>init_i8042()</code></td>
<td style="text-align:left">初始化设备</td>
</tr>
<tr>
<td style="text-align:left"><code>I8042_DATA_PORT=0x60</code></td>
<td style="text-align:left">端口 I/O 地址</td>
</tr>
<tr>
<td style="text-align:left"><code>KEYDOWN_MASK=0x8000</code></td>
<td style="text-align:left">通码 MASK</td>
</tr>
<tr>
<td style="text-align:left"><code>KEY_QUEUE_LEN</code></td>
<td style="text-align:left">键队列长度</td>
</tr>
</tbody>
</table>
<h3 id="vgac"><a class="markdownIt-Anchor" href="#vgac"></a> vga.c</h3>
<p>VGA 设备。 模拟了VGA的功能. VGA初始化时注册了从 <code>0x40000</code> 开始的一段用于映射到video memory的物理内存. 在NEMU中, video memory是唯一使用内存映射I/O方式访问的I/O空间. 代码只模拟了400x300x32的图形模式, 一个像素占32个bit的存储空间, R(red), G(green), B(blue), A(alpha)各占8 bit, 其中VGA不使用alpha的信息。VGA 设备同时注册了位于 <code>0x100</code> 的长度为 4 的端口存储屏幕大小信息。</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数/宏</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>init_vga()</code></td>
<td style="text-align:left">初始化设备</td>
</tr>
<tr>
<td style="text-align:left"><code>SCREEN_PORT=0x100</code></td>
<td style="text-align:left">端口 I/O 地址</td>
</tr>
<tr>
<td style="text-align:left"><code>VMEM=0x40000</code></td>
<td style="text-align:left">内存映射 I/O 地址</td>
</tr>
<tr>
<td style="text-align:left"><code>SCREEN_H</code></td>
<td style="text-align:left">屏幕高度</td>
</tr>
<tr>
<td style="text-align:left"><code>SCREEN_W</code></td>
<td style="text-align:left">屏幕宽度</td>
</tr>
</tbody>
</table>
<h2 id="monitor"><a class="markdownIt-Anchor" href="#monitor"></a> monitor/</h2>
<p>监视器部分实现（也包含 NEMU 执行主循环）。</p>
<h3 id="monitorc"><a class="markdownIt-Anchor" href="#monitorc"></a> monitor.c</h3>
<h4 id="函数-init_monitor"><a class="markdownIt-Anchor" href="#函数-init_monitor"></a> 函数 init_monitor</h4>
<p>初始化监视器并启动（用于 <code>main.c/main</code> 中）。</p>
<ul>
<li>解析并处理命令行参数</li>
<li>初始化日志文件</li>
<li>寄存器测试（调用 <code>reg_test()</code>，实现在 <code>src/cpu/reg.c</code>）</li>
<li>加载程序镜像（根据命令行参数，如果为空，则调用 <code>load_default_img()</code> 加载默认镜像）</li>
<li>启动环境（调用 <code>restart()</code>，初始化应用程序入口点，寄存器值）</li>
<li>编译正则表达式（调用 <code>init_regex()</code>，实现在 <code>src/monitor/debug/expr.c</code>）</li>
<li>初始化监视点池（调用 <code>init_wp_pool()</code>，实现在 <code>src/monitor/debug/watchpoint.c</code>）</li>
<li>初始化设备（调用 <code>init_device()</code>，实现在 <code>src/device/device.c</code>）</li>
<li>初始化差异测试（调用 <code>init_difftest()</code>，实现在 <code>src/monitor/diff-test.c</code>）</li>
<li>显示欢迎界面</li>
<li>返回是否为批处理模式（根据命令行参数）</li>
</ul>
<p>注：</p>
<ul>
<li>命令行参数
<ul>
<li><code>[img_file]</code> 指定应用程序镜像文件</li>
<li><code>-b</code> 批处理模式</li>
<li><code>-l log_file</code> 指定日志文件</li>
<li><code>-d</code> 指定 Diff-Test 镜像文件</li>
</ul>
</li>
</ul>
<h3 id="cpu-execc"><a class="markdownIt-Anchor" href="#cpu-execc"></a> cpu-exec.c</h3>
<h4 id="函数-cpu_exec"><a class="markdownIt-Anchor" href="#函数-cpu_exec"></a> 函数 cpu_exec</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpu_exec</span><span class="params">(<span class="keyword">uint64_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<p>模拟 CPU 工作。</p>
<ul>
<li>判断 NEMU 状态（查看 <code>nemu_state</code>，定义在 <code>include/monitor/monitor.h</code>）</li>
<li>若指令数 <code>n</code> 小于 <code>MAX_INSTR_TO_PRINT</code> （默认为 10），则打印每条指令。</li>
<li>开始执行指令
<ul>
<li>调用 <code>exec_wrapper</code> 执行下一条指令（传入是否打印指令标记）</li>
<li>检查监视点状态是否有更新</li>
<li>更新设备信息</li>
<li>判断 NEMU 状态（查看 <code>nemu_state</code>），决定是否退出</li>
</ul>
</li>
<li>执行完 <code>n</code> 条指令后，将 NEMU 状态置为结束（<code>NEMU_END</code>）</li>
</ul>
<p>注：</p>
<ul>
<li>执行某条命令后
<ul>
<li>若 NEMU 状态为结束（<code>NEMU_END</code>），则检查程序返回值（<code>cpu.eax</code>）是否为 0（是否正常退出）。并输出 <code>HIT GOOD TRAP</code>（正常退出） 或 <code>HIT BAD TRAP</code>（非正常退出）。</li>
</ul>
</li>
</ul>
<h3 id="debug"><a class="markdownIt-Anchor" href="#debug"></a> debug/</h3>
<h4 id="watchpointc"><a class="markdownIt-Anchor" href="#watchpointc"></a> watchpoint.c</h4>
<p>定义了监视点内存池及其相关的函数。</p>
<ul>
<li><code>wp_pool</code> 监视点池</li>
<li><code>head</code> 使用中的监视点链表头指针</li>
<li><code>free_</code> 监视点池中未使用的监视点链表头指针</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>init_wp_pool()</code></td>
<td style="text-align:left">初始化监视点内存池</td>
</tr>
<tr>
<td style="text-align:left"><code>clearWP(wp)</code></td>
<td style="text-align:left">清空某监视点的下一项指针</td>
</tr>
<tr>
<td style="text-align:left"><code>WP *getHeadWP()</code></td>
<td style="text-align:left">获取 <code>head</code></td>
</tr>
<tr>
<td style="text-align:left"><code>WP *createWP()</code></td>
<td style="text-align:left">申请使用一个新监视点（内部调用 <code>new_wp()</code> 并更新链表信息）</td>
</tr>
<tr>
<td style="text-align:left"><code>removeWP(no)</code></td>
<td style="text-align:left">删除指定编号的监视点</td>
</tr>
<tr>
<td style="text-align:left"><code>WP *new_wp()</code></td>
<td style="text-align:left">（私有）从内存池中获取下一个能使用的监视点，并作一定预处理</td>
</tr>
<tr>
<td style="text-align:left"><code>free_wp(wp)</code></td>
<td style="text-align:left">（私有）释放一个监视点</td>
</tr>
</tbody>
</table>
<h4 id="exprc"><a class="markdownIt-Anchor" href="#exprc"></a> expr.c</h4>
<p>实现了 <code>expr.h/expr</code> 函数，实现表达式解析和求值。</p>
<h5 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h5>
<ul>
<li><code>PRI_NEG</code> 取负运算优先级</li>
<li><code>PRI_POINT</code> 解引用运算优先级</li>
<li>形如 <code>TK_TYPE</code> 的 Token 类型枚举</li>
</ul>
<h5 id="数组-rules"><a class="markdownIt-Anchor" href="#数组-rules"></a> 数组 rules</h5>
<p>规定了使用正则表达式解析 Token 的规则。</p>
<table>
<thead>
<tr>
<th style="text-align:left">成员</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>regex</code></td>
<td style="text-align:left">正则表达式字符串</td>
</tr>
<tr>
<td style="text-align:left"><code>token_type</code></td>
<td style="text-align:left">对应 Token 类型，可用 <code>TK_TYPE</code> 枚举或字符（如 <code>+</code>）表示</td>
</tr>
<tr>
<td style="text-align:left"><code>opPri</code></td>
<td style="text-align:left">运算符 Token 的优先级</td>
</tr>
</tbody>
</table>
<h5 id="数组-re"><a class="markdownIt-Anchor" href="#数组-re"></a> 数组 re</h5>
<p>根据 <code>rules</code> 编译后的正则表达式。</p>
<h5 id="函数-init_regex"><a class="markdownIt-Anchor" href="#函数-init_regex"></a> 函数 <code>init_regex</code></h5>
<p>根据 <code>rules</code> 编译到 <code>re</code></p>
<h5 id="结构体-token"><a class="markdownIt-Anchor" href="#结构体-token"></a> 结构体 Token</h5>
<p>识别后的 Token.</p>
<table>
<thead>
<tr>
<th style="text-align:left">成员</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>type</code></td>
<td style="text-align:left">Token 类型，可用 <code>TK_TYPE</code> 枚举或字符（如 <code>+</code>）表示</td>
</tr>
<tr>
<td style="text-align:left"><code>isOp</code></td>
<td style="text-align:left">标记此 Token 是否是运算符</td>
</tr>
<tr>
<td style="text-align:left"><code>isValue</code></td>
<td style="text-align:left">标记此 Token 是否是值</td>
</tr>
<tr>
<td style="text-align:left"><code>str</code></td>
<td style="text-align:left">Token 的原始字符串</td>
</tr>
<tr>
<td style="text-align:left"><code>data</code></td>
<td style="text-align:left">值类型的实际数据</td>
</tr>
<tr>
<td style="text-align:left"><code>priority</code></td>
<td style="text-align:left">运算符的优先级</td>
</tr>
</tbody>
</table>
<ul>
<li><code>isOp</code> 和 <code>isValue</code> 多用于区分特殊单目运算符，如解引用和取负</li>
<li><code>data</code> 多存储经过预处理的数据，如转换后的整数</li>
</ul>
<blockquote>
<p>解析后的 Token 列表存储在数组 <code>tokens</code> 中。 <code>nr_token</code> 指示 <code>token</code> 有效长度。</p>
</blockquote>
<h5 id="函数-make_token"><a class="markdownIt-Anchor" href="#函数-make_token"></a> 函数 make_token</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">make_token</span><span class="params">(<span class="keyword">char</span> *e)</span></span></span><br></pre></td></tr></table></figure>
<p>根据字符串解析 Token 列表，返回是否解析成功。</p>
<p>实现思路：使用 <code>re</code> 依次尝试每一种匹配，直到遇到第一个成功匹配，根据其规则的 <code>token_type</code> 生成 Token，存入 <code>token</code>。</p>
<ul>
<li>函数 <code>toInteger</code> ：以指定进制完成字符串到数的转换，用于 十进制，二进制，八进制，十六进制 数的解析。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">uint32_t</span> <span class="title">toInteger</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">uint32_t</span> base)</span></span></span><br></pre></td></tr></table></figure>
<h5 id="函数-evalwithtoken"><a class="markdownIt-Anchor" href="#函数-evalwithtoken"></a> 函数 evalWithToken</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">evalWithToken</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">bool</span> * success)</span></span></span><br></pre></td></tr></table></figure>
<p>求解 <code>tokens[l..r]</code> 中的表达式的值。</p>
<p>实现思路：单 Token 特殊处理，然后处理外围括号情况，然后确定最后计算的运算符，分割成 <code>left</code> 和 <code>right</code> 两部分，然后递归解决，最后合并，</p>
<ul>
<li>函数 <code>checkExtraP</code> 判断 <code>tokens[l..r]</code> 是否外围为括号且括号匹配正常。</li>
<li>函数 <code>getReg</code> 根据寄存器名获取寄存器值，使用了 <code>regMap</code></li>
<li>数组 <code>regMap</code> 标识寄存器名与对应的偏移量（<code>cpu.gpr</code>）</li>
</ul>
<h5 id="函数-expr"><a class="markdownIt-Anchor" href="#函数-expr"></a> 函数 expr</h5>
<p>对 <code>expr.h/expr</code> 的实现，调用了 <code>make_token</code> 和 <code>evalWithToken</code>。</p>
<h4 id="uic"><a class="markdownIt-Anchor" href="#uic"></a> ui.c</h4>
<p>监视器 CUI 部分。</p>
<h5 id="函数族-fc2color"><a class="markdownIt-Anchor" href="#函数族-fc2color"></a> 函数族 fc2color</h5>
<p>控制台字体颜色控制。</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>fc2red</code></td>
<td style="text-align:left">前景色设为红色</td>
</tr>
<tr>
<td style="text-align:left"><code>fc2green</code></td>
<td style="text-align:left">前景色设为绿色</td>
</tr>
<tr>
<td style="text-align:left"><code>fc2yellow</code></td>
<td style="text-align:left">前景色设为黄色</td>
</tr>
<tr>
<td style="text-align:left"><code>fc2blue</code></td>
<td style="text-align:left">前景色设为蓝色</td>
</tr>
<tr>
<td style="text-align:left"><code>fc2purple</code></td>
<td style="text-align:left">前景色设为紫色</td>
</tr>
<tr>
<td style="text-align:left"><code>csClear</code></td>
<td style="text-align:left">清除所有控制台设置</td>
</tr>
</tbody>
</table>
<h5 id="函数族-cmd_item"><a class="markdownIt-Anchor" href="#函数族-cmd_item"></a> 函数族 cmd_item</h5>
<p>不同命令的实现。</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>cmd_help</code></td>
<td style="text-align:left">获取帮助</td>
</tr>
<tr>
<td style="text-align:left"><code>cmd_q</code></td>
<td style="text-align:left">退出</td>
</tr>
<tr>
<td style="text-align:left"><code>cmd_c</code></td>
<td style="text-align:left">继续执行（调用 <code>cpu_exec(-1)</code>，实现在 <code>src/monitor/cpu-exec.c</code>）</td>
</tr>
<tr>
<td style="text-align:left"><code>cmd_si</code></td>
<td style="text-align:left">执行单步指令</td>
</tr>
<tr>
<td style="text-align:left"><code>cmd_info name</code></td>
<td style="text-align:left">查看信息</td>
</tr>
<tr>
<td style="text-align:left"><code>cmd_x N expr</code></td>
<td style="text-align:left">显示地址从 <code>expr</code> 的值开始的 <code>N</code> 个字节值</td>
</tr>
<tr>
<td style="text-align:left"><code>cmd_p expr</code></td>
<td style="text-align:left">计算表达式的值</td>
</tr>
<tr>
<td style="text-align:left"><code>cmd_w expr</code></td>
<td style="text-align:left">新建监视点，监视表达式为 <code>expr</code></td>
</tr>
<tr>
<td style="text-align:left"><code>cmd_d no</code></td>
<td style="text-align:left">删除指定编号的监视点</td>
</tr>
</tbody>
</table>
<ul>
<li>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd_info</span><br></pre></td></tr></table></figure>
<ul>
<li><code>r</code> 打印所有寄存器信息</li>
<li><code>w</code> 打印所有监视点信息</li>
</ul>
</li>
</ul>
<h5 id="数组-cmd_table"><a class="markdownIt-Anchor" href="#数组-cmd_table"></a> 数组 cmd_table</h5>
<table>
<thead>
<tr>
<th style="text-align:left">成员</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>name</code></td>
<td style="text-align:left">命令名（用于识别命令）</td>
</tr>
<tr>
<td style="text-align:left"><code>description</code></td>
<td style="text-align:left">命令描述（用于帮助列表）</td>
</tr>
<tr>
<td style="text-align:left"><code>handler</code></td>
<td style="text-align:left">命令实现函数指针</td>
</tr>
</tbody>
</table>
<h5 id="函数-ui_mainloop"><a class="markdownIt-Anchor" href="#函数-ui_mainloop"></a> 函数 ui_mainloop</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ui_mainloop</span><span class="params">(<span class="keyword">int</span> is_batch_mode)</span></span>;</span><br></pre></td></tr></table></figure>
<p>NEMU 以及其 CUI 主循环，不断读取命令，并执行。</p>
<ul>
<li>如果是批处理模式（<code>is_batch_mode</code> 为真），则直接执行应用程序，不监听用户命令。</li>
</ul>
<h3 id="diff-test"><a class="markdownIt-Anchor" href="#diff-test"></a> diff-test/</h3>
<p>差异测试实现。</p>
<blockquote>
<p>如果有一种方法能够表达指令的正确行为, 我们就可以基于这种方法来进行类似assert()的检查了。那么, 究竟什么地方表达了指令的正确行为呢? 最直接的, 当然就是i386手册了, 但是我们恰恰就是根据i386手册中的指令行为来在NEMU中实现指令的, 同一套方法不能既用于实现也用于检查. 如果有一个i386手册的参考实现就好了. 嘿! 我们用的真机不就是根据i386手册实现出来的吗? 我们让在NEMU中执行的每条指令也在真机中执行一次, 然后对比NEMU和真机的状态, 如果NEMU和真机的状态不一致, 我们就捕捉到error了! 这实际上是一种非常奏效的测试方法, 在软件测试领域称为differential testing(后续简称DiffTest). 我们刚才提到了&quot;状态&quot;, 那&quot;状态&quot;具体指的是什么呢? 我们在PA1中已经认识到, 计算机就是一个数字电路. 那么, “计算机的状态&quot;就恰恰是那些时序逻辑部件的状态, 也就是寄存器和内存的值. 其实仔细思考一下, 计算机执行指令, 就是修改这些时序逻辑部件的状态的过程. 要检查指令的实现是否正确, 只要检查这些时序逻辑部件中的值是否一致就可以了! DiffTest可以非常及时地捕捉到error, 第一次发现NEMU的寄存器或内存的值与真机不一样的时候, 就是因为当时执行的指令实现有误导致的. 这时候其实离error非常接近, 防止了error进一步传播的同时, 要回溯找到fault也容易得多. 多么美妙的功能啊! 背后还蕴含着计算机本质的深刻原理! 但很遗憾, 不要忘记了, 真机上是运行了操作系统GNU/Linux的, 而NEMU中的测试程序是运行在x86-nemu上的, 我们无法在native中运行编译到x86-nemu的AM程序. 所以, 我们需要的不仅是一个i386手册的正确实现, 而且需要在上面能正确运行x86-nemu的AM程序. 事实上, QEMU就是一个不错的参考实现. 它是一个虚拟出来的完整的x86计算机系统, 而NEMU的目标只是虚拟出x86的一个子集, 能在NEMU上运行的程序, 自然也能在QEMU上运行. 因此, 为了通过DiffTest的方法测试NEMU实现的正确性, 我们让NEMU和QEMU逐条指令地执行同一个客户程序. 双方每执行完一条指令, 就检查各自的寄存器和内存的状态, 如果发现状态不一致, 就马上报告错误, 停止客户程序的执行.</p>
</blockquote>
<h4 id="diff-testh"><a class="markdownIt-Anchor" href="#diff-testh"></a> diff-test.h</h4>
<p>定义了宏 <code>DIFFTEST_REG_SIZE</code> 规定访问的寄存器大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DIFFTEST_REG_SIZE (sizeof(uint32_t) * 9) <span class="comment">// GRPs + EIP</span></span></span><br></pre></td></tr></table></figure>
<h4 id="refc"><a class="markdownIt-Anchor" href="#refc"></a> ref.c</h4>
<p>在 DUT(Design Under Test, 测试对象)和 REF(Reference, 参考实现) 之间定义了一组 API。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从DUT host memory的 src 处拷贝 n 字节到REF guest memory的 dest 处</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">difftest_memcpy_from_dut</span><span class="params">(<span class="keyword">paddr_t</span> dest, <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 获取REF的寄存器状态到 r </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">difftest_getregs</span><span class="params">(<span class="keyword">void</span> *r)</span></span>;</span><br><span class="line"><span class="comment">// 设置REF的寄存器状态为 r </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">difftest_setregs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *r)</span></span>;</span><br><span class="line"><span class="comment">// 让REF执行 n 条指令</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">difftest_exec</span><span class="params">(<span class="keyword">uint64_t</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 初始化REF的DiffTest功能</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">difftest_init</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中寄存器状态 <code>r</code> 要求寄存器的值按照某种顺序排列，若未按要求顺序排列， <code>difftest_getregs()</code> 和 <code>difftest_setregs()</code> 的行为是未定义的. REF 需要实现这些 API，DUT会使用这些 API 来进行 DiffTest 。</li>
</ul>
<h4 id="diff-testc"><a class="markdownIt-Anchor" href="#diff-testc"></a> diff-test.c</h4>
<p>定义了变量 <code>is_skip_ref</code>，<code>is_skip_dut</code> 用于标记忽视一些指令处的比对。（可结合 <code>difftest_step</code> 实现） 定义了函数 <code>difftest_skip_ref</code>，<code>difftest_skip_dut</code> 标记上述变量。</p>
<h5 id="函数-init_difftest"><a class="markdownIt-Anchor" href="#函数-init_difftest"></a> 函数 init_difftest</h5>
<p>初始化 Diff-Test。</p>
<ul>
<li>打开动态库文件 <code>ref_so_file</code></li>
<li>从动态库中分别读取上述 API 的符号</li>
<li>对 REF 的 DIffTest功能进行初始化，此时会启动 REF，代码还会对 REF 的状态进行一些初始化工作，REF 运行在后台，因此将看不到 REF 的任何输出</li>
<li>将 DUT 的 guest memory 拷贝到 REF 中</li>
<li>将 DUT 的寄存器状态拷贝到 REF 中</li>
</ul>
<h5 id="函数-difftest_step"><a class="markdownIt-Anchor" href="#函数-difftest_step"></a> 函数 difftest_step</h5>
<p>用于逐条指令执行后的状态对比。它会在 <code>exec_wrapper()</code> 的最后被调用。在这里读取 REF 的寄存器并与 NEMU 寄存器状态比对。</p>
<h2 id="misc"><a class="markdownIt-Anchor" href="#misc"></a> misc/</h2>
<h3 id="logoc"><a class="markdownIt-Anchor" href="#logoc"></a> logo.c</h3>
<p>定义了字符数组 <code>logo</code> 存储 i386 Manual Logo。用于 <code>inv</code> 指令（位于 <code>special.c</code> 中）。</p>
<h1 id="4-tools"><a class="markdownIt-Anchor" href="#4-tools"></a> 4 tools/</h1>
<h2 id="gen-exprc"><a class="markdownIt-Anchor" href="#gen-exprc"></a> gen-expr.c</h2>
<p>生成 C 表达式，用于测试表达式求值功能。</p>
<h2 id="qemu-diff"><a class="markdownIt-Anchor" href="#qemu-diff"></a> qemu-diff</h2>
<p>QEMU 实现，用于 Diff-Test。编译成动态库 <code>qemu-so</code>，传入 nemu 的 <code>-d</code> 参数中。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://Dragonliu2022.github.io/2022/04/23/PA答疑之代码框架/" title="PA答疑之代码框架" target="_blank" rel="external">https://Dragonliu2022.github.io/2022/04/23/PA答疑之代码框架/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/dragonliu2018" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.png" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/dragonliu2018" target="_blank"><span class="text-dark">Dragon&#39;s Blogs</span><small class="ml-1x">Synthesis</small></a></h3>
        <div>Life is painting a picture, not doing a sum.</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2022/04/26/模型的评价指标/" title="模型的评价指标"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2022/04/23/PA答疑之IDEX和IDEXW/" title="PA答疑之IDEX和IDEXW"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">    <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/dragonliu2018" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script src="/js/plugin.min.js"></script>
<script src="/js/application.js"></script>

    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>





   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: 'Pbjl2Wajl9och0xVbR5eqoH1-gzGzoHsz',
    appKey: 'PgxFh1wV6pyMMllhxs7NJijb',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>